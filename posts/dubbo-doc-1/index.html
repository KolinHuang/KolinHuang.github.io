<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Dubbo文档阅读笔记-用法 | 银杏叶</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Dubbo文档阅读笔记-用法" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="网站应用演进的过程" /><meta property="og:description" content="网站应用演进的过程" /><link rel="canonical" href="www.yucaihuang.com/posts/dubbo-doc-1/" /><meta property="og:url" content="www.yucaihuang.com/posts/dubbo-doc-1/" /><meta property="og:site_name" content="银杏叶" /><meta property="og:image" content="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-04T13:40:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" /><meta property="twitter:title" content="Dubbo文档阅读笔记-用法" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"image":"https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/posts/dubbo-doc-1/"},"url":"www.yucaihuang.com/posts/dubbo-doc-1/","author":{"@type":"Person","name":"Kol Huang"},"description":"网站应用演进的过程","dateModified":"2021-06-04T13:40:00+08:00","datePublished":"2021-06-04T13:40:00+08:00","headline":"Dubbo文档阅读笔记-用法","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">银杏叶</a></div><div class="site-subtitle font-italic">把开源的变成自己的，把自己的变成祖传的!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Dubbo文档阅读笔记-用法</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Dubbo文档阅读笔记-用法</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Jun 4, 2021, 1:40 PM +0800" > Jun 4 <i class="unloaded">2021-06-04T13:40:00+08:00</i> </span> by <span class="author"> Kol Huang</div></div><div class="post-content"> <img src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" class="post-preview-img"><h2 id="网站应用演进的过程">网站应用演进的过程</h2><ul><li>单一应用架构：当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</li><li>垂直应用架构：当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</li><li>分布式服务架构：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</li><li>流动计算架构：当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</li></ul><h2 id="dubbo要解决的问题">Dubbo要解决的问题</h2><p>在大规模服务化之前，只用RMI或Hessian等RPC工具就能实现简单得服务暴露和引用，通过F5等硬件进行负载均衡。</p><p>需求1：但是服务越来越多时，服务URL配置管理变得困难，硬件负载均衡的单点压力越来越大，所以需要一个服务注册中心，用于动态地注册和发现服务，并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p><p>需求2：进一步发展，服务之间的依赖关系变得错综复杂，这时候需要有一个工具帮助我们自动梳理服务之间的依赖关系图。</p><p>需求3：接着，对于单个服务来说，访问量急剧增加时，服务的容量问题就凸显出来，这个服务需要多少机器支撑，什么时候该加机器？所以需要有一个监控中心帮助我们来监控服务调用的情况，让管理人员随时对服务进行动态调整。</p><h2 id="dubbo的架构">Dubbo的架构</h2><p>主要有5个角色：</p><ol><li>Provider：服务的提供者</li><li>Consumer：服务的调用者</li><li>Registry：服务注册与发现的注册中心</li><li>Monitor：统计服务调用次数和调用时间的监控中心</li><li>Container：服务运行的容器</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210602094408318.png" alt="image-20210602094408318" /></p><p>调用关系：</p><ol><li>服务容器负责启动、加载、运行服务提供者</li><li>服务提供者在启动时，向注册中心注册自己提供的服务</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务</li><li>注册中心返回服务提供者列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li><li>服务消费者从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送给监控中心</li></ol><h2 id="简单用法">简单用法</h2><p><code class="language-plaintext highlighter-rouge">remote_provider.xml</code>：服务提供者配置服务暴露</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- 和本地服务一样实现远程服务 --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">“xxxService”</span> <span class="na">class=</span><span class="s">“com.xxx.XxxServiceImpl”</span> <span class="nt">/&gt;</span> 
<span class="c">&lt;!-- 增加暴露远程服务配置 --&gt;</span>
<span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">“com.xxx.XxxService”</span> <span class="na">ref=</span><span class="s">“xxxService”</span> <span class="nt">/&gt;</span> 
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Remote-consumer.xml</code>：服务消费者配置服务引用</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- 增加引用远程服务配置 --&gt;</span>
<span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">“xxxService”</span> <span class="na">interface=</span><span class="s">“com.xxx.XxxService”</span> <span class="nt">/&gt;</span>
<span class="c">&lt;!-- 和本地服务一样使用远程服务 --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">“xxxAction”</span> <span class="na">class=</span><span class="s">“com.xxx.XxxAction”</span><span class="nt">&gt;</span> 
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">“xxxService”</span> <span class="na">ref=</span><span class="s">“xxxService”</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><h2 id="dubbo配置">Dubbo配置</h2><p><strong>XML配置：</strong></p><p><code class="language-plaintext highlighter-rouge">provider.xml</code>：服务提供者需要的配置信息</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xmlns:dubbo=</span><span class="s">"http://dubbo.apache.org/schema/dubbo"</span>
       <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dubbo:application</span> <span class="na">name=</span><span class="s">"demo-provider"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">address=</span><span class="s">"zookeeper://127.0.0.1:2181"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">port=</span><span class="s">"20890"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"demoService"</span> <span class="na">class=</span><span class="s">"org.apache.dubbo.samples.basic.impl.DemoServiceImpl"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"org.apache.dubbo.samples.basic.api.DemoService"</span> <span class="na">ref=</span><span class="s">"demoService"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">consumer.xml</code>：服务消费者需要的配置信息</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xmlns:dubbo=</span><span class="s">"http://dubbo.apache.org/schema/dubbo"</span>
       <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dubbo:application</span> <span class="na">name=</span><span class="s">"demo-consumer"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">group=</span><span class="s">"aaa"</span> <span class="na">address=</span><span class="s">"zookeeper://127.0.0.1:2181"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"demoService"</span> <span class="na">check=</span><span class="s">"false"</span> <span class="na">interface=</span><span class="s">"org.apache.dubbo.samples.basic.api.DemoService"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><p>配置项：</p><div class="table-wrapper"><table><thead><tr><th>标签<th>用途<th>解释<tbody><tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:service/&gt;</code><td>服务配置<td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:reference/&gt;</code><td>引用配置<td>用于创建一个远程服务代理，一个引用可以指向多个注册中心<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:protocol/&gt;</code><td>协议配置<td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:application/&gt;</code><td>应用配置<td>用于配置当前应用信息，不管该应用是提供者还是消费者<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:module/&gt;</code><td>模块配置<td>用于配置当前模块信息，可选<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:registry/&gt;</code><td>注册中心配置<td>用于配置连接注册中心相关信息<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:monitor/&gt;</code><td>监控中心配置<td>用于配置连接监控中心相关信息，可选<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:provider/&gt;</code><td>提供方配置<td>当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:consumer/&gt;</code><td>消费方配置<td>当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:method/&gt;</code><td>方法配置<td>用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息<tr><td><code class="language-plaintext highlighter-rouge">&lt;dubbo:argument/&gt;</code><td>参数配置<td>用于指定方法参数配置</table></div><p><strong>动态配置中心</strong></p><p>启用动态配置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:config-center</span> <span class="na">address=</span><span class="s">"zookeeper://127.0.0.1:2181"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>或</p><div class="language-properties highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="py">dubbo.config-center.address</span><span class="p">=</span><span class="s">zookeeper://127.0.0.1:2181</span>
</pre></table></code></div></div><p><strong>Dubbo配置加载流程</strong></p><p>首先，从Dubbo支持的配置来源说起，默认有四种配置来源：</p><ul><li>JVM System Properties，-D 参数</li><li>Externalized Configuration，外部化配置</li><li>ServiceConfig、ReferenceConfig 等编程接口采集的配置</li><li>本地配置文件 dubbo.properties</li></ul><p>覆盖关系的优先级：System Properties &gt; Externalized Configuration &gt; Spring\API &gt; Local File</p><p>其次，Dubbo支持的所有配置都是properties格式的。</p><p>并且，Dubbo支持几种配置方式：</p><ol><li>Spring XML</li><li>Spring Annotation</li><li>Spring Boot Properties</li><li>API</li></ol><h2 id="dubbo的用法示例">Dubbo的用法示例</h2><h3 id="启动时检查">启动时检查</h3><p>Dubbo默认会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止Spring容器初始化，以便上线时能及早发现问题。</p><p>但是在某些情况下，我们可以通过配置<code class="language-plaintext highlighter-rouge">check="false"</code>关闭启动检查，比如不关心某些服务，或者出现了循环依赖则必须有有一方先启动。</p><p>关闭某个服务的启动时检查</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">check=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>关闭所有服务的启动时检查：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:consumer</span> <span class="na">check=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>关闭注册中心启动时检查：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:registry</span> <span class="na">check=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>当然也可以用properties或者JVM的 -D参数配置</p><h3 id="集群容错">集群容错</h3><p>在集群调用失败时，Dubbo提供了多种容错方案，默认为failover重试。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210602144634260.png" alt="image-20210602144634260" /></p><p>上图中，各个节点的关系解释：</p><ul><li><code class="language-plaintext highlighter-rouge">Invoker</code>是<code class="language-plaintext highlighter-rouge">Provider</code>的一个可调用<code class="language-plaintext highlighter-rouge">Service</code>的抽象，<code class="language-plaintext highlighter-rouge">Invoker</code>封装了<code class="language-plaintext highlighter-rouge">Provider</code>地址以及<code class="language-plaintext highlighter-rouge">Service</code>接口信息。</li><li><code class="language-plaintext highlighter-rouge">Directory</code>代表多个<code class="language-plaintext highlighter-rouge">Invoker</code>，可以把它看做<code class="language-plaintext highlighter-rouge">List&lt;Invoker&gt;</code>，但与<code class="language-plaintext highlighter-rouge">List</code>不同的是，它的值可能是动态变化的，比如注册中心推送变更。</li><li><code class="language-plaintext highlighter-rouge">Cluster</code>将<code class="language-plaintext highlighter-rouge">Directory</code>中的多个<code class="language-plaintext highlighter-rouge">Invoker</code>伪装成一个<code class="language-plaintext highlighter-rouge">Invoker</code>，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个。</li><li><code class="language-plaintext highlighter-rouge">Router</code>负责从多个<code class="language-plaintext highlighter-rouge">Invoker</code>中按路由规则选出子集，比如读写分离，应用隔离等。</li><li><code class="language-plaintext highlighter-rouge">LoadBalance</code>负责从多个<code class="language-plaintext highlighter-rouge">Invoker</code>中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。</li></ul><h3 id="集群容错模式">集群容错模式</h3><ul><li><p>Failover Cluster：默认的策略，失败自动切换，当出现失败，重试其他服务器，通常用于读操作，但是重试会带来更长的延迟，可通过设置<code class="language-plaintext highlighter-rouge">retries="2"</code>来设置重试次数，不包含第一次，即会重试2次。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">retries=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
或
<span class="nt">&lt;dubbo:reference</span> <span class="na">retries=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
或
<span class="nt">&lt;dubbo:reference&gt;</span>
    <span class="nt">&lt;dubbo:method</span> <span class="na">name=</span><span class="s">"findFoo"</span> <span class="na">retries=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/dubbo:reference&gt;</span>
</pre></table></code></div></div></li><li><p>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p></li><li><p>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p></li><li><p>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p></li><li><p>Forking Cluster：并行调用多个服务器，只要成功一个就返回。通常用于实时性比较高的读操作，但需要浪费更多的服务资源。可通过<code class="language-plaintext highlighter-rouge">forks="2"</code>来设置最大并行数。</p></li><li><p>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p></li></ul><p>集群模式的配置方法：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">cluster=</span><span class="s">"failsafe"</span> <span class="nt">/&gt;</span>
或
<span class="nt">&lt;dubbo:reference</span> <span class="na">cluster=</span><span class="s">"failsafe"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="负载均衡策略">负载均衡策略</h3><p>在集群负载均衡时，Dubbo提供了多种均衡策略，默认为random随机调用。</p><ul><li><code class="language-plaintext highlighter-rouge">Random LoadBalance</code>：随机，按权重设置随机概率。</li><li><code class="language-plaintext highlighter-rouge">RoundRobin LoadBalance</code>：轮询，按公约后的权重设置轮询比率。</li><li><code class="language-plaintext highlighter-rouge">LeastActive LoadBalance</code>：最少活跃数调用，相同活跃数随机，活跃数指调用前后计数差。慢的提供者收到更少的请求。</li><li><code class="language-plaintext highlighter-rouge">ConsistentHash LoadBalance</code>：一致性哈希，相同参数的请求总是发送到同一提供者。当某一台提供者挂掉时，原本发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动。</li></ul><p>配置方式：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"..."</span> <span class="na">loadbalance=</span><span class="s">"roundrobin"</span> <span class="nt">/&gt;</span>
或
<span class="nt">&lt;dubbo:reference</span> <span class="na">interface=</span><span class="s">"..."</span> <span class="na">loadbalance=</span><span class="s">"roundrobin"</span> <span class="nt">/&gt;</span>
或
<span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"..."</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dubbo:method</span> <span class="na">name=</span><span class="s">"..."</span> <span class="na">loadbalance=</span><span class="s">"roundrobin"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/dubbo:service&gt;</span>
或
<span class="nt">&lt;dubbo:reference</span> <span class="na">interface=</span><span class="s">"..."</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dubbo:method</span> <span class="na">name=</span><span class="s">"..."</span> <span class="na">loadbalance=</span><span class="s">"roundrobin"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/dubbo:reference&gt;</span>
</pre></table></code></div></div><h3 id="线程模型配置">线程模型配置</h3><p>如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。</p><p>但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。</p><p>如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。</p><p>因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210602155950298.png" alt="image-20210602155950298" /></p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">dispatcher=</span><span class="s">"all"</span> <span class="na">threadpool=</span><span class="s">"fixed"</span> <span class="na">threads=</span><span class="s">"100"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Dispatcher</code></p><ul><li><code class="language-plaintext highlighter-rouge">all</code>：所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。</li><li><code class="language-plaintext highlighter-rouge">direct</code>：所有消息都不派发到线程池，全部在IO线程上直接执行。</li><li><code class="language-plaintext highlighter-rouge">message</code>：只有请求响应消息派发到线程池，其他连接断开事件、心跳等消息直接在IO线程上执行。</li><li><code class="language-plaintext highlighter-rouge">execution</code>：只有请求消息派发到线程池，不含响应，响应和其他连接断开事件、心跳等消息直接在IO线程上执行。</li><li><code class="language-plaintext highlighter-rouge">connection</code>：在IO线程上，将连接断开事件放入队列，有序逐个执行，其他消息派发到线程池。</li></ul><p><code class="language-plaintext highlighter-rouge">ThreadPool</code></p><ul><li><code class="language-plaintext highlighter-rouge">fixed</code>：固定大小的线程池，启动时建立线程，不关闭，一直持有。（默认）</li><li><code class="language-plaintext highlighter-rouge">cached</code>：缓存线程池，空闲一分钟自动删除，需要时自动创建。</li><li><code class="language-plaintext highlighter-rouge">limited</code>：可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。</li><li><code class="language-plaintext highlighter-rouge">eager</code>：优先创建<code class="language-plaintext highlighter-rouge">worker</code>线程池。在任务数量大于<code class="language-plaintext highlighter-rouge">corePoolSize</code>但是小于<code class="language-plaintext highlighter-rouge">maximumPoolSize</code>时，优先创建<code class="language-plaintext highlighter-rouge">worker</code>来处理任务。当任务数量大于<code class="language-plaintext highlighter-rouge">maximumPoolSize</code>时，将任务放入阻塞队列中。阻塞队列充满时，抛出<code class="language-plaintext highlighter-rouge">RejectedExecutionException</code>异常。也就是先创建线程，再放队列，和JDK的实现不太一样。饱和策略是队列满了直接抛异常。</li></ul><h3 id="直连提供者">直连提供者</h3><p>在开发和测试环境下，经常需要绕过测试注册中心，只测试指定服务提供者，这时候可能需要点对点直连。<strong>点对点直连方式，将以服务接口为单位</strong>，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p><p>配置方式：</p><ol><li><p>XML配置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"xxxService"</span> <span class="na">interface=</span><span class="s">"com.alibaba.xxx.XxxService"</span> <span class="na">url=</span><span class="s">"dubbo://localhost:20890"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div></li><li><p>-D参数：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>java <span class="nt">-Dcom</span>.alibaba.xxx.XxxService<span class="o">=</span>dubbo://localhost:20890
</pre></table></code></div></div><p>key 为服务名，value 为服务提供者 url，此配置优先级最高，<code class="language-plaintext highlighter-rouge">1.0.15</code> 及以上版本支持。</p></li><li><p>文件映射：</p><p>如果服务比较多，也可以用文件映射，用 <code class="language-plaintext highlighter-rouge">-Ddubbo.resolve.file</code> 指定映射文件路径，此配置优先级高于 <code class="language-plaintext highlighter-rouge">&lt;dubbo:reference&gt;</code> 中的配置，如：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>java <span class="nt">-Ddubbo</span>.resolve.file<span class="o">=</span>xxx.properties
</pre></table></code></div></div><p>然后在映射文件 <code class="language-plaintext highlighter-rouge">xxx.properties</code> 中加入配置，其中 key 为服务名，value 为服务提供者 URL：</p><div class="language-properties highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="py">com.alibaba.xxx.XxxService</span><span class="p">=</span><span class="s">dubbo://localhost:20890</span>
</pre></table></code></div></div></li></ol><p>为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用。</p><h3 id="只订阅">只订阅</h3><p>如果一个正在开发的服务提供者进行注册，那么会影响消费者的正常运行，所以Dubbo提供了服务提供者只订阅不注册的方法，这样服务提供者在开发过程中，可以订阅其他服务，但是不会注册正在开发的服务，并且可以通过直连的方式测试正在开发的服务。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:registry</span> <span class="na">address=</span><span class="s">"10.20.153.10:9090"</span> <span class="na">register=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
或
<span class="nt">&lt;dubbo:registry</span> <span class="na">address=</span><span class="s">"10.20.153.10:9090?register=false"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="多协议">多协议</h3><p>Dubbo 允许配置多协议，在<strong>不同服务上支持不同协议</strong>或者<strong>同一服务上同时支持多种协议</strong>。</p><p>为不同的服务配置不同的协议，具体根据服务的类型来选择最优的协议，例如：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- 多协议配置 --&gt;</span>
    <span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">port=</span><span class="s">"20880"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rmi"</span> <span class="na">port=</span><span class="s">"1099"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span>
    <span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.HelloService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">ref=</span><span class="s">"helloService"</span> <span class="na">protocol=</span><span class="s">"dubbo"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 使用rmi协议暴露服务 --&gt;</span>
    <span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.DemoService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">ref=</span><span class="s">"demoService"</span> <span class="na">protocol=</span><span class="s">"rmi"</span> <span class="nt">/&gt;</span> 
</pre></table></code></div></div><p>同一服务也支持配置多种协议，例如：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- 多协议配置 --&gt;</span>
    <span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">port=</span><span class="s">"20880"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"hessian"</span> <span class="na">port=</span><span class="s">"8080"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 使用多个协议暴露服务 --&gt;</span>
    <span class="nt">&lt;dubbo:service</span> <span class="na">id=</span><span class="s">"helloService"</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.HelloService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">protocol=</span><span class="s">"dubbo,hessian"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="多注册中心">多注册中心</h3><p>Dubbo 支持<strong>同一服务向多注册中心同时注册</strong>，或者<strong>不同服务分别注册到不同的注册中心上去</strong>，甚至可以<strong>同时引用注册在不同注册中心上的同名服务</strong>。另外，注册中心是支持自定义扩展的。</p><p>把一个服务<code class="language-plaintext highlighter-rouge">HelloService</code>注册到两个不同地的注册中心上：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- 多注册中心配置 --&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"hangzhouRegistry"</span> <span class="na">address=</span><span class="s">"10.20.141.150:9090"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"qingdaoRegistry"</span> <span class="na">address=</span><span class="s">"10.20.141.151:9010"</span> <span class="na">default=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 向多个注册中心注册 --&gt;</span>
    <span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.HelloService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">ref=</span><span class="s">"helloService"</span> <span class="na">registry=</span><span class="s">"hangzhouRegistry,qingdaoRegistry"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>不同服务分别注册到不同的注册中心：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- 多注册中心配置 --&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"chinaRegistry"</span> <span class="na">address=</span><span class="s">"10.20.141.150:9090"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"intlRegistry"</span> <span class="na">address=</span><span class="s">"10.20.154.177:9010"</span> <span class="na">default=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 向中文站注册中心注册 --&gt;</span>
    <span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.HelloService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">ref=</span><span class="s">"helloService"</span> <span class="na">registry=</span><span class="s">"chinaRegistry"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 向国际站注册中心注册 --&gt;</span>
    <span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.DemoService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">ref=</span><span class="s">"demoService"</span> <span class="na">registry=</span><span class="s">"intlRegistry"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>同时引用注册在不同注册中心的同名服务，该同名服务虽然接口和版本号均一致，但是连接的数据库不同，那么也是可以在同一个消费者端引用的：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- 多注册中心配置 --&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"chinaRegistry"</span> <span class="na">address=</span><span class="s">"10.20.141.150:9090"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"intlRegistry"</span> <span class="na">address=</span><span class="s">"10.20.154.177:9010"</span> <span class="na">default=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 引用中文站服务 --&gt;</span>
    <span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"chinaHelloService"</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.HelloService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">registry=</span><span class="s">"chinaRegistry"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 引用国际站站服务 --&gt;</span>
    <span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"intlHelloService"</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.HelloService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">registry=</span><span class="s">"intlRegistry"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>如果只是测试环境临时需要连接两个不同注册中心，使用竖号分隔多个不同注册中心地址：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- 多注册中心配置，竖号分隔表示同时连接多个不同注册中心，同一注册中心的多个集群地址用逗号分隔 --&gt;</span>
    <span class="nt">&lt;dubbo:registry</span> <span class="na">address=</span><span class="s">"10.20.141.150:9090|10.20.154.177:9010"</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- 引用服务 --&gt;</span>
    <span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"helloService"</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.HelloService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="服务分组">服务分组</h3><p>当一个接口有多种实现时，可用group分组：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">group=</span><span class="s">"feedback"</span> <span class="na">interface=</span><span class="s">"com.xxx.IndexService"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;dubbo:service</span> <span class="na">group=</span><span class="s">"member"</span> <span class="na">interface=</span><span class="s">"com.xxx.IndexService"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>引用：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"feedbackIndexService"</span> <span class="na">group=</span><span class="s">"feedback"</span> <span class="na">interface=</span><span class="s">"com.xxx.IndexService"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"memberIndexService"</span> <span class="na">group=</span><span class="s">"member"</span> <span class="na">interface=</span><span class="s">"com.xxx.IndexService"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="多版本">多版本</h3><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p><p>可以按照以下的步骤进行版本迁移：</p><ol><li>在低压力时间段，先升级一半提供者为新版本</li><li>再将所有消费者升级为新版本</li><li>然后将剩下的一半提供者升级为新版本</li></ol><h3 id="分组聚合">分组聚合</h3><p>通过分组对结果进行聚合并返回聚合后的结果。</p><p>比如菜单服务，用group区分同一接口的多种实现，现在消费方需从每种group中调用一次并返回结果，对结果进行合并之后返回，这样就可以实现聚合菜单项。</p><p>合并所有分组：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">interface=</span><span class="s">"com.xxx.MenuService"</span> <span class="na">group=</span><span class="s">"*"</span> <span class="na">merger=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>合并指定分组：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">interface=</span><span class="s">"com.xxx.MenuService"</span> <span class="na">group=</span><span class="s">"aaa,bbb"</span> <span class="na">merger=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="回声测试">回声测试</h3><p>回声测试用于检测服务是否可用，回声测试按照正常流程执行，能够测试整个调用是否通畅，可用于监控。</p><p>所有服务自动实现 <code class="language-plaintext highlighter-rouge">EchoService</code> 接口，只需将任意服务引用强制转型为 <code class="language-plaintext highlighter-rouge">EchoService</code>，即可使用。</p><p>例如：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"memberService"</span> <span class="na">interface=</span><span class="s">"com.xxx.MemberService"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>使用：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// 远程服务引用</span>
<span class="nc">MemberService</span> <span class="n">memberService</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"memberService"</span><span class="o">);</span> 
 
<span class="nc">EchoService</span> <span class="n">echoService</span> <span class="o">=</span> <span class="o">(</span><span class="nc">EchoService</span><span class="o">)</span> <span class="n">memberService</span><span class="o">;</span> <span class="c1">// 强制转型为EchoService</span>

<span class="c1">// 回声测试可用性</span>
<span class="nc">String</span> <span class="n">status</span> <span class="o">=</span> <span class="n">echoService</span><span class="o">.</span><span class="n">$echo</span><span class="o">(</span><span class="s">"OK"</span><span class="o">);</span> 
 
<span class="k">assert</span><span class="o">(</span><span class="n">status</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"OK"</span><span class="o">));</span>
</pre></table></code></div></div><h3 id="上下文信息">上下文信息</h3><p>上下文中存放当前调用过程中所需的环境信息，所有的配置信息都会转化为URL的参数。</p><p>RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。</p><p>服务消费者：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 远程调用</span>
<span class="n">xxxService</span><span class="o">.</span><span class="na">xxx</span><span class="o">();</span>
<span class="c1">// 本端是否为消费端，这里会返回true</span>
<span class="kt">boolean</span> <span class="n">isConsumerSide</span> <span class="o">=</span> <span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">isConsumerSide</span><span class="o">();</span>
<span class="c1">// 获取最后一次调用的提供方IP地址</span>
<span class="nc">String</span> <span class="n">serverIP</span> <span class="o">=</span> <span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getRemoteHost</span><span class="o">();</span>
<span class="c1">// 获取当前服务配置信息，所有配置信息都将转换为URL的参数</span>
<span class="nc">String</span> <span class="n">application</span> <span class="o">=</span> <span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getUrl</span><span class="o">().</span><span class="na">getParameter</span><span class="o">(</span><span class="s">"application"</span><span class="o">);</span>
<span class="c1">// 注意：每发起RPC调用，上下文状态会变化</span>
<span class="n">yyyService</span><span class="o">.</span><span class="na">yyy</span><span class="o">();</span>
</pre></table></code></div></div><p>服务提供者：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">XxxServiceImpl</span> <span class="kd">implements</span> <span class="nc">XxxService</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">xxx</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 本端是否为提供端，这里会返回true</span>
        <span class="kt">boolean</span> <span class="n">isProviderSide</span> <span class="o">=</span> <span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">isProviderSide</span><span class="o">();</span>
        <span class="c1">// 获取调用方IP地址</span>
        <span class="nc">String</span> <span class="n">clientIP</span> <span class="o">=</span> <span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getRemoteHost</span><span class="o">();</span>
        <span class="c1">// 获取当前服务配置信息，所有配置信息都将转换为URL的参数</span>
        <span class="nc">String</span> <span class="n">application</span> <span class="o">=</span> <span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getUrl</span><span class="o">().</span><span class="na">getParameter</span><span class="o">(</span><span class="s">"application"</span><span class="o">);</span>
        <span class="c1">// 注意：每发起RPC调用，上下文状态会变化</span>
        <span class="n">yyyService</span><span class="o">.</span><span class="na">yyy</span><span class="o">();</span>
        <span class="c1">// 此时本端变成消费端，这里会返回false</span>
        <span class="kt">boolean</span> <span class="n">isProviderSide</span> <span class="o">=</span> <span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">isProviderSide</span><span class="o">();</span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></table></code></div></div><h3 id="隐式参数">隐式参数</h3><p>可以通过 <code class="language-plaintext highlighter-rouge">RpcContext</code> 上的 <code class="language-plaintext highlighter-rouge">setAttachment</code> 和 <code class="language-plaintext highlighter-rouge">getAttachment</code> 在服务消费方和提供方之间进行参数的隐式传递。</p><blockquote><p>path, group, version, dubbo, token, timeout 几个 key 是保留字段，请使用其它值。</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210603101609690.png" alt="image-20210603101609690" /></p><p>消费者设置：</p><p><code class="language-plaintext highlighter-rouge">setAttachment</code> 设置的 KV 对，在完成下面一次远程调用会被清空，即多次远程调用要多次设置。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">setAttachment</span><span class="o">(</span><span class="s">"index"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">);</span> <span class="c1">// 隐式传参，后面的远程调用都会隐式将这些参数发送到服务器端，类似cookie，用于框架集成，不建议常规业务使用</span>
<span class="n">xxxService</span><span class="o">.</span><span class="na">xxx</span><span class="o">();</span> <span class="c1">// 远程调用</span>
<span class="c1">// ...</span>
</pre></table></code></div></div><p>提供者获取：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">XxxServiceImpl</span> <span class="kd">implements</span> <span class="nc">XxxService</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">xxx</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 获取客户端隐式传入的参数，用于框架集成，不建议常规业务使用</span>
        <span class="nc">String</span> <span class="n">index</span> <span class="o">=</span> <span class="nc">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAttachment</span><span class="o">(</span><span class="s">"index"</span><span class="o">);</span> 
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="本地调用">本地调用</h3><p>本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"injvm"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:provider</span> <span class="na">protocol=</span><span class="s">"injvm"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>从 <code class="language-plaintext highlighter-rouge">2.2.0</code> 开始，每个服务默认都会在本地暴露。在引用服务的时候，默认优先引用本地服务。如果希望引用远程服务可以使用一下配置强制引用远程服务。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="err">...</span> <span class="na">scope=</span><span class="s">"remote"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="本地存根">本地存根</h3><p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub <a href="https://dubbo.apache.org/zh/docs/v2.7/user/examples/local-stub/#fn:1">1</a>，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">stub=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>或</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">stub=</span><span class="s">"com.foo.BarServiceStub"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="本地伪装">本地伪装</h3><p>本地伪装 通常用于服务降级，比如某验权服务，当服务提供方全部挂掉后，客户端不抛出异常，而是通过 Mock 数据返回授权失败。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">mock=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>或</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">mock=</span><span class="s">"com.foo.BarServiceMock"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>提供mock实现：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.foo</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BarServiceMock</span> <span class="kd">implements</span> <span class="nc">BarService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 你可以伪造容错数据，此方法只在出现RpcException时被执行</span>
        <span class="k">return</span> <span class="s">"容错数据"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="延迟暴露">延迟暴露</h3><p>如果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。</p><p>在 Dubbo 2.6.5 版本中对服务延迟暴露逻辑进行了细微的调整，将需要延迟暴露（delay &gt; 0）服务的<strong>倒计时</strong>动作<strong>推迟到了 Spring 初始化完成后进行。</strong></p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">delay=</span><span class="s">"5000"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p><strong>Spring 2.x初始化死锁问题</strong></p><p>在 Spring 解析到 <code class="language-plaintext highlighter-rouge">&lt;dubbo:service /&gt;</code> 时，就已经向外暴露了服务，而 Spring 还在接着初始化其它 Bean。如果这时有请求进来，并且服务的实现类里有调用 <code class="language-plaintext highlighter-rouge">applicationContext.getBean()</code> 的用法。</p><ul><li>请求线程的 applicationContext.getBean() 调用，先同步 singletonObjects 判断 Bean 是否存在，不存在就同步 beanDefinitionMap 进行初始化，并再次同步 singletonObjects 写入 Bean 实例缓存。</li><li>而 Spring 初始化线程，因不需要判断 Bean 的存在，直接同步 beanDefinitionMap 进行初始化，并同步 singletonObjects 写入 Bean 实例缓存。</li><li>这样就导致 getBean 线程，先锁 singletonObjects，再锁 beanDefinitionMap，再次锁 singletonObjects。而 Spring 初始化线程，先锁 beanDefinitionMap，再锁 singletonObjects。反向锁导致线程死锁，不能提供服务，启动不了。</li></ul><p>规避方法：</p><ol><li>强烈建议不要在服务的实现类中有 applicationContext.getBean() 的调用，全部采用 IoC 注入的方式使用 Spring的Bean。</li><li>如果实在要调 getBean()，可以将 Dubbo 的配置放在 Spring 的最后加载。</li><li>如果不想依赖配置顺序，可以使用 <code class="language-plaintext highlighter-rouge">&lt;dubbo:provider delay=”-1” /&gt;</code>，使 Dubbo 在 Spring 容器初始化完后，再暴露服务。</li><li>如果大量使用 getBean()，相当于已经把 Spring 退化为工厂模式在用，可以将 Dubbo 的服务隔离单独的 Spring 容器。</li></ol><h3 id="配置规则">配置规则</h3><p>覆盖规则是 Dubbo 设计的在无需重启应用的情况下，动态调整 RPC 调用行为的一种能力。2.7.0 版本开始，支持从<strong>服务</strong>和<strong>应用</strong>两个粒度来调整动态配置。</p><p>应用粒度</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1"># 将应用demo（key:demo）在20880端口上提供（side:provider）的所有服务（scope:application）的权重修改为1000（weight:1000）。</span>
<span class="nn">---</span>
<span class="na">configVersion</span><span class="pi">:</span> <span class="s">v2.7</span>
<span class="na">scope</span><span class="pi">:</span> <span class="s">application</span>
<span class="na">key</span><span class="pi">:</span> <span class="s">demo</span>
<span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">configs</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">addresses</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">0.0.0.0:20880"</span><span class="pi">]</span>
  <span class="na">side</span><span class="pi">:</span> <span class="s">provider</span>
  <span class="na">parameters</span><span class="pi">:</span>
  <span class="na">weight</span><span class="pi">:</span> <span class="m">1000</span>
  <span class="s">...</span>
</pre></table></code></div></div><p>服务粒度</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1"># 所有消费（side:consumer）DemoService服务（key:org.apache.dubbo.samples.governance.api.DemoService）的应用实例（addresses:[0.0.0.0]），超时时间修改为6000ms</span>
<span class="nn">---</span>
<span class="na">configVersion</span><span class="pi">:</span> <span class="s">v2.7</span>
<span class="na">scope</span><span class="pi">:</span> <span class="s">service</span>
<span class="na">key</span><span class="pi">:</span> <span class="s">org.apache.dubbo.samples.governance.api.DemoService</span>
<span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">configs</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">addresses</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0.0.0.0</span><span class="pi">]</span>
  <span class="na">side</span><span class="pi">:</span> <span class="s">consumer</span>
  <span class="na">parameters</span><span class="pi">:</span>
  <span class="na">timeout</span><span class="pi">:</span> <span class="m">6000</span>
  <span class="s">...</span>
</pre></table></code></div></div><p>配置模板：</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="nn">---</span>
<span class="na">configVersion</span><span class="pi">:</span> <span class="s">v2.7</span>
<span class="na">scope</span><span class="pi">:</span> <span class="s">application/service</span>
<span class="na">key</span><span class="pi">:</span> <span class="s">app-name/group+service+version</span>
<span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">configs</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">addresses</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">0.0.0.0"</span><span class="pi">]</span>
  <span class="na">providerAddresses</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">1.1.1.1:20880"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">2.2.2.2:20881"</span><span class="pi">]</span>
  <span class="na">side</span><span class="pi">:</span> <span class="s">consumer</span>
  <span class="s">applications/services</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">parameters</span><span class="pi">:</span>
    <span class="na">timeout</span><span class="pi">:</span> <span class="m">1000</span>
    <span class="na">cluster</span><span class="pi">:</span> <span class="s">failfase</span>
    <span class="na">loadbalance</span><span class="pi">:</span> <span class="s">random</span>
<span class="pi">-</span> <span class="na">addresses</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">0.0.0.0:20880"</span><span class="pi">]</span>
  <span class="na">side</span><span class="pi">:</span> <span class="s">provider</span>
  <span class="s">applications/services</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">parameters</span><span class="pi">:</span>
    <span class="na">threadpool</span><span class="pi">:</span> <span class="s">fixed</span>
    <span class="na">threads</span><span class="pi">:</span> <span class="m">200</span>
    <span class="na">iothreads</span><span class="pi">:</span> <span class="m">4</span>
    <span class="na">dispatcher</span><span class="pi">:</span> <span class="s">all</span>
    <span class="na">weight</span><span class="pi">:</span> <span class="m">200</span>
<span class="nn">...</span>
</pre></table></code></div></div><p>其中：</p><ul><li><code class="language-plaintext highlighter-rouge">configVersion</code> 表示 dubbo 的版本</li><li><code class="language-plaintext highlighter-rouge">scope</code>表示配置作用范围，分别是应用（application）或服务（service）粒度。<strong>必填</strong>。</li><li>key指定规则体作用在哪个服务或应用。必填。<ul><li>scope=service时，key取值为[{group}:]{service}[:{version}]的组合</li></ul></li><li>scope=application时，key取值为application名称</li><li><code class="language-plaintext highlighter-rouge">enabled=true</code> 覆盖规则是否生效，可不填，缺省生效。</li><li>configs 定义具体的覆盖规则内容，可以指定n（n&gt;=1）个规则体。必填。<ul><li>side，</li><li>applications</li><li>services</li><li>parameters</li><li>addresses</li><li>providerAddresses</li></ul></li></ul><p><strong>对于绝大多数配置场景，只需要理清楚以下问题基本就知道配置该怎么写了：</strong></p><ol><li>要修改整个应用的配置还是某个服务的配置。<ul><li>应用：<code class="language-plaintext highlighter-rouge">scope: application, key: app-name</code>（还可使用<code class="language-plaintext highlighter-rouge">services</code>指定某几个服务）。</li><li>服务：<code class="language-plaintext highlighter-rouge">scope: service, key:group+service+version </code>。</li></ul></li><li>修改是作用到消费者端还是提供者端。<ul><li>消费者：<code class="language-plaintext highlighter-rouge">side: consumer</code> ，作用到消费端时（你还可以进一步使用<code class="language-plaintext highlighter-rouge">providerAddress</code>, <code class="language-plaintext highlighter-rouge">applications</code>选定特定的提供者示例或应用）。</li><li>提供者：<code class="language-plaintext highlighter-rouge">side: provider</code>。</li></ul></li><li>配置是否只对某几个特定实例生效。<ul><li>所有实例：<code class="language-plaintext highlighter-rouge">addresses: ["0.0.0.0"] </code>或<code class="language-plaintext highlighter-rouge">addresses: ["0.0.0.0:*"] </code>具体由side值决定。</li><li>指定实例：<code class="language-plaintext highlighter-rouge">addersses[实例地址列表]</code>。</li></ul></li><li>要修改的属性是哪个。</li></ol><h3 id="服务降级">服务降级</h3><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p><p>向注册中心写入动态配置覆盖规则：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">RegistryFactory</span> <span class="n">registryFactory</span> <span class="o">=</span> <span class="nc">ExtensionLoader</span><span class="o">.</span><span class="na">getExtensionLoader</span><span class="o">(</span><span class="nc">RegistryFactory</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getAdaptiveExtension</span><span class="o">();</span>
<span class="nc">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="n">registryFactory</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">(</span><span class="no">URL</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="s">"zookeeper://10.20.153.10:2181"</span><span class="o">));</span>
<span class="n">registry</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="no">URL</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="s">"override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null"</span><span class="o">));</span>
</pre></table></code></div></div><p>其中：</p><ul><li><code class="language-plaintext highlighter-rouge">mock=force:return+null</code> 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li><li>还可以改为 <code class="language-plaintext highlighter-rouge">mock=fail:return+null</code> 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li></ul><h3 id="主机配置">主机配置</h3><p>dubbo在不设置host的情况下，默认的host为：</p><ol><li>未联网时，为127.0.0.1</li><li>在阿里云服务器中，返回私有地址，如：172.18.46.234</li><li>在本机测试时，返回公有地址，如：30.5.10.11</li></ol><p>除此之外,可以通过 <code class="language-plaintext highlighter-rouge">dubbo.protocol</code> 或 <code class="language-plaintext highlighter-rouge">dubbo.provider </code>的 <code class="language-plaintext highlighter-rouge">host</code> 属性对 <code class="language-plaintext highlighter-rouge">host</code> 进行配置,支持IP地址和域名</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">port=</span><span class="s">"20890"</span> <span class="na">host=</span><span class="s">"www.example.com"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="日志适配">日志适配</h3><p>自 <code class="language-plaintext highlighter-rouge">2.2.1</code> 开始，dubbo 开始内置 log4j、slf4j、jcl、jdk 这些日志框架的适配，也可以通过以下方式显式配置日志输出策略：</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>java <span class="nt">-Ddubbo</span>.application.logger<span class="o">=</span>log4j
</pre></table></code></div></div><p>或</p><pre><code class="language-fallback">dubbo.application.logger=log4j
</code></pre><p>或</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:application</span> <span class="na">logger=</span><span class="s">"log4j"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h3 id="访问日志">访问日志</h3><p>如果你想记录每一次请求信息，可开启访问日志，类似于apache的访问日志。<strong>注意</strong>：此日志量比较大，请注意磁盘容量。</p><p>将访问日志输出到当前应用的log4j日志：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">accesslog=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><p>将访问日志输出到指定文件：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">accesslog=</span><span class="s">"http://10.20.160.198/wiki/display/dubbo/foo/bar.log"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h2 id="协议参考手册">协议参考手册</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210604094941931.png" alt="image-20210604094941931" /></p><ul><li>Transporter: mina, netty, grizzy</li><li>Serialization: dubbo, hessian2, java, json</li><li>Dispatcher: all, direct, message, execution, connection</li><li>ThreadPool: fixed, cached</li></ul><h3 id="dubbo协议"><strong>Dubbo协议</strong></h3><p>Dubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p><p><strong>特性：</strong>是默认协议，使用基于netty <code class="language-plaintext highlighter-rouge">3.2.5.Final</code> 和 hessian2 <code class="language-plaintext highlighter-rouge">3.2.1-fixed-2(Alibaba embed version)</code> 的 tbremoting 交互。</p><ul><li>连接个数：单连接</li><li>连接方式：长连接</li><li>传输协议：TCP</li><li>传输方式：NIO异步传输</li><li>序列化：Hessian二进制序列化</li><li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</li><li>适用场景：常规远程服务方法调用</li></ul><p><strong>约束：</strong></p><ul><li>参数及返回值需实现Serializable接口。</li><li>参数及返回值不能自定义实现 <code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Map</code>, <code class="language-plaintext highlighter-rouge">Number</code>, <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">Calendar</code> 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。</li><li>Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量。</li></ul><p><strong>常见问题：</strong></p><p>为什么要消费者比提供者个数多？</p><p>因 dubbo 协议采用单一长连接，假设网络为千兆网卡，根据测试经验数据每条连接最多只能压满 7MByte(不同的环境可能不一样，供参考)，理论上 1 个服务提供者需要 20 个服务消费者才能压满网卡。</p><p>为什么不能传大包？</p><p>会影响TPS。因 dubbo 协议采用单一长连接，如果每次请求的数据包大小为 500KByte，假设网络为千兆网卡，每条连接最大 7MByte(不同的环境可能不一样，供参考)，单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。单个消费者调用单个服务提供者的 TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。</p><p>为什么采用异步单一长连接？</p><p>因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，如果采用常规的 hessian 服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步 IO，复用线程池，防止 C10K 问题。</p><h3 id="rest协议"><strong>rest协议</strong></h3><p>REST服务中虽然建议使用HTTP协议中四种标准方法POST、DELETE、PUT、GET来分别实现常见的“增删改查”，但实际中，我们一般情况直接用POST来实现“增改”，GET来实现“删查”即可（DELETE和PUT甚至会被一些防火墙阻挡）。</p><h3 id="http协议"><strong>http协议</strong></h3><p>基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现</p><p>特性：</p><ul><li>连接个数：多连接</li><li>连接方式：短连接</li><li>传输协议：HTTP</li><li>传输方式：同步传输</li><li>序列化：表单序列化</li><li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。</li><li>适用场景：需同时给应用程序和浏览器 JS 使用的服务。</li></ul><h3 id="hessian协议"><strong>hessian协议</strong></h3><p><a href="http://hessian.caucho.com/">Hessian</a> 是 Caucho 开源的一个 RPC 框架，其通讯效率高于 WebService 和 Java 自带的序列化。</p><p>Hessian <a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/hessian/#fn:1">1</a> 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。</p><p>Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：</p><ul><li>提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用</li><li>或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。</li></ul><p>特性：</p><ul><li>连接个数：多连接</li><li>连接方式：短连接</li><li>传输协议：HTTP</li><li>传输方式：同步传输</li><li>序列化：Hessian二进制序列化</li><li>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，<strong>可传文件。</strong></li><li>适用场景：页面传输，文件传输，或与原生hessian服务互操作</li></ul><p>约束：</p><ul><li>参数及返回值需实现 <code class="language-plaintext highlighter-rouge">Serializable</code> 接口</li><li>参数及返回值不能自定义实现 <code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Map</code>, <code class="language-plaintext highlighter-rouge">Number</code>, <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">Calendar</code> 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。</li></ul><h3 id="redis协议"><strong>redis协议</strong></h3><p>基于Redis实现的RPC协议。</p><h3 id="thrift协议"><strong>thrift协议</strong></h3><p>当前 dubbo 支持的 thrift 协议是对 thrift 原生协议 的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。</p><p><a href="http://thrift.apache.org/">Thrift</a> 是 Facebook 捐给 Apache 的一个 RPC 框架</p><p>Dubbo 自 2.7.5 版本开始支持 gRPC 协议，对于计划使用 HTTP/2 通信，或者想利用 gRPC 带来的 Stream、反压、Reactive 编程等能力的开发者来说， 都可以考虑启用 gRPC 协议。</p><h3 id="memcached协议"><strong>memcached协议</strong></h3><p>基于 memcached 实现的 RPC 协议。</p><h3 id="rmi协议"><strong>RMI协议</strong></h3><p>RMI 协议采用 JDK 标准的 <code class="language-plaintext highlighter-rouge">java.rmi.*</code> 实现，采用阻塞式短连接和 JDK 标准序列化方式。</p><p>注意：如果正在使用 RMI 提供服务给外部访问 <a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rmi/#fn:1">1</a>，同时应用里依赖了老的 common-collections 包 <a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rmi/#fn:2">2</a> 的情况下，存在反序列化安全风险 <a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rmi/#fn:3">3</a>。</p><p>特性：</p><ul><li>连接个数：多连接</li><li>连接方式：短连接</li><li>传输协议：TCP</li><li>传输方式：同步传输</li><li>序列化：Java 标准二进制序列化</li><li>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。</li><li>适用场景：常规远程服务方法调用，与原生RMI服务互操作</li></ul><p>约束：</p><ul><li>参数及返回值需实现 <code class="language-plaintext highlighter-rouge">Serializable</code> 接口</li><li>dubbo 配置中的超时时间对 RMI 无效，需使用 java 启动参数设置：<code class="language-plaintext highlighter-rouge">-Dsun.rmi.transport.tcp.responseTimeout=3000</code>，参见下面的 RMI 配置</li></ul><p>如果服务接口继承了 <code class="language-plaintext highlighter-rouge">java.rmi.Remote</code> 接口，可以和原生 RMI 互操作，即：</p><ul><li>提供者用 Dubbo 的 RMI 协议暴露服务，消费者直接用标准 RMI 接口调用，</li><li>或者提供方用标准 RMI 暴露服务，消费方用 Dubbo 的 RMI 协议调用。</li></ul><p>如果服务接口没有继承 <code class="language-plaintext highlighter-rouge">java.rmi.Remote</code> 接口：</p><ul><li>缺省 Dubbo 将自动生成一个 <code class="language-plaintext highlighter-rouge">com.xxx.XxxService$Remote</code> 的接口，并继承 <code class="language-plaintext highlighter-rouge">java.rmi.Remote</code> 接口，并以此接口暴露服务，</li><li>但如果设置了 <code class="language-plaintext highlighter-rouge">&lt;dubbo:protocol name="rmi" codec="spring" /&gt;</code>，将不生成 <code class="language-plaintext highlighter-rouge">$Remote</code> 接口，而使用 Spring 的 <code class="language-plaintext highlighter-rouge">RmiInvocationHandler</code> 接口暴露服务，和 Spring 兼容。</li></ul><h3 id="webservice协议"><strong>webservice协议</strong></h3><p>基于 WebService 的远程调用协议，基于 <a href="http://cxf.apache.org/">Apache CXF</a> <a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/webservice/#fn:1">1</a> 的 <code class="language-plaintext highlighter-rouge">frontend-simple</code> 和 <code class="language-plaintext highlighter-rouge">transports-http</code> 实现。</p><p>可以和原生 WebService 服务互操作，即：</p><ul><li>提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用，</li><li>或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。</li></ul><p>特性</p><ul><li>连接个数：多连接</li><li>连接方式：短连接</li><li>传输协议：HTTP</li><li>传输方式：同步传输</li><li>序列化：SOAP 文本序列化</li><li>适用场景：系统集成，跨语言调用</li></ul><p>约束</p><ul><li>参数及返回值需实现 <code class="language-plaintext highlighter-rouge">Serializable</code> 接口</li><li>参数尽量使用基本类型和 POJO</li></ul><h2 id="注册中心参考手册">注册中心参考手册</h2><h3 id="nacos">Nacos</h3><p>Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 <a href="https://github.com/apache/incubator-dubbo/tree/master/dubbo-registry/dubbo-registry-nacos"><code class="language-plaintext highlighter-rouge">dubbo-registry-nacos</code></a></p><h3 id="zookeeper">Zookeeper</h3><p>推荐使用。</p><p>流程说明：</p><ul><li>服务提供者启动时: 向 <code class="language-plaintext highlighter-rouge">/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li>服务消费者启动时: 订阅 <code class="language-plaintext highlighter-rouge">/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code class="language-plaintext highlighter-rouge">/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li>监控中心启动时: 订阅 <code class="language-plaintext highlighter-rouge">/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址。</li></ul><p>支持以下功能：</p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求</li><li>当设置 <code class="language-plaintext highlighter-rouge">&lt;dubbo:registry check="false" /&gt;</code> 时，记录失败注册和订阅请求，后台定时重试</li><li>可通过 <code class="language-plaintext highlighter-rouge">&lt;dubbo:registry username="admin" password="1234" /&gt;</code> 设置 zookeeper 登录信息</li><li>可通过 <code class="language-plaintext highlighter-rouge">&lt;dubbo:registry group="dubbo" /&gt;</code> 设置 zookeeper 的根节点，不配置将使用默认的根节点。</li><li>支持 <code class="language-plaintext highlighter-rouge">*</code> 号通配符 <code class="language-plaintext highlighter-rouge">&lt;dubbo:reference group="*" version="*" /&gt;</code>，可订阅服务的所有分组和所有版本的提供者</li></ul><h3 id="multicast注册中心">Multicast注册中心</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210604100603542.png" alt="image-20210604100603542" /></p><p>Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现。</p><ol><li>提供方启动时广播自己的地址</li><li>消费方启动时广播订阅请求</li><li>提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 <code class="language-plaintext highlighter-rouge">unicast=false</code>，则广播给订阅者</li><li>消费方收到提供方地址时，连接该地址进行 RPC 调用。</li></ol><p>组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段: 224.0.0.0 - 239.255.255.255</p><h3 id="redis注册中心">Redis注册中心</h3><p>Redis 过期数据通过心跳的方式检测脏数据，服务器时间必须同步，并且对服务器有一定压力，否则过期检测会不准确</p><p>使用 Redis 的 Key/Map 结构存储数据结构：</p><ul><li>主 Key 为服务名和类型</li><li>Map 中的 Key 为 URL 地址</li><li>Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除 [^3]</li></ul><p>使用 Redis 的 Publish/Subscribe 事件通知数据变更：</p><ul><li>通过事件的值区分事件类型：<code class="language-plaintext highlighter-rouge">register</code>, <code class="language-plaintext highlighter-rouge">unregister</code>, <code class="language-plaintext highlighter-rouge">subscribe</code>, <code class="language-plaintext highlighter-rouge">unsubscribe</code></li><li>普通消费者直接订阅指定服务提供者的 Key，只会收到指定服务的 <code class="language-plaintext highlighter-rouge">register</code>, <code class="language-plaintext highlighter-rouge">unregister</code> 事件</li><li>监控中心通过 <code class="language-plaintext highlighter-rouge">psubscribe</code> 功能订阅 <code class="language-plaintext highlighter-rouge">/dubbo/*</code>，会收到所有服务的所有变更事件</li></ul><p>调用过程：</p><ol><li>服务提供方启动时，向 <code class="language-plaintext highlighter-rouge">Key:/dubbo/com.foo.BarService/providers</code> 下，添加当前提供者的地址</li><li>并向 <code class="language-plaintext highlighter-rouge">Channel:/dubbo/com.foo.BarService/providers</code> 发送 <code class="language-plaintext highlighter-rouge">register</code> 事件</li><li>服务消费方启动时，从 <code class="language-plaintext highlighter-rouge">Channel:/dubbo/com.foo.BarService/providers</code> 订阅 <code class="language-plaintext highlighter-rouge">register</code> 和 <code class="language-plaintext highlighter-rouge">unregister</code> 事件</li><li>并向 <code class="language-plaintext highlighter-rouge">Key:/dubbo/com.foo.BarService/consumers</code> 下，添加当前消费者的地址</li><li>服务消费方收到 <code class="language-plaintext highlighter-rouge">register</code> 和 <code class="language-plaintext highlighter-rouge">unregister</code> 事件后，从 <code class="language-plaintext highlighter-rouge">Key:/dubbo/com.foo.BarService/providers</code> 下获取提供者地址列表</li><li>服务监控中心启动时，从 <code class="language-plaintext highlighter-rouge">Channel:/dubbo/*</code> 订阅 <code class="language-plaintext highlighter-rouge">register</code> 和 <code class="language-plaintext highlighter-rouge">unregister</code>，以及 <code class="language-plaintext highlighter-rouge">subscribe</code> 和<code class="language-plaintext highlighter-rouge">unsubsribe </code>事件</li><li>服务监控中心收到 <code class="language-plaintext highlighter-rouge">register</code> 和 <code class="language-plaintext highlighter-rouge">unregister</code> 事件后，从 <code class="language-plaintext highlighter-rouge">Key:/dubbo/com.foo.BarService/providers</code> 下获取提供者地址列表</li><li>服务监控中心收到 <code class="language-plaintext highlighter-rouge">subscribe</code> 和 <code class="language-plaintext highlighter-rouge">unsubsribe</code> 事件后，从 <code class="language-plaintext highlighter-rouge">Key:/dubbo/com.foo.BarService/consumers</code> 下获取消费者地址列表</li></ol><h3 id="simple注册中心">Simple注册中心</h3><p>Simple 注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。</p><h2 id="服务最佳化实践">服务最佳化实践</h2><h3 id="分包">分包</h3><p>建议将服务接口、服务模型、服务异常等<strong>均放在 API 包中</strong>，因为服务模型和异常也是 API 的一部分，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p><p>如果需要，也可以考虑在 API 包中放置一份 Spring 的引用配置，这样使用方只需在 Spring 加载过程中引用此配置即可。配置建议放在模块的包目录下，以免冲突，如：<code class="language-plaintext highlighter-rouge">com/alibaba/china/xxx/dubbo-reference.xml</code>。</p><h3 id="粒度">粒度</h3><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p><p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p><p>不建议使用过于抽象的通用接口，如：<code class="language-plaintext highlighter-rouge">Map query(Map)</code>，这样的接口没有明确语义，会给后期维护带来不便。</p><h3 id="版本">版本</h3><p>每个接口都应定义版本号，为后续不兼容升级提供可能，如： <code class="language-plaintext highlighter-rouge">&lt;dubbo:service interface="com.xxx.XxxService" version="1.0" /&gt;</code>。</p><p>建议使用两位版本号，因为第三位版本号通常表示兼容升级，只有不兼容时才需要变更服务版本。</p><p><strong>当不兼容时，先升级一半提供者为新版本，再将消费者全部升为新版本，然后将剩下的一半提供者升为新版本。</strong></p><h3 id="兼容性">兼容性</h3><p>服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。</p><p>各协议的兼容性不同，参见：<a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/">服务协议</a></p><h3 id="枚举值">枚举值</h3><p>如果是完备集，可以用 <code class="language-plaintext highlighter-rouge">Enum</code>，比如：<code class="language-plaintext highlighter-rouge">ENABLE</code>, <code class="language-plaintext highlighter-rouge">DISABLE</code>。</p><p>如果是业务种类，以后明显会有类型增加，不建议用 <code class="language-plaintext highlighter-rouge">Enum</code>，可以用 <code class="language-plaintext highlighter-rouge">String</code> 代替。</p><p>如果是在返回值中用了 <code class="language-plaintext highlighter-rouge">Enum</code>，并新增了 <code class="language-plaintext highlighter-rouge">Enum</code> 值，建议先升级服务消费方，这样服务提供方不会返回新值。</p><p>如果是在传入参数中用了 <code class="language-plaintext highlighter-rouge">Enum</code>，并新增了 <code class="language-plaintext highlighter-rouge">Enum</code> 值，建议先升级服务提供方，这样服务消费方不会传入新值。</p><h3 id="序列化">序列化</h3><p><strong>服务参数及返回值建议使用 POJO 对象，即通过 <code class="language-plaintext highlighter-rouge">setter</code>, <code class="language-plaintext highlighter-rouge">getter</code> 方法表示属性的对象。</strong></p><p>服务参数及返回值不建议使用接口，因为数据模型抽象的意义不大，并且序列化需要接口实现类的元信息，并不能起到隐藏实现的意图。</p><p>服务参数及返回值都必须是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value">传值调用</a>，而不能是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference">传引用调用</a>，消费方和提供方的参数或返回值引用并不是同一个，只是值相同，Dubbo 不支持引用远程对象。</p><h3 id="异常">异常</h3><p><strong>建议使用异常汇报错误，而不是返回错误码0，异常信息能携带更多信息，并且语义更友好。</strong></p><p>如果担心性能问题，在必要时，可以通过 override 掉异常类的 <code class="language-plaintext highlighter-rouge">fillInStackTrace()</code> 方法为空方法，<strong>使其不拷贝栈信息。</strong></p><p>查询方法不建议抛出 checked 异常，否则调用方在查询时将过多的 <code class="language-plaintext highlighter-rouge">try...catch</code>，并且不能进行有效处理。</p><p>服务提供方不应将 DAO 或 SQL 等异常抛给消费方，<strong>应在服务实现中对消费方不关心的异常进行包装</strong>，否则可能出现消费方无法反序列化相应异常。</p><h3 id="调用">调用</h3><p>不要只是因为是 Dubbo 调用，而把调用 <code class="language-plaintext highlighter-rouge">try...catch</code> 起来。<code class="language-plaintext highlighter-rouge">try...catch</code> 应该加上合适的回滚边界上。</p><p>Provider 端需要对输入参数进行校验。如有性能上的考虑，服务实现者可以考虑在 API 包上加上服务 Stub 类来完成检验。</p><h2 id="推荐用法">推荐用法</h2><p>在Provider端尽量多配置Consumer端属性：</p><ul><li>作为服务的提供方，比服务消费方更清楚服务的性能参数，如调用的超时时间、合理的重试次数等</li><li>在Provider端配置后，Consumer 端不配置则会使用 Provider 端的配置，即 Provider 端的配置可以作为 Consumer 的缺省值 <a href="https://dubbo.apache.org/zh/docs/v2.7/user/recommend/#fn:1">1</a>。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 是不可控的，并且往往是不合理的</li></ul><p>Provider 端尽量多配置 Consumer 端的属性，让 Provider 的实现者一开始就思考 Provider 端的服务特点和服务质量等问题。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.HelloService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">ref=</span><span class="s">"helloService"</span>
    <span class="na">timeout=</span><span class="s">"300"</span> <span class="na">retries=</span><span class="s">"2"</span> <span class="na">loadbalance=</span><span class="s">"random"</span> <span class="na">actives=</span><span class="s">"0"</span> <span class="nt">/&gt;</span>
 
<span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.alibaba.hello.api.WorldService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="na">ref=</span><span class="s">"helloService"</span>
    <span class="na">timeout=</span><span class="s">"300"</span> <span class="na">retries=</span><span class="s">"2"</span> <span class="na">loadbalance=</span><span class="s">"random"</span> <span class="na">actives=</span><span class="s">"0"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;dubbo:method</span> <span class="na">name=</span><span class="s">"findAllPerson"</span> <span class="na">timeout=</span><span class="s">"10000"</span> <span class="na">retries=</span><span class="s">"9"</span> <span class="na">loadbalance=</span><span class="s">"leastactive"</span> <span class="na">actives=</span><span class="s">"5"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;dubbo:service/&gt;</span>
</pre></table></code></div></div><p>建议在 Provider 端配置的 Consumer 端属性有：</p><ol><li><code class="language-plaintext highlighter-rouge">timeout</code>：方法调用的超时时间</li><li><code class="language-plaintext highlighter-rouge">retries</code>：失败重试次数，缺省是 2 <a href="https://dubbo.apache.org/zh/docs/v2.7/user/recommend/#fn:2">2</a></li><li><code class="language-plaintext highlighter-rouge">loadbalance</code>：负载均衡算法 <a href="https://dubbo.apache.org/zh/docs/v2.7/user/recommend/#fn:3">3</a>，缺省是随机 <code class="language-plaintext highlighter-rouge">random</code>。还可以配置轮询 <code class="language-plaintext highlighter-rouge">roundrobin</code>、最不活跃优先 <a href="https://dubbo.apache.org/zh/docs/v2.7/user/recommend/#fn:4">4</a> <code class="language-plaintext highlighter-rouge">leastactive</code> 和一致性哈希 <code class="language-plaintext highlighter-rouge">consistenthash</code> 等</li><li><code class="language-plaintext highlighter-rouge">actives</code>：消费者端的最大并发调用限制，即当 Consumer 对一个服务的并发调用到上限后，新调用会阻塞直到超时，在方法上配置 <code class="language-plaintext highlighter-rouge">dubbo:method</code> 则针对该方法进行并发限制，在接口上配置 <code class="language-plaintext highlighter-rouge">dubbo:service</code>，则针对该服务进行并发限制</li></ol><p>在Provider端配置合理的Provider端属性：</p><p>建议在 Provider 端配置的 Provider 端属性有：</p><ol><li><code class="language-plaintext highlighter-rouge">threads</code>：服务线程池大小</li><li><code class="language-plaintext highlighter-rouge">executes</code>：一个服务提供者并行执行请求上限，即当 Provider 对一个服务的并发调用达到上限后，新调用会阻塞，此时 Consumer 可能会超时。在方法上配置 <code class="language-plaintext highlighter-rouge">dubbo:method</code> 则针对该方法进行并发限制，在接口上配置 <code class="language-plaintext highlighter-rouge">dubbo:service</code>，则针对该服务进行并发限制</li></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/javaweb/'>Javaweb</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/web/" class="post-tag no-text-decoration" >web</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Dubbo文档阅读笔记-用法 - 银杏叶&url=www.yucaihuang.com/posts/dubbo-doc-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Dubbo文档阅读笔记-用法 - 银杏叶&u=www.yucaihuang.com/posts/dubbo-doc-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Dubbo文档阅读笔记-用法 - 银杏叶&url=www.yucaihuang.com/posts/dubbo-doc-1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/web-url-with-chinese-string/">URL包含中文，请求资源404</a></li><li><a href="/posts/web-docker_2/">Docker：入门</a></li><li><a href="/posts/web-docker_1/">Docker：概述</a></li><li><a href="/posts/web-delete-system-python-in-centos/">centOS误删系统自带python</a></li><li><a href="/posts/springboot-starter-id/">创建自定义Springboot starter</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/web-javaweb-mybatis_1/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 4, 2020 <i class="unloaded">2020-09-04T19:17:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Mybatis：环境搭建</h3><div class="text-muted small"><p> 创建maven工程并导入坐标： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; ...</p></div></div></a></div><div class="card"> <a href="/posts/web-javaweb-mybatis_2/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 4, 2020 <i class="unloaded">2020-09-04T19:18:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Mybatis：入门</h3><div class="text-muted small"><p> 入门案例 public class MybatisTest { public static void main(String[] args) throws IOException { //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); ...</p></div></div></a></div><div class="card"> <a href="/posts/web-javaweb-mybatis_3/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 4, 2020 <i class="unloaded">2020-09-04T19:19:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Mybatis：CRUD</h3><div class="text-muted small"><p> 保存操作 在用户Dao接口中定义saveUser抽象方法，用于保存用户： package com.hyc.dao; import com.hyc.domain.User; import org.apache.ibatis.annotations.Select; import java.util.List; /** * 用户的持久层接口 */ public interface I...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/jvm-classfile-resolve/" class="btn btn-outline-primary"><p>JVM：记一次完整的类文件分析过程</p></a> <a href="/posts/dubbo-doc-2/" class="btn btn-outline-primary"><p>Dubbo文档阅读笔记-设计</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-1</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
