<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Java源码分析之ConcurrentHashMap | 黄玉才的博客</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Java源码分析之ConcurrentHashMap" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="ConcurrentHashMap源码分析" /><meta property="og:description" content="ConcurrentHashMap源码分析" /><link rel="canonical" href="www.yucaihuang.com/posts/java-concurrenthashmap/" /><meta property="og:url" content="www.yucaihuang.com/posts/java-concurrenthashmap/" /><meta property="og:site_name" content="黄玉才的博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-18T15:17:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Java源码分析之ConcurrentHashMap" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/posts/java-concurrenthashmap/"},"url":"www.yucaihuang.com/posts/java-concurrenthashmap/","author":{"@type":"Person","name":"Kol Huang"},"description":"ConcurrentHashMap源码分析","dateModified":"2021-03-18T15:17:00+08:00","datePublished":"2021-03-18T15:17:00+08:00","headline":"Java源码分析之ConcurrentHashMap","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">黄玉才的博客</a></div><div class="site-subtitle font-italic">把开源的变成自己的，把自己的变成祖传的!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Java源码分析之ConcurrentHashMap</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Java源码分析之ConcurrentHashMap</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Mar 18, 2021, 3:17 PM +0800" > Mar 18 <i class="unloaded">2021-03-18T15:17:00+08:00</i> </span> by <span class="author"> Kol Huang</div></div><div class="post-content"><h2 id="concurrenthashmap源码分析">ConcurrentHashMap源码分析</h2><h3 id="类前注释">类前注释</h3><ul><li>此类包含了HashTable中所有的方法。</li><li>此哈希表是线程安全的，并且无需甚至是无法对整个表加锁。</li><li>在并发场景下，调用此类的<code class="language-plaintext highlighter-rouge">size</code>、<code class="language-plaintext highlighter-rouge">isEmpty</code>、<code class="language-plaintext highlighter-rouge">containsValue</code>等方法得到的结果只能反映一小段时间内的状态，因此请勿将这些方法作为程序控制的一部分。</li><li>当此哈希表出现了过多的哈希碰撞时，会动态扩展其容量。但是动态扩展和rehash操作总是非常耗时的，最好能在创建哈希表时就指定一个初始容量，这样能提高效率。</li><li>当键是可比较（Comparable）的时，此类可能会使用比较的顺序来打破性能瓶颈（help break ties）。</li><li>和HashTable类似，但是和HashMap不同，本哈希表不允许null值作为键或值。</li></ul><h3 id="类定义">类定义</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="nc">ConcurrentMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;,</span> <span class="nc">Serializable</span> 
</pre></table></code></div></div><p>继承自<code class="language-plaintext highlighter-rouge">AbstractMap</code>抽象类，并实现了<code class="language-plaintext highlighter-rouge">ConcurrentMap</code>和<code class="language-plaintext highlighter-rouge">Serializable</code>接口。看到类名很容易误会此类是由<code class="language-plaintext highlighter-rouge">HashMap</code>派生而来，实际上<code class="language-plaintext highlighter-rouge">ConcurrentMap</code>、<code class="language-plaintext highlighter-rouge">HashMap</code>和<code class="language-plaintext highlighter-rouge">EnumMap</code>等都是<code class="language-plaintext highlighter-rouge">AbstractMap</code>派生而来。</p><h3 id="overview">overview</h3><p>最初设计这个哈希表的目标是为了在并发竞争下维持可读性。第二个目标是为了在内存消耗上与HashMap保持一致甚至是优于它，并支持多线程写入。</p><p>每个哈希映射都保存在一个Node节点中，但是，存在各种子类：TreeNode被安排在平衡树中，而不是列表中。 TreeBins拥有TreeNode集合的根。 在调整大小期间，ForwardingNodes放置在桶（bin）的顶部。</p><p>该表在第一次插入时被延迟初始化为2的幂。 表中的每个bin通常包含一个Node列表（大多数情况下，该列表只有零个或一个Node）。 表访问需要volatile/原子性 读，写和CASes。使用sun.misc.Unsafe实现。</p><p>我们将Node哈希字段的最高（符号）位用于控制目的，带有负哈希字段的节点在map方法中会经过特殊处理或忽略。</p><p>将第一个节点插入到一个空的桶中，使用CAS将其插入。其他更新操作则需要加锁。主要是对桶的第一个节点加锁，对这些锁的锁定支持依赖于内置的“synchronized”监视器。</p><h3 id="关键成员">关键成员</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOVED</span>     <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// hash for forwarding nodes</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TREEBIN</span>   <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="c1">// hash for roots of trees</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">RESERVED</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">;</span> <span class="c1">// hash for transient reservations</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">HASH_BITS</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="o">;</span> <span class="c1">// usable bits of normal node hash</span>
</pre></table></code></div></div><ul><li>当哈希值是MOVED时，说明当前节点是一个转发节点；</li><li>当哈希值是TREEBIN时，说明这是一个红黑树的根；</li><li>当哈希值是RESERVED时，说明这是一个暂时保留的节点？还是说这个字段是暂时保留的。</li><li>HASH_BITS用于正常哈希值的取模操作，防止哈希值溢出。</li></ul><h3 id="unsafe机制">Unsafe机制</h3><p>首先获取以下变量的内存地址，然后通过unsafe包的<code class="language-plaintext highlighter-rouge">native</code>方法实现CAS操作，保证线程安全。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// Unsafe mechanics</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="no">U</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">SIZECTL</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">TRANSFERINDEX</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">BASECOUNT</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">CELLSBUSY</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">CELLVALUE</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">ABASE</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">ASHIFT</span><span class="o">;</span>

<span class="kd">static</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="no">U</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="nc">ConcurrentHashMap</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
    <span class="no">SIZECTL</span> <span class="o">=</span> <span class="no">U</span><span class="o">.</span><span class="na">objectFieldOffset</span>
      <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"sizeCtl"</span><span class="o">));</span>
    <span class="no">TRANSFERINDEX</span> <span class="o">=</span> <span class="no">U</span><span class="o">.</span><span class="na">objectFieldOffset</span>
      <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"transferIndex"</span><span class="o">));</span>
    <span class="no">BASECOUNT</span> <span class="o">=</span> <span class="no">U</span><span class="o">.</span><span class="na">objectFieldOffset</span>
      <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"baseCount"</span><span class="o">));</span>
    <span class="no">CELLSBUSY</span> <span class="o">=</span> <span class="no">U</span><span class="o">.</span><span class="na">objectFieldOffset</span>
      <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"cellsBusy"</span><span class="o">));</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">ck</span> <span class="o">=</span> <span class="nc">CounterCell</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
    <span class="no">CELLVALUE</span> <span class="o">=</span> <span class="no">U</span><span class="o">.</span><span class="na">objectFieldOffset</span>
      <span class="o">(</span><span class="n">ck</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"value"</span><span class="o">));</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">ak</span> <span class="o">=</span> <span class="nc">Node</span><span class="o">[].</span><span class="na">class</span><span class="o">;</span>
    <span class="no">ABASE</span> <span class="o">=</span> <span class="no">U</span><span class="o">.</span><span class="na">arrayBaseOffset</span><span class="o">(</span><span class="n">ak</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="no">U</span><span class="o">.</span><span class="na">arrayIndexScale</span><span class="o">(</span><span class="n">ak</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">scale</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">"data type scale not a power of two"</span><span class="o">);</span>
    <span class="no">ASHIFT</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">-</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">numberOfLeadingZeros</span><span class="o">(</span><span class="n">scale</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="3个核心tabat方法">3个核心tabAt方法</h3><p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>在操作<code class="language-plaintext highlighter-rouge">Node</code>数据中的节点时，为了保证线程安全，定义了以下三个原子操作，使用unsafe机制实现。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">tabAt</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="no">U</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="no">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="no">ABASE</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">casTabAt</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span>
                                    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="no">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="no">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="no">ABASE</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">setTabAt</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="no">U</span><span class="o">.</span><span class="na">putObjectVolatile</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="no">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="no">ABASE</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>第一个方法从主内存中读数据而不是工作内存，第二个方法CAS设置节点，第三个方法将节点的值直接更新到主内存。</p><h3 id="put方法">put方法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">putVal</code>方法中，当键值有一者为空时，就会抛出空指针异常。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NullPointerException</span><span class="o">();</span>
</pre></table></code></div></div><p>随后用key的<code class="language-plaintext highlighter-rouge">hashCode</code>计算哈希值：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">spread</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">spread</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">(</span><span class="n">h</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">))</span> <span class="o">&amp;</span> <span class="no">HASH_BITS</span><span class="o">;</span><span class="c1">//HASH_BITS是2147483647</span>
<span class="o">}</span>
</pre></table></code></div></div><p>计算出哈希值后开启一个死循环：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;;)</span> <span class="o">{</span>
  <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">fh</span><span class="o">;</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>首先判断哈希表是否为空，如果为空，就初始化表：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
  <span class="n">tab</span> <span class="o">=</span> <span class="n">initTable</span><span class="o">();</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">initTable</code>方法中， 使用<code class="language-plaintext highlighter-rouge">sizeCtl</code>中记录的大小来初始化哈希表，如果<code class="language-plaintext highlighter-rouge">sizeCtl</code>小于0，就会调用<code class="language-plaintext highlighter-rouge">yeild()</code>方法自旋等待。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">while</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span><span class="n">sc</span> <span class="o">=</span> <span class="n">sizeCtl</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span> <span class="c1">// lost initialization race; just spin</span>
</pre></table></code></div></div><p>如果<code class="language-plaintext highlighter-rouge">sizeCtl</code>大于等于0，就CAS设置变量<code class="language-plaintext highlighter-rouge">sizeCtl</code>的值，如果<code class="language-plaintext highlighter-rouge">sizeCtl</code>的值和<code class="language-plaintext highlighter-rouge">sc</code>的值相等（在CAS开始前并没有线程修改<code class="language-plaintext highlighter-rouge">sizeCtl</code>的值，不考虑ABA问题），就将<code class="language-plaintext highlighter-rouge">sizeCtl</code>设置为-1。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="no">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">SIZECTL</span><span class="o">,</span> <span class="n">sc</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
</pre></table></code></div></div><p>设置成功后执行<code class="language-plaintext highlighter-rouge">try..finally</code>块，判断<code class="language-plaintext highlighter-rouge">sc</code>是否大于0，如果大于0，说明其他线程已经设置过了<code class="language-plaintext highlighter-rouge">sc</code>的值，那么就将现有的<code class="language-plaintext highlighter-rouge">sc</code>赋值给<code class="language-plaintext highlighter-rouge">n</code>；如果仍旧小于0，那说明<code class="language-plaintext highlighter-rouge">sc</code>的值仍旧是-1，此时就将<code class="language-plaintext highlighter-rouge">DEFAULT_CAPACITY</code>赋值给<code class="language-plaintext highlighter-rouge">n</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">try</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">sc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">sc</span> <span class="o">:</span> <span class="no">DEFAULT_CAPACITY</span><span class="o">;</span>
    <span class="o">...</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
</pre></table></code></div></div><p>这个变量<code class="language-plaintext highlighter-rouge">n</code>中存储着哈希表的初始化容量，随后创建<code class="language-plaintext highlighter-rouge">node</code>数组，完成初始化。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">nt</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;?,?&gt;[</span><span class="n">n</span><span class="o">];</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">nt</span><span class="o">;</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">);</span>
</pre></table></code></div></div><p>有个关键点，就是<code class="language-plaintext highlighter-rouge">sc = n - (n &gt;&gt;&gt; 2)</code>这行代码。要解释为什么需要这行代码就需要知道<code class="language-plaintext highlighter-rouge">sizeCtl</code>的详细作用：</p><ul><li><code class="language-plaintext highlighter-rouge">sizeCtl</code>是用于控制初始化以及扩容的变量。</li><li>当它为负值时，说明此哈希表正在经历初始化或者扩容。-1代表初始化， -N代表有N-1个线程正在进行扩容。</li><li>当它不为负值时，如果哈希表是空的，那么<code class="language-plaintext highlighter-rouge">sizeCtl</code>存储着初始化容量或者是一个默认值为0。在初始化完毕后，<code class="language-plaintext highlighter-rouge">sizeCtl</code>中存储着下一个要调整表大小的元素计数值。</li></ul><p>也就是说<code class="language-plaintext highlighter-rouge">sc = n - (n &gt;&gt;&gt; 2)</code>设置了下一个要调整表大小的元素计数值（可能为8），当表中元素计数大于等于8的时候，可能需要扩容，或者小于等于8的时候，需要缩容，具体还要看<code class="language-plaintext highlighter-rouge">resize</code>的过程。</p><p>OK，<code class="language-plaintext highlighter-rouge">initTable</code>方法就看到这里，回到<code class="language-plaintext highlighter-rouge">put</code>方法。</p><p>如果哈希表不为空，但是哈希到的这个位置是一个空的<code class="language-plaintext highlighter-rouge">bin</code>，就采用CAS设置，不加锁。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">casTabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span>
               <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">)))</span>
    <span class="k">break</span><span class="o">;</span>                   <span class="c1">// no lock when adding to empty bin</span>
</pre></table></code></div></div><p>当哈希到的<code class="language-plaintext highlighter-rouge">bin</code>位置仍旧是空的时候，就将新节点放入。</p><p>上述代码里，计算<code class="language-plaintext highlighter-rouge">bin</code>在内存中的偏移量的语句是<code class="language-plaintext highlighter-rouge">(long)i &lt;&lt; ASHIFT) + ABASE</code>，其中<code class="language-plaintext highlighter-rouge">i</code>是取模过后的哈希值，<code class="language-plaintext highlighter-rouge">ABASE</code>是通过反射获取的数组第一个元素的偏移地址，<code class="language-plaintext highlighter-rouge">ASHIFT</code>的计算比较复杂，如下所示：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="no">U</span><span class="o">.</span><span class="na">arrayIndexScale</span><span class="o">(</span><span class="n">ak</span><span class="o">);</span>
<span class="k">if</span> <span class="o">((</span><span class="n">scale</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">"data type scale not a power of two"</span><span class="o">);</span>
<span class="no">ASHIFT</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">-</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">numberOfLeadingZeros</span><span class="o">(</span><span class="n">scale</span><span class="o">);</span>
</pre></table></code></div></div><p>首先通过<code class="language-plaintext highlighter-rouge">arrayIndexScale</code>方法获取数组的转换因子，也就是数组中元素的增量地址（当前数组一个元素占用的字节数）。</p><p>再调用<code class="language-plaintext highlighter-rouge">Integer.numberOfLeadingZeros</code>方法计算出<code class="language-plaintext highlighter-rouge">scale</code>的二进制形式中，前导0的个数。</p><p><code class="language-plaintext highlighter-rouge">ASHIFT</code>就是31-前导0的个数。</p><p>最后通过<code class="language-plaintext highlighter-rouge">(long)i &lt;&lt; ASHIFT) + ABASE</code>计算出哈希值为<code class="language-plaintext highlighter-rouge">i</code>的元素的内存地址。实际上通过<code class="language-plaintext highlighter-rouge">ABASE + i * Scale</code>也能计算出内存地址，我看不太懂源码是如何算的，兴许只是想通过位运算来提高效率。</p><p>至此，<strong>当哈希表不为空且<code class="language-plaintext highlighter-rouge">bin</code>桶为空的情况已经分析完毕</strong>。最后就是<code class="language-plaintext highlighter-rouge">bin</code>桶不为空的情况了。</p><p>如果当前<code class="language-plaintext highlighter-rouge">bin</code>的哈希值为<code class="language-plaintext highlighter-rouge">MOVED</code>，说明当前正在发生<code class="language-plaintext highlighter-rouge">resize</code>操作，当前线程需要协助完成<code class="language-plaintext highlighter-rouge">resize</code>，即调用<code class="language-plaintext highlighter-rouge">helpTransfer</code>方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">fh</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">==</span> <span class="no">MOVED</span><span class="o">)</span>
  <span class="n">tab</span> <span class="o">=</span> <span class="n">helpTransfer</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">f</span><span class="o">);</span>
</pre></table></code></div></div><p>先跳过<code class="language-plaintext highlighter-rouge">helpTransfer</code>，这个方法放到后面说。</p><p>如果当前<code class="language-plaintext highlighter-rouge">bin</code>的哈希值不为<code class="language-plaintext highlighter-rouge">MOVED</code>，就开始对节点<code class="language-plaintext highlighter-rouge">f</code>加锁（链表头节点），执行插入操作：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="no">V</span> <span class="n">oldVal</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kd">synchronized</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>进入<code class="language-plaintext highlighter-rouge">synchronized</code>代码块后，再次检查一下当前哈希值的节点是否变化，没变化才会继续执行操作。</p><p>如果哈希值大于等于0，说明当前节点是一个普通的链表头节点，可以执行链表的查询和插入操作。因此继续对链表遍历，找到key的位置，如果不存在，就插入到链表末尾。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">fh</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">binCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="o">;;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">K</span> <span class="n">ek</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
        <span class="o">((</span><span class="n">ek</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
         <span class="o">(</span><span class="n">ek</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ek</span><span class="o">))))</span> <span class="o">{</span>
      <span class="n">oldVal</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span><span class="o">)</span>
        <span class="n">e</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
      <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span>
                                <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
      <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>如果哈希值小于0，并且节点<code class="language-plaintext highlighter-rouge">f</code>是一个树节点，那么就执行红黑树的插入操作。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">f</span> <span class="k">instanceof</span> <span class="nc">TreeBin</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>
  <span class="n">binCount</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">((</span><span class="nc">TreeBin</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">f</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span>
                                        <span class="n">value</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">oldVal</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span><span class="o">)</span>
      <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在上述遍历链表的过程中，会记录节点的总数，如果节点总数大于等于<code class="language-plaintext highlighter-rouge">TREEIFY_THRESHOLD</code>（8），会将链表转化为红黑树。</p><p>最后调用<code class="language-plaintext highlighter-rouge">addCount(1L, binCount);</code>方法，这个方法也放到后面讲。</p><p>至此，put方法分析完毕。</p><h3 id="addcount方法">addCount方法</h3><p>此方法的一个作用是增加计数，如果发现哈希表太小了（占用率大），并且没有触发<code class="language-plaintext highlighter-rouge">resize</code>操作，那么就调用<code class="language-plaintext highlighter-rouge">transfer</code>进行扩容，如果已经在<code class="language-plaintext highlighter-rouge">resize</code>了，就调用<code class="language-plaintext highlighter-rouge">helpTransfer</code>帮助执行扩容。在扩容完毕后重新检查占用率，因为调整大小操作是滞后的，需要重新判断是否已经满足了扩容需求。</p><p>这个方法中用到了<code class="language-plaintext highlighter-rouge">CounterCell</code>类，这个类是<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>专门用来记录元素个数的。在无线程安全的集合中，我们可以直接选择使用一个成员变量来记录元素个数，但是无法保证线程安全，例如在多线程环境下调用HashMap的size()方法不能准确得知元素个数。<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>为了保证线程安全设计了这个类。</p><p>以下内容能够帮助理解<code class="language-plaintext highlighter-rouge">CounterCell</code>的作用，参考自<a href="https://blog.csdn.net/qq_40225004/article/details/107027896">这里</a>：</p><p><strong>为什么不直接for循环对当前map对象cas操作 baseCount 加 1，却要引入CounterCell数组？</strong></p><p><strong>因为for循环cas这种方式可以提高多线程并发效率，如果cas的是当前map对象，同一时刻还是只有一个线程能cas成功；当引入CounterCell数组，cas的是当前线程对应在数组中特定位置的元素，也就是说如果位置不冲突，n个长度的CounterCell数组是可以支持n个线程同时cas成功的。</strong></p><p><strong>这也是ConcurrentHashMap在JDK1.8后采用的并发思想。</strong></p><p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>用一个<code class="language-plaintext highlighter-rouge">volatile</code>修饰的<code class="language-plaintext highlighter-rouge">CounterCell</code>数组采用分片的方法来保存元素个数。CounterCell数组的每个元素都存储一个元素计数，当需要获取元素数量时，调用<code class="language-plaintext highlighter-rouge">sumCount</code>方法统计。<code class="language-plaintext highlighter-rouge">volatile</code>则保证了内存可见性。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">long</span> <span class="nf">sumCount</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">CounterCell</span><span class="o">[]</span> <span class="n">as</span> <span class="o">=</span> <span class="n">counterCells</span><span class="o">;</span> <span class="nc">CounterCell</span> <span class="n">a</span><span class="o">;</span>
  <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">baseCount</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">as</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">as</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">((</span><span class="n">a</span> <span class="o">=</span> <span class="n">as</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>回到addCount方法，首先是进行并发计数。获取<code class="language-plaintext highlighter-rouge">CounterCell</code>数组，如果不为空就进入<code class="language-plaintext highlighter-rouge">if</code>代码块；如果为空就CAS设置<code class="language-plaintext highlighter-rouge">BASECOUNT</code>的值（<code class="language-plaintext highlighter-rouge">BASECOUNT</code>实际上是在未发生并发竞争的情况下元素的计数器），CAS失败了就进入<code class="language-plaintext highlighter-rouge">if</code>代码块。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">((</span><span class="n">as</span> <span class="o">=</span> <span class="n">counterCells</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span>
    <span class="o">!</span><span class="no">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">BASECOUNT</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">baseCount</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">x</span><span class="o">))</span> <span class="o">{</span>
</pre></table></code></div></div><p>很好理解，如果<code class="language-plaintext highlighter-rouge">CounterCell</code>不为空，那说明当前处于多线程环境，需要并发计数。如果<code class="language-plaintext highlighter-rouge">CounterCell</code>为空，但是CAS失败了，说明当前正处于多线程环境不久，也需要并发计数。</p><p>在<code class="language-plaintext highlighter-rouge">if</code>代码块中，首先将未冲突标志位设为<code class="language-plaintext highlighter-rouge">true</code>。然后接连判断以下条件，任何一个条件成立，就进入<code class="language-plaintext highlighter-rouge">fullAddCount</code>方法。</p><ol><li><code class="language-plaintext highlighter-rouge">as == null</code>，说明是前面CAS失败了；</li><li><code class="language-plaintext highlighter-rouge">(m = as.length - 1) &lt; 0</code>，<code class="language-plaintext highlighter-rouge">CounterCell</code>数组没有元素但不为空，说明早处于并发环境；</li><li><code class="language-plaintext highlighter-rouge">(a = as[ThreadLocalRandom.getProbe() &amp; m]) == null</code>，在as数组里用当前线程作为参数找的槽为空（如果不为空，可以直接CAS元素<code class="language-plaintext highlighter-rouge">a</code>了）；</li><li><code class="language-plaintext highlighter-rouge">!(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)))</code>，CAS向槽中填<code class="language-plaintext highlighter-rouge">v</code>失败。</li></ol><p>当出现以上并发问题时，就调用<code class="language-plaintext highlighter-rouge">fullAddCount(x, uncontended)</code>方法，把x填入<code class="language-plaintext highlighter-rouge">CounterCell</code>数组中。</p><p>这里不对<code class="language-plaintext highlighter-rouge">fullAddCount</code>方法过度分析了，可以简单解释一下：</p><ul><li>当出现情况1时，调用这个方法能够创建<code class="language-plaintext highlighter-rouge">CounterCell</code>数组来支持并发计数。</li><li>当出现情况2时，调用这个方法能够初始化<code class="language-plaintext highlighter-rouge">CounterCell</code>数组。</li><li>当出现情况3时，调用这个方法为当前线程创建<code class="language-plaintext highlighter-rouge">CounterCell</code>计数器，并放入<code class="language-plaintext highlighter-rouge">CounterCell</code>数组中。</li><li>当出现情况4时，调用这个方法能够对<code class="language-plaintext highlighter-rouge">CounterCell</code>数组扩容，因为多个线程在CAS<code class="language-plaintext highlighter-rouge">CounterCell</code>元素时，产生了哈希碰撞，所以需要扩容。</li></ul><p>回到<code class="language-plaintext highlighter-rouge">addCount</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">check</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">return</span><span class="o">;</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">sumCount</span><span class="o">();</span>
</pre></table></code></div></div><p>当<code class="language-plaintext highlighter-rouge">check</code>小于等于1时，直接返回。这个<code class="language-plaintext highlighter-rouge">check</code>形参是由<code class="language-plaintext highlighter-rouge">put</code>方法中的<code class="language-plaintext highlighter-rouge">binCount</code>传递来的，所以当<code class="language-plaintext highlighter-rouge">check</code>小于等于1时，说明<code class="language-plaintext highlighter-rouge">put</code>时未发生哈希碰撞，也就无需再往下执行扩容了。</p><p>接下来进入了重点环节，当上一个<code class="language-plaintext highlighter-rouge">if</code>条件未成立或者<code class="language-plaintext highlighter-rouge">check&gt;1</code>时会进入以下逻辑。</p><p>当以下三个条件均成立时，才进入<code class="language-plaintext highlighter-rouge">while</code>循环:</p><ul><li>元素总数大于等于阈值<code class="language-plaintext highlighter-rouge">sizeCtl</code>（前文已经分析过sizeCtl的作用了，不再赘述）。</li><li>当前哈希表不为空。</li><li>表长度仍旧小于<code class="language-plaintext highlighter-rouge">MAXIMUM_CAPACITY</code>（1 « 30）</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">while</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(</span><span class="n">sc</span> <span class="o">=</span> <span class="n">sizeCtl</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
       <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
       <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
</pre></table></code></div></div><p>满足扩容的条件，开始着手扩容。首先调用<code class="language-plaintext highlighter-rouge">resizeStamp</code>方法：返回标记位，以调整大小为n的表的大小。 向左移动<code class="language-plaintext highlighter-rouge">RESIZE_STAMP_SHIFT</code>时必须为负。</p><p>接着判断<code class="language-plaintext highlighter-rouge">sc</code>是否小于0：</p><ul><li><p>如果小于0，检测到其他线程正在初始化，就直接<code class="language-plaintext highlighter-rouge">break</code>。否则CAS设置<code class="language-plaintext highlighter-rouge">SIZECTL</code>的值，成功了就执行<code class="language-plaintext highlighter-rouge">transfer</code>方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">sc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span><span class="n">sc</span> <span class="o">&gt;&gt;&gt;</span> <span class="no">RESIZE_STAMP_SHIFT</span><span class="o">)</span> <span class="o">!=</span> <span class="n">rs</span> <span class="o">||</span> <span class="n">sc</span> <span class="o">==</span> <span class="n">rs</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span>
      <span class="n">sc</span> <span class="o">==</span> <span class="n">rs</span> <span class="o">+</span> <span class="no">MAX_RESIZERS</span> <span class="o">||</span> <span class="o">(</span><span class="n">nt</span> <span class="o">=</span> <span class="n">nextTable</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
      <span class="n">transferIndex</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="k">break</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="no">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">SIZECTL</span><span class="o">,</span> <span class="n">sc</span><span class="o">,</span> <span class="n">sc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
    <span class="n">transfer</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">nt</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div></li><li><p>如果大于等于0，就CAS设置<code class="language-plaintext highlighter-rouge">SIZECTL</code>的值，成功了就执行<code class="language-plaintext highlighter-rouge">transfer</code>方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="no">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">SIZECTL</span><span class="o">,</span> <span class="n">sc</span><span class="o">,</span>
                             <span class="o">(</span><span class="n">rs</span> <span class="o">&lt;&lt;</span> <span class="no">RESIZE_STAMP_SHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">))</span>
  <span class="n">transfer</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</pre></table></code></div></div></li></ul><p>接着来看transfer方法的逻辑。</p><h3 id="transfer方法">transfer方法</h3><p>这是ConcurrentHashMap扩容操作的核心，这个方法相当的长而且非常复杂，因为它支持多线程并发进行扩容操作，并且没有用锁。</p><p>扩容操作分为两个步骤：</p><ol><li>构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。这个单线程的保证是通过RESIZE_STAMP_SHIFT这个常量经过一次运算来保证的。</li><li>将原来table中的元素复制到nextTable中，这里允许多线程进行操作。</li></ol><p>方法开始给<code class="language-plaintext highlighter-rouge">stride</code>变量赋值，先判断CPU的核心数，如果是单核，直接将表长度<code class="language-plaintext highlighter-rouge">n</code>赋值给<code class="language-plaintext highlighter-rouge">stride</code>，表示单核需要承担<code class="language-plaintext highlighter-rouge">rehash</code>所有桶的任务；如果是多核的，让表长度除8（为什么要除8？），然后再除核心数，让每个核心需要处理的桶一样多。如果平均分完后，每个核心分配的桶数量小于16，那么就默认为16。也就是说：</p><ol><li>通过 计算CPU核心数和旧哈希表的长度得到每个核心需要负责迁移多少个桶，每个核心负责的桶数是平均的。</li><li>一个核心至少负责16个桶的任务。</li><li><strong>许多博客将核心数和线程数弄混了，虽然由于此操作时单线程的，一个核心对应一个线程，但是概念不能混淆，否则下面的多线程并发迁移就理解不了了。</strong></li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">stride</span><span class="o">;</span>
<span class="k">if</span> <span class="o">((</span><span class="n">stride</span> <span class="o">=</span> <span class="o">(</span><span class="no">NCPU</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">/</span> <span class="no">NCPU</span> <span class="o">:</span> <span class="n">n</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">MIN_TRANSFER_STRIDE</span><span class="o">)</span>
  <span class="n">stride</span> <span class="o">=</span> <span class="no">MIN_TRANSFER_STRIDE</span><span class="o">;</span> <span class="c1">// subdivide range</span>
</pre></table></code></div></div><p>紧接着判断新的哈希表是否已经创建，如果没有就自行创建：将新表的大小设置为原表的2倍，如果报了OOM，那么就将<code class="language-plaintext highlighter-rouge">sizeCtl</code>设置为理论上的最大值<code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>，作为下一次扩容尝试的大小（见前文对<code class="language-plaintext highlighter-rouge">sizeCtl</code>的解释）。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">nextTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>            <span class="c1">// initiating</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">nt</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;?,?&gt;[</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">];</span><span class="c1">//两倍</span>
    <span class="n">nextTab</span> <span class="o">=</span> <span class="n">nt</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>      <span class="c1">// try to cope with OOME//报OOM了</span>
    <span class="n">sizeCtl</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="n">nextTable</span> <span class="o">=</span> <span class="n">nextTab</span><span class="o">;</span>
  <span class="n">transferIndex</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在继续之前，我们先来看看<code class="language-plaintext highlighter-rouge">ConcurrenthashMap</code>中的一个静态内部类<code class="language-plaintext highlighter-rouge">ForwardingNode</code>，这个类的实例仅存在于扩容过程。此内部类继承自<code class="language-plaintext highlighter-rouge">Node</code>类，除此之外，有一个final修饰的<code class="language-plaintext highlighter-rouge">Node</code>数组类型的成员变量<code class="language-plaintext highlighter-rouge">nextTable</code>，表示扩容后的新的哈希表，由构造器传入参数赋值。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ForwardingNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">nextTable</span><span class="o">;</span>
  <span class="nc">ForwardingNode</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="no">MOVED</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">nextTable</span> <span class="o">=</span> <span class="n">tab</span><span class="o">;</span>
  <span class="o">}</span>
</pre></table></code></div></div><p>这个类还有一个<code class="language-plaintext highlighter-rouge">find</code>方法，这个方法的作用是：为读线程在扩容期间提供跳转到新表的入口，如果读线程在旧表中没有找到需要的节点，就到<code class="language-plaintext highlighter-rouge">ForwardingNode</code>的<code class="language-plaintext highlighter-rouge">nextTable</code>字段引用的新表中继续查找需要的节点。这个方法最外层是一个死循环，跳出这个循环的条件有：</p><ol><li>该桶为<code class="language-plaintext highlighter-rouge">null</code>。</li><li>该桶不为<code class="language-plaintext highlighter-rouge">null</code>，并成功查找到了所需节点（包括以红黑树方式查找）。</li></ol><p>否则会不断通过<code class="language-plaintext highlighter-rouge">ForwardingNode</code>到新表查找节点。</p><p>首先保证传入的<code class="language-plaintext highlighter-rouge">Object</code>参数<code class="language-plaintext highlighter-rouge">k</code>非空，新哈希表也非空并且长度不为0，新哈希表索引<code class="language-plaintext highlighter-rouge">h</code>的位置有元素存在，否则直接返回<code class="language-plaintext highlighter-rouge">null</code>。前三个条件很好理解，第四个条件有这么几种情况：</p><ol><li>旧表中的该桶索引位置本来就没有节点。</li><li>该位置扩容完成了，被迁移到了新节点中。这个情况也直接返回<code class="language-plaintext highlighter-rouge">null</code>，因为扩容完成了，不该由<code class="language-plaintext highlighter-rouge">ForwadingNode</code>来参与查找。</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
    <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">h</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</pre></table></code></div></div><p>上述条件均不成立的情况下，说明可以通过<code class="language-plaintext highlighter-rouge">ForwardingNode</code>查找节点。随后开启一个死循环，在这个循环体中，取出索引<code class="language-plaintext highlighter-rouge">h</code>位置的节点，比较其哈希值和<code class="language-plaintext highlighter-rouge">key</code>值，判断是否与传入的参数相同，如果相同就返回该节点；如果不相同，就判断这个节点的哈希值是否为负数，前面提到哈希值为负数有三种情况，分别代表该节点为正在扩容的节点（<code class="language-plaintext highlighter-rouge">ForwardingNode</code>）、是红黑树节点（<code class="language-plaintext highlighter-rouge">TreeBin</code>）以及保留字段。如果是红黑树，就在红黑树中查找返回，如果是<code class="language-plaintext highlighter-rouge">ForwardingNode</code>，就将该节点指向的<code class="language-plaintext highlighter-rouge">nextTable</code>取出，赋值给<code class="language-plaintext highlighter-rouge">tab</code>变量，重新循环在<code class="language-plaintext highlighter-rouge">nextTable</code>中查找节点。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">eh</span><span class="o">;</span> <span class="no">K</span> <span class="n">ek</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">((</span><span class="n">eh</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span>
      <span class="o">((</span><span class="n">ek</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">||</span> <span class="o">(</span><span class="n">ek</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ek</span><span class="o">))))</span>
    <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">eh</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="nc">ForwardingNode</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">tab</span> <span class="o">=</span> <span class="o">((</span><span class="nc">ForwardingNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">).</span><span class="na">nextTable</span><span class="o">;</span>
      <span class="k">continue</span> <span class="n">outer</span><span class="o">;</span><span class="c1">//跳回外层循环</span>
    <span class="o">}</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>回到<code class="language-plaintext highlighter-rouge">transfer</code>方法，创建了一个<code class="language-plaintext highlighter-rouge">ForwardingNode</code>节点后，这里有两个标志为：</p><ul><li><code class="language-plaintext highlighter-rouge">advance</code>代表是否可以继续处理下一个桶，如果为true，表示当前桶已经处理完毕，可以处理下一个了。</li><li><code class="language-plaintext highlighter-rouge">finishing</code>用于控制扩容何时结束，该标识的另一个用途：最后一个扩容线程会负责重新检查一遍数组查看是否有遗漏的桶。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nc">ForwardingNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">fwd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ForwardingNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">nextTab</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="kt">boolean</span> <span class="n">finishing</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// to ensure sweep before committing nextTab</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bound</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;;)</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>随后开启了一个死循环用于处理一个 stride 长度的任务，其中，<code class="language-plaintext highlighter-rouge">i</code>代表当前处理的槽位序号，<code class="language-plaintext highlighter-rouge">bound</code>代表需要处理的槽位边界。循环体内通过不断地左移<code class="language-plaintext highlighter-rouge">i</code>的值来遍历旧表，进行<code class="language-plaintext highlighter-rouge">rehash</code>。</p><p>在循环体中：首先开启一个<code class="language-plaintext highlighter-rouge">while</code>循环，使用CAS不断尝试为当前线程分配任务，直到分配成功或任务队列已经被全部分配完毕。如果当前线程已经被分配过bucket区域，那么会通过<code class="language-plaintext highlighter-rouge">--i</code>指向下一个待处理bucket然后退出该循环（哈希表从后往前的顺序分配）。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">while</span> <span class="o">(</span><span class="n">advance</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">nextIndex</span><span class="o">,</span> <span class="n">nextBound</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">bound</span> <span class="o">||</span> <span class="n">finishing</span><span class="o">)</span>
    <span class="n">advance</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">nextIndex</span> <span class="o">=</span> <span class="n">transferIndex</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="n">advance</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="no">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span>
           <span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">TRANSFERINDEX</span><span class="o">,</span> <span class="n">nextIndex</span><span class="o">,</span>
            <span class="n">nextBound</span> <span class="o">=</span> <span class="o">(</span><span class="n">nextIndex</span> <span class="o">&gt;</span> <span class="n">stride</span> <span class="o">?</span>
                         <span class="n">nextIndex</span> <span class="o">-</span> <span class="n">stride</span> <span class="o">:</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">{</span>
    <span class="n">bound</span> <span class="o">=</span> <span class="n">nextBound</span><span class="o">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">advance</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>退出这个循环有3个机会：</p><ol><li><code class="language-plaintext highlighter-rouge">--i &gt;= bound || finishing</code>成立一个，如果<code class="language-plaintext highlighter-rouge">--i&gt;=bound</code>说明当前线程已经分配过<code class="language-plaintext highlighter-rouge">bucket</code>区域了，如果<code class="language-plaintext highlighter-rouge">finishing == true</code>，说明扩容已经完成了。</li><li><code class="language-plaintext highlighter-rouge">nextIndex = transferIndex</code> &lt;= 0，表示所有bucket已经被分配完毕了，因为<code class="language-plaintext highlighter-rouge">transferIndex&lt;=0</code>，<code class="language-plaintext highlighter-rouge">transferIndex</code>代表着下一个被划分的索引。</li><li>CAS执行成功，说明成功为当前线程分配了<code class="language-plaintext highlighter-rouge">bucket</code>区域。</li></ol><p>上面都失败了，就循环重来吧。</p><p>–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=</p><p>这里可以举个例子解释一下具体是怎么划分的，以单核CPU、首次扩容（旧表长度为8）为例。当前<code class="language-plaintext highlighter-rouge">stride</code>等于旧哈希表长<code class="language-plaintext highlighter-rouge">n</code>，<code class="language-plaintext highlighter-rouge">transferIndex</code>首先被赋值为<code class="language-plaintext highlighter-rouge">n</code>了。接下来代码进入了上面的循环体中，首先会CAS竞争修改<code class="language-plaintext highlighter-rouge">transferIndex</code>值，如果当前的<code class="language-plaintext highlighter-rouge">nextIndex</code>仍旧等于<code class="language-plaintext highlighter-rouge">transferIndex</code>，那么CAS成功，将<code class="language-plaintext highlighter-rouge">transferIndex</code>的值设置为<code class="language-plaintext highlighter-rouge">nextBound</code>。<code class="language-plaintext highlighter-rouge">nextBound</code>的计算方式如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">nextBound</span> <span class="o">=</span> <span class="o">(</span><span class="n">nextIndex</span> <span class="o">&gt;</span> <span class="n">stride</span> <span class="o">?</span> <span class="n">nextIndex</span> <span class="o">-</span> <span class="n">stride</span> <span class="o">:</span> <span class="mi">0</span><span class="o">)</span>
</pre></table></code></div></div><p>也就是说，当<code class="language-plaintext highlighter-rouge">nextIndex</code>小于等于<code class="language-plaintext highlighter-rouge">stride</code>时，将<code class="language-plaintext highlighter-rouge">transferIndex</code>设置为0。那么什么情况下，<code class="language-plaintext highlighter-rouge">nextIndex</code>（<code class="language-plaintext highlighter-rouge">transferIndex</code> == <code class="language-plaintext highlighter-rouge">nextIndex</code>）会大于<code class="language-plaintext highlighter-rouge">stride</code>？回顾上面的代码，只有当核心数大于1时，<code class="language-plaintext highlighter-rouge">stride</code>会比<code class="language-plaintext highlighter-rouge">transferIndex</code>小。当核心数等于1时，<code class="language-plaintext highlighter-rouge">stride</code>只可能大于等于<code class="language-plaintext highlighter-rouge">transferIndex</code>。所以<code class="language-plaintext highlighter-rouge">nextBound</code>在这个例子中必然等于0。</p><p>CAS成功后，设置区间为<code class="language-plaintext highlighter-rouge">[0, n-1]</code>，即<code class="language-plaintext highlighter-rouge">[0,15]</code>，将这个区间划分给当前核心的一条扩容线程。</p><p>–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=–=</p><p>接下来先跳过下面这个<code class="language-plaintext highlighter-rouge">if</code>代码块看后面的代码。</p><p>调用<code class="language-plaintext highlighter-rouge">tabAt</code>方法获得旧表的<code class="language-plaintext highlighter-rouge">i</code>位置的节点。</p><ul><li>如果为空，就在旧表的这个位置放入<code class="language-plaintext highlighter-rouge">forwardingNode</code>节点指向新节点，起占位标识和转发作用，这是触发并发扩容的关键。</li><li>如果不为空，并且哈希值为<code class="language-plaintext highlighter-rouge">MOVED</code>，说明当前节点已经是<code class="language-plaintext highlighter-rouge">forwardingNode</code>了，说明该位置已经被其他线程迁移过了，将 advance 设置为 true ，以便继续往下一个桶检查并进行迁移操作。</li><li>否则开始对这个索引位置的链表进行<code class="language-plaintext highlighter-rouge">rehash</code>。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
  <span class="n">advance</span> <span class="o">=</span> <span class="n">casTabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">fwd</span><span class="o">);</span>
<span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">fh</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">==</span> <span class="no">MOVED</span><span class="o">)</span>
  <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// already processed</span>
<span class="k">else</span> <span class="o">{</span><span class="c1">//开始rehash</span>
</pre></table></code></div></div><p>开始<code class="language-plaintext highlighter-rouge">rehash</code>前，先获得该链表头节点的监视器锁，并进行加锁后的检验：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">synchronized</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
</pre></table></code></div></div><p>首先判断节点<code class="language-plaintext highlighter-rouge">f</code>哈希值是否大于等于0，根据不同的情况进行<code class="language-plaintext highlighter-rouge">rehash</code>：</p><ul><li>如果是，说明是普通的链表头节点。</li><li>如果不是，说明有可能是红黑树的根节点。</li></ul><p>普通链表的迁移过程：</p><ul><li>遍历整条链表，找出 lastRun 节点。</li><li>根据 lastRun 节点的哈希高位标识(0 或 1，为0说明是低位，为1说明是高位)，首先将 lastRun设置为 ln （LowNode）或者 hn （HighNode）链的末尾部分节点，后续的节点使用头插法拼接。</li><li>使用高位和低位两条链表进行迁移，使用头插法拼接链表。</li><li>使用 volatile 的方式将 ln 链设置到新数组下标为 i 的位置上。</li><li>使用 volatile 的方式将 hn 链设置到新数组下标为 i + n(n为原数组长度) 的位置上</li><li>迁移完成后使用 volatile 的方式将占位对象<code class="language-plaintext highlighter-rouge">fwd</code>设置到旧 hash 桶上，该占位对象的用途是标识该hash桶已被处理过，以及查询请求的转发作用</li><li>设置advance为 true 表示当前 hash 桶已处理完，可以继续处理下一个 hash 桶</li></ul><p><strong>什么是lastRun节点？</strong><a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">图出处</a></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pPS0VLQUk=,size_16,color_FFFFFF,t_70-20210318145113774-20210318151703205.png" alt="img" /></p><p>红黑树的迁移过程省略，本人没有对红黑树深入研究。</p><p>回到前面跳过的<code class="language-plaintext highlighter-rouge">if</code>代码块：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">nextn</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">sc</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">finishing</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">nextTable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">nextTab</span><span class="o">;</span>
    <span class="n">sizeCtl</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="no">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">SIZECTL</span><span class="o">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">sizeCtl</span><span class="o">,</span> <span class="n">sc</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">sc</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="n">resizeStamp</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="no">RESIZE_STAMP_SHIFT</span><span class="o">)</span><span class="c1">//成立，说明该线程不是扩容大军里面的最后一条线程，直接return回到上层while循环</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="n">finishing</span> <span class="o">=</span> <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// recheck before commit</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>如果扩容结束了，就做收尾工作：将 <code class="language-plaintext highlighter-rouge">nextTable</code> 设置为 <code class="language-plaintext highlighter-rouge">null</code>，表示扩容已结束，将 <code class="language-plaintext highlighter-rouge">table</code> 指向新数组，<code class="language-plaintext highlighter-rouge">sizeCtl</code> 设置为扩容阈值。</p><p>每一条线程扩容结束时，就会调用上述代码块中的CAS语句，将并发扩容线程数-1。除了修改结束标识之外，还得设置 i = n; 以便重新检查一遍数组，防止有遗漏未成功迁移的桶。</p><p>以上过程是一条线程处理扩容的操作，如果在扩容期间，其他写线程访问到了<code class="language-plaintext highlighter-rouge">ForwardingNode</code>，那么这些线程会加入到并发扩容的行列。前面介绍put方法的时候，提到了一个<code class="language-plaintext highlighter-rouge">helptransfer</code>方法， 它就是来干这个的。</p><h3 id="小结">小结</h3><p>为了彻底理解，我们在宏观上来看看并发迁移的过程：</p><ul><li>首先某个线程在往哈希表中添加元素后会调用<code class="language-plaintext highlighter-rouge">addCount</code>方法计数；</li><li>当计数结果发现当前元素总数超过了设定的阈值<code class="language-plaintext highlighter-rouge">sizeCtl</code>，于是触发了<code class="language-plaintext highlighter-rouge">resize</code>操作，即调用了<code class="language-plaintext highlighter-rouge">transfer</code>方法。</li><li>如果当前CPU核心数是1个的话，那么这条<code class="language-plaintext highlighter-rouge">rehash</code>线程只能自己默默地负责所有迁移工作。</li><li>如果当前CPU核心数是多个的话，那么这条线程很有可能有帮手了！假设核心1的线程正在执行<code class="language-plaintext highlighter-rouge">rehash</code>，核心2的线程这时对哈希表执行了写操作（读操作不会调用<code class="language-plaintext highlighter-rouge">helptransfer</code>），发现当前哈希表中存在<code class="language-plaintext highlighter-rouge">ForwardingNode</code>，于是它就立马调用<code class="language-plaintext highlighter-rouge">helptransfer</code>方法帮助核心1的线程进行<code class="language-plaintext highlighter-rouge">rehash</code>操作。核心3和核心n遵循核心2的操作。</li></ul><p><strong>我觉得理解并发迁移的关键，就是分清楚单核多线程和多核多线程的关系。</strong></p><p>借用<a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">大佬</a>的图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pPS0VLQUk=,size_16,color_FFFFFF,t_70-20210318151704967.png" alt="img" /></p><p>以下问题摘录自<a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">链接</a></p><h3 id="哈希桶迁移中以及迁移后如何处理get和put方法呢">哈希桶迁移中以及迁移后如何处理get和put方法呢？</h3><ul><li>还未被迁移到的<code class="language-plaintext highlighter-rouge">hash</code>桶正常进行<code class="language-plaintext highlighter-rouge">get</code>和<code class="language-plaintext highlighter-rouge">put</code>操作，因为没有遇到<code class="language-plaintext highlighter-rouge">ForwardingNode</code>。</li><li>正在迁移的桶遇到了<code class="language-plaintext highlighter-rouge">get</code>请求， 通过<code class="language-plaintext highlighter-rouge">ForwardingNode</code>的<code class="language-plaintext highlighter-rouge">nextTable</code>字段转发到新的表上查询。</li><li>正在迁移的桶遇到了<code class="language-plaintext highlighter-rouge">put</code>请求，在<code class="language-plaintext highlighter-rouge">rehash</code>时，链表头节点的哈希值会被设置为<code class="language-plaintext highlighter-rouge">MOVED</code>，写入线程会去协助<code class="language-plaintext highlighter-rouge">rehash</code>。</li></ul><h3 id="如果-lastrun-节点正好在一条全部都为高位或者全部都为低位的链表上会不会形成死循环">如果 lastRun 节点正好在一条全部都为高位或者全部都为低位的链表上，会不会形成死循环？</h3><p><strong>答：</strong>在数组长度为64之前会导致一直扩容，但是到了64或者以上后就会转换为红黑树，因此不会一直死循环 。</p><h3 id="我们都知道并发情况下各线程中的数据可能不是最新的那为什么-get-方法不需要加锁">我们都知道，并发情况下，各线程中的数据可能不是最新的，那为什么 get 方法不需要加锁？</h3><p><strong>答：</strong>get操作全程不需要加锁是因为Node的成员val是用volatile修饰的 。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/%E5%AE%B9%E5%99%A8/'>容器</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" class="post-tag no-text-decoration" >Java源码学习</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Java源码分析之ConcurrentHashMap - 黄玉才的博客&url=www.yucaihuang.com/posts/java-concurrenthashmap/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Java源码分析之ConcurrentHashMap - 黄玉才的博客&u=www.yucaihuang.com/posts/java-concurrenthashmap/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Java源码分析之ConcurrentHashMap - 黄玉才的博客&url=www.yucaihuang.com/posts/java-concurrenthashmap/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/web-url-with-chinese-string/">URL包含中文，请求资源404</a></li><li><a href="/posts/web-docker_2/">Docker：入门</a></li><li><a href="/posts/web-docker_1/">Docker：概述</a></li><li><a href="/posts/web-delete-system-python-in-centos/">centOS误删系统自带python</a></li><li><a href="/posts/springboot-starter-id/">创建自定义Springboot starter</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/priority-queue-src-code-analyze/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Aug 28, 2020 <i class="unloaded">2020-08-28T21:03:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>从算法到源码：PriorityQueue源码学习</h3><div class="text-muted small"><p> 剑指 Offer 41. 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： voi...</p></div></div></a></div><div class="card"> <a href="/posts/java-ArrayList-srccode-analyze/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 16, 2020 <i class="unloaded">2020-09-16T18:27:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java源码分析之ArrayList</h3><div class="text-muted small"><p> 类前注释 先看源码开始的一大段注释，基本上把ArrayList的功能和实现介绍了一下： /** Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addit...</p></div></div></a></div><div class="card"> <a href="/posts/java-hashmap/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Nov 24, 2020 <i class="unloaded">2020-11-24T20:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java源码分析之HashMap</h3><div class="text-muted small"><p> 类前注释 关键点： HashMap和HashTable大致相当，只不过HashMap是非线程安全的，并且允许空值。HashMap集合内的元素顺序是无法保证的，可能会改变。 如果哈希函数将元素正确分散在存储桶中，get和put操作只花费常量时间。迭代整个集合，花费的时间为桶的数量 x 键值对的数量。如果需要对此集合进行迭代操作，那么一定不要把桶的数量初始...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-ioc-analyze/" class="btn btn-outline-primary"><p>Spring IOC原理总结</p></a> <span class="btn btn-outline-primary disabled"><p>-</p></span></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-1</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
