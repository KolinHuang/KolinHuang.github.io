<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Docker文档阅读笔记 | 黄玉才的博客</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Docker文档阅读笔记" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="阅读Docker文档过程中，摘录翻译的笔记。 文档地址：https://docs.docker.com/" /><meta property="og:description" content="阅读Docker文档过程中，摘录翻译的笔记。 文档地址：https://docs.docker.com/" /><link rel="canonical" href="www.yucaihuang.com/posts/web-docker_docs/" /><meta property="og:url" content="www.yucaihuang.com/posts/web-docker_docs/" /><meta property="og:site_name" content="黄玉才的博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-07-02T17:01:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Docker文档阅读笔记" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/posts/web-docker_docs/"},"url":"www.yucaihuang.com/posts/web-docker_docs/","author":{"@type":"Person","name":"Kol Huang"},"description":"阅读Docker文档过程中，摘录翻译的笔记。 文档地址：https://docs.docker.com/","dateModified":"2021-07-02T17:01:00+08:00","datePublished":"2021-07-02T17:01:00+08:00","headline":"Docker文档阅读笔记","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">黄玉才的博客</a></div><div class="site-subtitle font-italic">Focus!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Docker文档阅读笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Docker文档阅读笔记</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Jul 2, 2021, 5:01 PM +0800" > Jul 2 <i class="unloaded">2021-07-02T17:01:00+08:00</i> </span> by <span class="author"> Kol Huang</div></div><div class="post-content"><blockquote><p>阅读Docker文档过程中，摘录翻译的笔记。</p><p>文档地址：https://docs.docker.com/</p></blockquote><h2 id="docker-overview">Docker Overview</h2><p>Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Docker’s methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production.</p><p>重点是separate your applications from your infrastructure，将基础架构与应用分离，以支持软件的快速交付。利用Docker提供的快速交付、测试以及部署方法，能够大大减少Develop和Deploy之间的延迟。</p><h3 id="关于docker平台">关于Docker平台</h3><p>Docker提供了容器，使得我们可以在一个宽松(loosely)且隔离的环境下打包并运行一个程序。这种隔离性以及相应的安全保障，允许开发者在一个主机上同步运行多个容器。同时，容器是轻量级的，但是包含了几乎所有在运行application时需要的环境配置，无需依赖于主机的环境。除此之外，Docker支持容器的共享。</p><p>Docker提供了许多工具和一个平台来管理容器的生命周期。</p><h3 id="我们能用docker做些什么">我们能用Docker做些什么？</h3><p><strong>第一点：快速、一致地交付应用。</strong></p><p>Docker 允许开发人员使用提供应用程序和服务的本地容器在标准化环境中工作（意思是开发环境与测试、生产环境都可以使用同一个容器？关于这一点，还需要了解更多Docker的企业级使用后才能理解！），从而简化了开发生命周期。容器非常适合<strong>持续集成和持续交付 (CI/CD)</strong> 工作流。那么什么是持续集成和持续交付呢？</p><p>考虑一下下面的场景：</p><ul><li>开发者之间通过容器共享工作成果。</li><li>然后他们用Docker将开发的应用push到测试环境中，进行手动或者自动化测试。</li><li>如果发现了BUGs，那么他们就可以在开发环境中修改，并重新部署到测试环境中。</li><li>当测试完毕后，只需要将更新的镜像push到生产环境中即可。</li></ul><p>突出一个<strong>快速、一致！</strong></p><p><strong>第二点：响应式部署和扩展</strong></p><p>基于容器的平台支持高度的可插拔式工作负载。容器可以运行在PC、数据中心的虚拟机、云服务提供商或者混合环境中。</p><p>同时Docker的可插拔和轻量级特性使其能够根据业务需求，实时且非常简单地动态管理工作负载、扩展或者下线应用和服务。</p><p>简单来说就是基于Docker，能够实时部署和扩展应用。</p><p><strong>第三点：在相同的硬件上运行更多的负载</strong></p><p>Docker平台是轻量级的，因此可以将宿主机上更多的算力用在业务应用上。Docker 非常适合高密度环境以及需要以更少资源完成更多任务的中小型部署。（Docker is perfect for <strong>high density environments</strong> and for <strong>small and medium deployments</strong> where you need to do more with fewer resources.）</p><h3 id="docker的架构">Docker的架构</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/Users/huangyucai/Library/Application Support/typora-user-images/image-20210701163809973.png" alt="image-20210701163809973" /></p><p>Docker是基于C/S架构的。Docker客户端与Docker服务端的daemon通信，daemon负责构建、运行和分发容器的繁重（heavy）工作。客户端和服务端Deamon可以同时运行在同一个主机上，当然也可以将Deamon运行在远程服务器上，然后本地用Docker客户端连接。客户端与Deamon使用REST API 通过UNIX套接字或者网络接口通信。</p><p>另一个Docker客户端是Docker Compose，它能够让你和由容器集合构成的应用协同工作。</p><p><strong>Docker daemon</strong></p><p>daemon（称为dockerd）会监听Docker API请求，并管理Docker实例，例如镜像、容器、网络和数据卷。一个daemon可以和其他daemon通信，以管理Docker服务。</p><p><strong>Docker client</strong></p><p>客户端（称为docker）是Docker用户与Docker平台交互的主要途径。当运行类似于<code class="language-plaintext highlighter-rouge">docker run</code>命令时，客户端会把这些命令发送给dockerd执行。docker命令会使用Docker API。一个Docker客户端可以与多个daemon通信。</p><p><strong>Docker registries</strong></p><p>Docker registry(暂且翻译成仓库吧)存储着Docker的镜像。Docker Hub是一个公共的仓库，Docker默认从Docker Hub上拉取镜像。当然，我们也可以配置自己的私有仓库。</p><p>使用<code class="language-plaintext highlighter-rouge">docker pull</code>或者<code class="language-plaintext highlighter-rouge">docker run</code>命令，从配置仓库中拉取镜像，使用<code class="language-plaintext highlighter-rouge">docker push</code>命令，将镜像推送到仓库中。</p><p><strong>Docker objects</strong></p><p>在使用Docker时，我们一直在创建或者使用镜像(images)、容器(containers)、网络(networks)、数据卷(volumes)、插件(plugins)以及其他objects。这里给出这些objects简洁的overview。</p><p><strong>1. images</strong></p><p>image是一个只读的模板，其中包含了创建一个容器的指令。通常情况下，一个镜像是基于另一个镜像创建的，只是添加了一些个性化定制。例如基于<code class="language-plaintext highlighter-rouge">ubuntu</code>镜像，在安装了WEB服务器以及一些配置后，生成了定制的镜像。</p><p>创建个人镜像，需要先按照一定的语法创建一个Dockerfile，这些语法是用来表述创建镜像的步骤的。Dockerfile中的每条指令都会在这个镜像中创建一个层(layer)。当修改Dockerfile并重新编译镜像时，只有被修改的层才会被重新编译。</p><p>这样的设计，是Docker相比于其他虚拟化技术更加轻量级、小巧、快速的原因。</p><p><strong>这里的概念比较重要，简单涉及了镜像的组成以及原理，以及Docker的优势由来。</strong></p><p><strong>2. Container</strong></p><p>容器是镜像的一个运行实例。我们可以通过Docker API或者CLI来创建、启动、停止、移动或者删除一个容器。我们可以将容器连接到一个或者多个网络，连接存储（啥意思？），甚至可以基于当前的运行状态创建一个新的镜像。</p><p>默认情况下，一个容器是与其他容器和宿主机相对隔离（relatively well isolated）的。但是我们可以控制容器的网络、存储或者其他底层子系统与其他容器或者宿主机之间的隔离程度。</p><p>容器在启动时，会根据镜像，以及我们传递的参数进行配置，但是当容器删除后，这些额外的配置状态不会被持久化存储。</p><p>使用示例：</p><p><code class="language-plaintext highlighter-rouge">docker run -it ubuntu /bin/bash</code></p><p>当运行上述命令时，会发生以下事情：</p><ol><li>如果本地没有<code class="language-plaintext highlighter-rouge">ubuntu</code>镜像，那么Docker会从配置仓库中拉取，仿佛你手动运行了<code class="language-plaintext highlighter-rouge">docker pull ubuntu</code>命令。</li><li>Docker会创建一个新的容器，仿佛你手动运行了<code class="language-plaintext highlighter-rouge">docker container create</code>命令。</li><li>Docker会分配给容器一个读写文件系统，作为最后一个layer。这允许一个运行中的容器在它的本地文件系统中创建或者修改文件目录。</li><li>如果没有具体指定网络参数的话，Docker创建一个网络接口将容器连接到默认的网络。这个过程包括分配一个IP地址给容器。默认情况下，容器可以利用宿主机的网络连接外网。</li><li>Docker运行容器并且执行<code class="language-plaintext highlighter-rouge">/bin/bash</code>。参数<code class="language-plaintext highlighter-rouge">-it</code>使得容器以交互模式启动，并且连接到我们的终端，因此我们可以通过键盘输入，同时输出会打印到终端。</li><li>键入<code class="language-plaintext highlighter-rouge">exit</code>命令后，容器会停止运行，但是不会被删除。可以重新启动或者删除它。</li></ol><h3 id="底层技术支持">底层技术支持</h3><p>Docker基于Golang编写，并且利用了许多Linux内核的特性来实现其功能。Docker使用一种叫做<code class="language-plaintext highlighter-rouge">namespaces</code>的技术来提供隔离的工作空间，即容器。当我们运行一个容器时，Docker会为这个容器创建一个<code class="language-plaintext highlighter-rouge">namespaces</code>集合。</p><p>这些<code class="language-plaintext highlighter-rouge">namespaces</code>提供了一层的隔离。容器的每个层面都在单独的<code class="language-plaintext highlighter-rouge">namespace</code>中运行，并且其访问权限仅限于该<code class="language-plaintext highlighter-rouge">namespace</code>。</p><h2 id="get-docker">Get Docker</h2><p><a href="https://docs.docker.com/docker-for-mac/install/">Docker Desktop for Mac</a>：A native application using the macOS sandbox security model which delivers all Docker tools to your Mac.</p><p><a href="https://docs.docker.com/docker-for-windows/install/">Docker Desktop for Windows</a>：A native Windows application which delivers all Docker tools to your Windows computer.</p><p><a href="https://docs.docker.com/engine/install/">Docker for Linux</a>：Install Docker on a computer which already has a Linux distribution installed.</p><h2 id="get-started">Get started</h2><h3 id="part-1-getting-started">Part 1: Getting started</h3><p><strong>Start the tutorial</strong></p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker run <span class="nt">-d</span> <span class="nt">-p</span> 80:80 docker/getting-started
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">-d</code>表示容器支持在后台运行。</li><li><code class="language-plaintext highlighter-rouge">-p 80:80</code>表示将宿主机的80端口映射到容器的80端口。</li><li><code class="language-plaintext highlighter-rouge">docker-getting-started</code>表示使用的镜像。</li></ul><p>TIPS：可以将参数连用：<code class="language-plaintext highlighter-rouge">-dp 80:80</code></p><p><strong>What is a container?</strong></p><p>容器是一个运行在机器上的简单的进程，并与其他进程隔离。隔离机制利用了Linux内核的<code class="language-plaintext highlighter-rouge">namespaces</code>和<code class="language-plaintext highlighter-rouge">cgroups</code>特性。</p><p><strong>What is a container image?</strong></p><p>当运行一个容器时，它使用一个隔离的文件系统。这个定制化的文件系统由容器镜像提供。容器镜像还提供容器运行的各种元数据。</p><h3 id="part-2-sample-application">Part 2: Sample application</h3><p>下载样例：https://github.com/docker/getting-started/tree/master/app</p><p><strong>尝试build the app’s container image</strong></p><p>为了build这个应用，需要用到一个Dockerfile。Dockerfile其实就是一个基于文本的指令脚本，用于创建一个容器镜像。</p><ol><li><p>在package.json的同级目录下创建一个文件，文件名为Dockerfile，填入以下内容：</p><div class="language-dockerfile highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre> <span class="c"># syntax=docker/dockerfile:1</span>
 FROM node:12-alpine
 RUN apk add --no-cache python g++ make
 WORKDIR /app
 COPY . .
 RUN yarn install --production
 CMD ["node", "src/index.js"]
</pre></table></code></div></div><p>确保没有后缀名，否则会在接下来的步骤中出错。</p></li><li><p>到app目录下运行命令：<code class="language-plaintext highlighter-rouge">docker build -t getting-started .</code></p><p>这个命令使用Dockerfile来创建一个新的容器镜像。你应该发现了，在运行 期间下载了许多layers。这是因为我们告诉了builder，我们想要从node:12-alpine镜像开始建立，但是本地并没有这个镜像，所以需要下载。</p><p>镜像下载完毕后，我们将其拷贝到自己的应用中，然后用yarn安装应用的依赖。CMD直接指出启动该镜像的容器所需的默认命令。</p><p>最后-t参数标记我们的镜像为getting-started。</p><p><code class="language-plaintext highlighter-rouge">.</code>告诉Docker从当前目录下寻找Dockerfile。</p></li></ol><p>完整的运行过程日志如下：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="o">[</span>root@iZbp1jbdkmqdd5f5n4hkjfZ app]# docker build <span class="nt">-t</span> getting-started <span class="nb">.</span>
Sending build context to Docker daemon  4.659MB
Step 1/6 : FROM node:12-alpine
12-alpine: Pulling from library/node
ddad3d7c1e96: Pull <span class="nb">complete
</span>3a8370f05d5d: Pull <span class="nb">complete
</span>71a8563b7fea: Pull <span class="nb">complete
</span>119c7e14957d: Pull <span class="nb">complete</span><span class="c">#拉取基本镜像node:12-alpine</span>
Digest: sha256:be24b4fe27c92231c051a06e717b67e2a4dfc70d8edb0281285762292b854c03
Status: Downloaded newer image <span class="k">for </span>node:12-alpine
 <span class="nt">---</span><span class="o">&gt;</span> deeae3752431
Step 2/6 : RUN apk add <span class="nt">--no-cache</span> python g++ make
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>3dc246f7c495
fetch http://dl-cdn.alpinelinux.org/alpine/v3.11/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.11/community/x86_64/APKINDEX.tar.gz
<span class="o">(</span>1/21<span class="o">)</span> Installing binutils <span class="o">(</span>2.33.1-r1<span class="o">)</span>
<span class="o">(</span>2/21<span class="o">)</span> Installing gmp <span class="o">(</span>6.1.2-r1<span class="o">)</span>
<span class="o">(</span>3/21<span class="o">)</span> Installing isl <span class="o">(</span>0.18-r0<span class="o">)</span>
<span class="o">(</span>4/21<span class="o">)</span> Installing libgomp <span class="o">(</span>9.3.0-r0<span class="o">)</span>
<span class="o">(</span>5/21<span class="o">)</span> Installing libatomic <span class="o">(</span>9.3.0-r0<span class="o">)</span>
<span class="o">(</span>6/21<span class="o">)</span> Installing mpfr4 <span class="o">(</span>4.0.2-r1<span class="o">)</span>
<span class="o">(</span>7/21<span class="o">)</span> Installing mpc1 <span class="o">(</span>1.1.0-r1<span class="o">)</span>
<span class="o">(</span>8/21<span class="o">)</span> Installing gcc <span class="o">(</span>9.3.0-r0<span class="o">)</span>
<span class="o">(</span>9/21<span class="o">)</span> Installing musl-dev <span class="o">(</span>1.1.24-r3<span class="o">)</span>
<span class="o">(</span>10/21<span class="o">)</span> Installing libc-dev <span class="o">(</span>0.7.2-r0<span class="o">)</span>
<span class="o">(</span>11/21<span class="o">)</span> Installing g++ <span class="o">(</span>9.3.0-r0<span class="o">)</span>
<span class="o">(</span>12/21<span class="o">)</span> Installing make <span class="o">(</span>4.2.1-r2<span class="o">)</span>
<span class="o">(</span>13/21<span class="o">)</span> Installing libbz2 <span class="o">(</span>1.0.8-r1<span class="o">)</span>
<span class="o">(</span>14/21<span class="o">)</span> Installing expat <span class="o">(</span>2.2.9-r1<span class="o">)</span>
<span class="o">(</span>15/21<span class="o">)</span> Installing libffi <span class="o">(</span>3.2.1-r6<span class="o">)</span>
<span class="o">(</span>16/21<span class="o">)</span> Installing gdbm <span class="o">(</span>1.13-r1<span class="o">)</span>
<span class="o">(</span>17/21<span class="o">)</span> Installing ncurses-terminfo-base <span class="o">(</span>6.1_p20200118-r4<span class="o">)</span>
<span class="o">(</span>18/21<span class="o">)</span> Installing ncurses-libs <span class="o">(</span>6.1_p20200118-r4<span class="o">)</span>
<span class="o">(</span>19/21<span class="o">)</span> Installing readline <span class="o">(</span>8.0.1-r0<span class="o">)</span>
<span class="o">(</span>20/21<span class="o">)</span> Installing sqlite-libs <span class="o">(</span>3.30.1-r2<span class="o">)</span>
<span class="o">(</span>21/21<span class="o">)</span> Installing python2 <span class="o">(</span>2.7.18-r0<span class="o">)</span>
Executing busybox-1.31.1-r10.trigger
OK: 212 MiB <span class="k">in </span>37 packages
Removing intermediate container 3dc246f7c495
 <span class="nt">---</span><span class="o">&gt;</span> 39c9a9dc3b4e
Step 3/6 : WORKDIR /app
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>664a2bf83568
Removing intermediate container 664a2bf83568
 <span class="nt">---</span><span class="o">&gt;</span> 85dd46d1c32d
Step 4/6 : COPY <span class="nb">.</span> <span class="nb">.</span>
 <span class="nt">---</span><span class="o">&gt;</span> e072c970903c
Step 5/6 : RUN yarn <span class="nb">install</span> <span class="nt">--production</span>
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>f5e984e6a6f5
yarn <span class="nb">install </span>v1.22.5
<span class="o">[</span>1/4] Resolving packages...
<span class="o">[</span>2/4] Fetching packages...##安装依赖
info fsevents@1.2.9: The platform <span class="s2">"linux"</span> is incompatible with this module.
info <span class="s2">"fsevents@1.2.9"</span> is an optional dependency and failed compatibility check. Excluding it from installation.
<span class="o">[</span>3/4] Linking dependencies...
<span class="o">[</span>4/4] Building fresh packages...
Done <span class="k">in </span>25.32s.
Removing intermediate container f5e984e6a6f5
 <span class="nt">---</span><span class="o">&gt;</span> 5aa203a10597
Step 6/6 : CMD <span class="o">[</span><span class="s2">"node"</span>, <span class="s2">"src/index.js"</span><span class="o">]</span>
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>09716c0faf9a
Removing intermediate container 09716c0faf9a
 <span class="nt">---</span><span class="o">&gt;</span> 49ddd910ff95
Successfully built 49ddd910ff95
Successfully tagged getting-started:latest
</pre></table></code></div></div><p>查看本地镜像，发现成功建立了一个getting-started镜像：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210705102240745.png" alt="image-20210705102240745" /></p><p><strong>尝试运行它</strong></p><ol><li><code class="language-plaintext highlighter-rouge">docker run -dp 3000:3000 getting-started</code></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/Users/huangyucai/Library/Application Support/typora-user-images/image-20210705102433072.png" alt="image-20210705102433072" /></p><ol><li>在前端访问：<code class="language-plaintext highlighter-rouge">https://localhost:3000</code></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/Users/huangyucai/Library/Application Support/typora-user-images/image-20210705102555795.png" alt="image-20210705102555795" /></p><p><strong>小结</strong></p><p>编写Dockerfile，然后运行<code class="language-plaintext highlighter-rouge">docker build</code>命令基于应用构建镜像，然后就可以根据这个镜像启动容器了。</p><h3 id="part-3-update-the-application">Part 3: Update the application</h3><p>要更新应用，那么需要删除正在启动的旧容器。</p><ol><li>用<code class="language-plaintext highlighter-rouge">docker ps</code>命令查看容器情况。</li><li>用<code class="language-plaintext highlighter-rouge">docker stop</code>命令停止容器。</li><li>用<code class="language-plaintext highlighter-rouge">docker rm</code>命令删除容器。</li><li>或者<code class="language-plaintext highlighter-rouge">docker rm -f &lt;the-container-id&gt;</code></li></ol><p>然后再重新编译镜像以及启动容器即可。</p><h3 id="part-4-share-the-application">Part 4: Share the application</h3><p>要共享Docker镜像，必须用到Docker 仓库(registry)。默认的仓库是Docker Hub，访问需要Docker ID。</p><p>要将容器推送到Docker Hub，首先需要在Docker Hub上创建一个仓库(repository)。</p><p><strong>Push the image</strong></p><ol><li>运行命令：<code class="language-plaintext highlighter-rouge">docker push docker/getting-started</code>。但是我们的镜像名就是<code class="language-plaintext highlighter-rouge">getting-started</code>，所以我们需要给它打标记。</li><li>运行命令：<code class="language-plaintext highlighter-rouge">docker login -u YUOR_USER_NAME</code>登录Docker Hub。</li><li>用<code class="language-plaintext highlighter-rouge">docker tag</code>命令给getting-started镜像重命名：<code class="language-plaintext highlighter-rouge">docker tag getting-started YOUR-USER-NAME/getting-started</code></li><li>最后将其<code class="language-plaintext highlighter-rouge">push</code>上去。如果没有指定tag，Docker默认会用<code class="language-plaintext highlighter-rouge">latest</code>tag标记。</li></ol><h3 id="part-5-persist-the-db">Part 5: Persist the DB</h3><p>“In case you didn’t notice, our todo list is being wiped clean every single time we launch the container.”</p><p>上面这句话啥意思？什么是todo list，在启动容器的时候，为什么会把它清除掉呢？</p><p><strong>The container’s filesystem</strong></p><p>当容器运行时，它使用了一个镜像的许多layers来组成它的文件系统。并且每个容器都有各自的暂存空间（scratch space）来创建、更新、删除文件。任何的修改不会影响到使用同个镜像的容器。</p><p><strong>Container volumes</strong></p><p>Volumes能够将容器的某个文件系统路径连接到宿主机上。如果在被挂载的路径上进行修改，宿主机也能看到变化。</p><p>目前有两种主要的volumes类型。</p><p><strong>Persist the todo data</strong></p><p>默认情况下，todo app将数据存在一个SQLite数据库中，位置在<code class="language-plaintext highlighter-rouge">/etc/todos/todo.db</code>。SQLLite是一个轻量级的关系型数据库，所有数据存储在一个文件中，适用于小型应用。后面我们会尝试把数据库引擎更换。</p><p>由于数据库只存在一个文件中，如果我们将这个文件持久化到主机上，并且让下一个容器可以访问它，那么就可以让这个容器使用已保存的数据，并追加（it should be able to pick up where the last one left off.）。通过创建一个容器卷，并将其attaching（也叫mounting，挂载）到数据存储的目录上，那么我们就能持久化数据了。当容器写入<code class="language-plaintext highlighter-rouge">todo.db</code>文件时，数据会通过容器卷被持久化到主机。</p><p>接下来使用命名容器卷（named volume）。可以将named volume简单地看做一桶数据（bucket of data）。Docker会维护磁盘上物理位置，我们只需要记住这个volume的名字即可。</p><ol><li><p>通过<code class="language-plaintext highlighter-rouge">docker volume create</code>命令创建一个容器卷：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker volume create todo-db
</pre></table></code></div></div></li><li><p>启动todo app容器，并添加<code class="language-plaintext highlighter-rouge">-v</code>参数来指定挂载一个卷。：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker run <span class="nt">-dp</span> 3000:3000 <span class="nt">-v</span> todo-db:/etc/todos getting-started
</pre></table></code></div></div></li></ol><blockquote><p>Named volumes和bind mounts是Docker引擎默认支持的volumes的两种主要类型。除此之外，还有许多volume驱动器插件来支持NFS、SFTP、NetAPP等。当在swarm或者Kubernetes等集群环境的多个主机上运行容器时，这些插件就很重要了。</p></blockquote><p><strong>Dive into the volume</strong></p><p>如果想知道“在使用一个named volume时，Docker将数据存在哪里”这个问题的答案，可以使用<code class="language-plaintext highlighter-rouge">docker volume inspect</code>命令查看：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>docker volume inspect todo-db
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"CreatedAt"</span>: <span class="s2">"2019-09-26T02:18:36Z"</span>,
        <span class="s2">"Driver"</span>: <span class="s2">"local"</span>,
        <span class="s2">"Labels"</span>: <span class="o">{}</span>,
        <span class="s2">"Mountpoint"</span>: <span class="s2">"/var/lib/docker/volumes/todo-db/_data"</span>,
        <span class="s2">"Name"</span>: <span class="s2">"todo-db"</span>,
        <span class="s2">"Options"</span>: <span class="o">{}</span>,
        <span class="s2">"Scope"</span>: <span class="s2">"local"</span>
    <span class="o">}</span>
<span class="o">]</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Mountpoint</code>项就指示了数据存储在磁盘上的具体路径。在大多数机器上，都需要root权限才能访问这个路径。</p><h3 id="part-6-user-bind-mounts">Part 6: User bind mounts</h3><p>上面大致介绍了使用named volume的方法，接下来介绍一下bind mount。</p><p>Bind mount和named volume的一大区别就是，我们可以控制具体的挂载路径。同样地，我们可以用它来持久化数据，但是一般情况下，都是从外部用来给容器提供额外的数据（理解数据的不同流向~）。</p><p>举个栗子：我们在利用Docker开发一个应用的时候，可以利用bind mount将源代码路径挂载上去，那么容器可以感知到源代码的变化，并做出响应，这样可以让我们立刻看到效果。</p><p>对于一个基于Node的应用，nodemon是一个非常好的工具，能够观察文件修改然后重启应用。</p><p><strong>quick volume type comparisons</strong></p><p>比较一下bind mount和named volume：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210707194111605.png" alt="image-20210707194111605" /></p><p><strong>start a dev-mode container</strong></p><p>为了运行一个支持开发工作流（development workflow）的容器，需要以下步骤：</p><ul><li>将源代码挂载到容器上；</li><li>安装所有依赖，包括<code class="language-plaintext highlighter-rouge">dev</code>依赖；</li><li>启动nodemon来观察文件系统的变化。</li></ul><p>操作起来~</p><ol><li><p>保证没有<code class="language-plaintext highlighter-rouge">getting-started</code>容器在运行；</p></li><li><p>运行以下命令：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker run <span class="nt">-dp</span> 3000:3000 <span class="nt">-w</span> /app <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">:/app"</span> node:12-alpine sh <span class="nt">-c</span> <span class="s2">"yarn install &amp;&amp; yarn run dev"</span> 
</pre></table></code></div></div><p>解释以下：</p><ul><li><code class="language-plaintext highlighter-rouge">-w /app</code>：设置命令运行的工作目录或者当前目录</li><li><code class="language-plaintext highlighter-rouge">-v "$(pwd):/app"</code>：将宿主机的当前目录挂载到容器的<code class="language-plaintext highlighter-rouge">/app</code>目录</li><li><code class="language-plaintext highlighter-rouge">node:12-alpine</code>：使用的镜像。</li><li><code class="language-plaintext highlighter-rouge">sh -c "yarn install &amp;&amp; yarn run dev"</code>：要运行的命令。使用sh开启一个shell（alpine没有bash）然后运行<code class="language-plaintext highlighter-rouge">yarn install</code>来安装所有的依赖，再运行<code class="language-plaintext highlighter-rouge">yarn run dev</code>。如果查看package.json，我们会看到dev脚本正在启动nodemon。（yarn是用于node.js包管理的工具~）</li></ul></li><li><p>可以通过<code class="language-plaintext highlighter-rouge">docker logs -f &lt;id&gt;</code>查看日志。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="o">[</span>root@iZbp1jbdkmqdd5f5n4hkjfZ app]# docker logs <span class="nt">-f</span> 4357ce14de51
yarn <span class="nb">install </span>v1.22.5
<span class="o">[</span>1/4] Resolving packages...
<span class="o">[</span>2/4] Fetching packages...
info fsevents@1.2.9: The platform <span class="s2">"linux"</span> is incompatible with this module.
info <span class="s2">"fsevents@1.2.9"</span> is an optional dependency and failed compatibility check. Excluding it from installation.
<span class="o">[</span>3/4] Linking dependencies...
<span class="o">[</span>4/4] Building fresh packages...
Done <span class="k">in </span>34.25s.
yarn run v1.22.5
<span class="nv">$ </span>nodemon src/index.js
<span class="o">[</span>nodemon] 1.19.2
<span class="o">[</span>nodemon] to restart at any <span class="nb">time</span>, enter <span class="sb">`</span>rs<span class="sb">`</span>
<span class="o">[</span>nodemon] watching <span class="nb">dir</span><span class="o">(</span>s<span class="o">)</span>: <span class="k">*</span>.<span class="k">*</span>
<span class="o">[</span>nodemon] starting <span class="sb">`</span>node src/index.js<span class="sb">`</span>
Using sqlite database at /etc/todos/todo.db
Listening on port 3000
</pre></table></code></div></div></li><li><p>接下来对程序进行修改。在<code class="language-plaintext highlighter-rouge">src/static/app.js</code>文件中，将<code class="language-plaintext highlighter-rouge">Add Item</code>按钮简化为<code class="language-plaintext highlighter-rouge">Add</code>，即：</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="o">-</span>                         <span class="p">{</span><span class="nx">submitting</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Adding...</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Add Item</span><span class="dl">'</span><span class="p">}</span>
 <span class="o">+</span>                         <span class="p">{</span><span class="nx">submitting</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Adding...</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Add</span><span class="dl">'</span><span class="p">}</span>
</pre></table></code></div></div></li><li><p>此时，刷新页面访问，会发现变更立马就反映在了浏览器上。期间Node服务器重启可能会耗费点时间，只需刷新等待几秒即可。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210707200047259.png" alt="image-20210707200047259" /></p></li></ol><h3 id="part-7-muitl-container-apps">Part 7: Muitl-container apps</h3><p>目前为止，我们只是在运行一个单一的容器应用。现在，我们想要给应用栈（Application stack）添加一个MySQL。接下来的疑惑就是“该在哪里运行MySQL？是将其运行在一个容器内，还是分隔开来？”。总体上来说，每个容器应当只做一件事，并且将这件事做好。有以下几个理由：</p><ul><li>我们很可能以不同于数据库的方式扩展API和前端。（需和数据库解耦？）</li><li>分离容器可以让版本迭代独立化。</li><li>While you may use a container for the database locally, you may want to use a managed service for the database in production. You don’t want to ship your database engine with your app then.在生产环境中，我们可能使用为数据库托管服务，所以并不希望在应用中发布数据库引擎。</li><li>运行多个进程将需要一个进程管理器（容器只启动一个进程），这增加了容器启动/关闭的复杂性</li></ul><p>So, we will update our application to work like this:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210707201654890.png" alt="image-20210707201654890" style="zoom:50%;" /></p><p><strong>Container networking</strong></p><p>如何让两个互相隔离的容器通信？答案是networking。Simple Rule:</p><blockquote><p>If two containers are on the same network, they can talk to each other. If they aren’t, they can’t.</p></blockquote><p><strong>Start MySQL</strong></p><p>有两种方法能够将一个容器放到一个网络上：</p><ol><li>在开始时就设置。</li><li>连接一个已存在的容器。</li></ol><p>接下来，我们会先创建一个网络，然后将MySQL容器在启动时就连接上该网络。</p><ol><li><p>创建网络：<code class="language-plaintext highlighter-rouge">docker network create todo-app</code> （<strong>这个是重点，不是MySQL</strong>）</p></li><li><p>启动MySQL容器，并连接到该网络（–network），其中会设置一些MySQL的环境参数：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker run <span class="nt">-d</span> <span class="nt">--network</span> todo-app <span class="nt">--network-alias</span> mysql <span class="nt">-v</span> todo-mysql-data:/var/lib/mysql <span class="nt">-e</span> <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>secret <span class="nt">-e</span> <span class="nv">MYSQL_DATABASE</span><span class="o">=</span>todos mysql:5.7
</pre></table></code></div></div><blockquote><p>我们并没有创建named volume，但是docker识别到需求，会自动帮我们创建名为todo-mysql-data的named volume。</p></blockquote></li><li><p>验证连接：<code class="language-plaintext highlighter-rouge">docker exec -it &lt;id&gt; mysql -u root -p</code></p></li></ol><p><strong>Connect to MySQL</strong></p><p>现在已经确定MySQL在运行中，那么如何使用？如何让其他容器访问它？记住，每个容器都有一个独立的IP地址！</p><p>为了解决这个问题，我们将使用 nicolaka/netshoot 容器，它附带了许多可用于故障排除或调试网络问题的工具。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> docker run <span class="nt">-it</span> <span class="nt">--network</span> todo-app nicolaka/netshoot
</pre></table></code></div></div><p>启动以后是这样的：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210707204357093.png" alt="image-20210707204357093" style="zoom:50%;" /></p><p>在容器内，我们可以使用<code class="language-plaintext highlighter-rouge">dig</code>命令，这是一个非常有用的DNS工具。我们可以通过以下命令找到hostname是mysql的IP地址。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>dig mysql
</pre></table></code></div></div><p>结果：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/Users/huangyucai/Library/Application Support/typora-user-images/image-20210707204623843.png" alt="image-20210707204623843" /></p><p>解析结果是<code class="language-plaintext highlighter-rouge">172.18.0.2</code>。虽然 mysql 通常不是有效的主机名，但 Docker 能够将其解析为具有该网络别名的容器的 IP 地址。（上面命令通过<code class="language-plaintext highlighter-rouge">--network-alias</code>设置了~）。</p><p>所以，其他容器只需要和<code class="language-plaintext highlighter-rouge">172.18.0.2</code>通信，就能连接到MySQL数据库了！这不能再简单啦。</p><p><strong>Run your app with MySQL</strong></p><p>todo app支持许多环境变量设置来指向一个数据库实例：</p><ul><li><code class="language-plaintext highlighter-rouge">MYSQL_HOST</code> - the hostname for the running MySQL server</li><li><code class="language-plaintext highlighter-rouge">MYSQL_USER</code> - the username to use for the connection</li><li><code class="language-plaintext highlighter-rouge">MYSQL_PASSWORD</code> - the password to use for the connection</li><li><code class="language-plaintext highlighter-rouge">MYSQL_DB</code> - the database to use once connected</li></ul><blockquote><p>虽然使用 env vars 来设置连接设置对于开发来说通常是可以的，但在生产中运行应用程序时，这是非常不推荐的。 Docker 前安全主管 Diogo Monica 写了一篇精彩的博客文章解释了原因。</p><p>更安全的机制是使用您的容器编排框架(k8s)提供的秘密支持。 在大多数情况下，这些机密作为文件安装在正在运行的容器中。 您会看到许多应用程序（包括 MySQL 映像和 todo app）也支持带有 _FILE 后缀的 env vars，以指向包含该变量的文件。</p><p>例如，设置 MYSQL_PASSWORD_FILE 变量将导致应用程序使用引用文件的内容作为连接密码。 Docker 没有做任何事情来支持这些环境变量。 您的应用程序需要知道查找变量并获取文件内容。</p></blockquote><p>解释完毕，来启动容器吧：</p><ol><li><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker run <span class="nt">-dp</span> 3000:3000 <span class="nt">-w</span> /app <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">:/app"</span> <span class="nt">--network</span> todo-app <span class="nt">-e</span> <span class="nv">MYSQL_HOST</span><span class="o">=</span>mysql <span class="nt">-e</span> <span class="nv">MYSQL_USER</span><span class="o">=</span>root <span class="nt">-e</span> <span class="nv">MYSQL_PASSWORD</span><span class="o">=</span>secret <span class="nt">-e</span> <span class="nv">MYSQL_DB</span><span class="o">=</span>todos node:12-alpine sh <span class="nt">-c</span> <span class="s2">"yarn install &amp;&amp; yarn run dev"</span>
</pre></table></code></div></div></li><li>查看日志：</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210707205651573.png" alt="image-20210707205651573" /></p><p>成功连接到了MySQL服务！</p><h3 id="part-8-user-docker-compose">Part 8: User Docker Compose</h3><p>这也是一个重头戏~前面学习了多容器通信的方法，接下来就讲讲Docker Compose。</p><p>Docker Compose是一个用于定义和共享多容器应用的工具。用Compose，我们可以创建一个YAML文件来定义服务，并且用一个简单的命令来启动或者拆除所有内容。</p><p>使用Compose的一大优势是你可以在一个文件中定义你的应用栈，将其保存在项目仓库的根目录下，并且可以轻松地让其他人为你的项目做出贡献。（说实话，没看懂啥意思）</p><p>其他人只需要克隆你的仓库，并启动Compose。实际上，在GitHub/GitLab上有些项目已经这样做了。</p><p><strong>Install Docker Compose</strong></p><p>在Linux上安装Docker Compose：</p><ol><li><code class="language-plaintext highlighter-rouge">sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</code></li><li><code class="language-plaintext highlighter-rouge">sudo chmod +x /usr/local/bin/docker-compose</code></li><li><code class="language-plaintext highlighter-rouge">docker-compose --version</code></li></ol><p><strong>Create the Compose file</strong></p><ol><li><p>在app项目的根目录创建一个<code class="language-plaintext highlighter-rouge">docker-compose.yml</code>文件。</p></li><li><p>在compose文件中，首先定义架构版本号。在大多数情况下，最好使用最新的支持版本。可以在<a href="https://docs.docker.com/compose/compose-file/">Compose file reference</a>找到最新的版本信息。</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
</pre></table></code></div></div></li><li><p>然后定义我们的应用需要用到的服务列表（或者叫容器）。</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
</pre></table></code></div></div><p>接下来尝试将服务迁移到compose文件中。</p></li></ol><p><strong>Define the app service</strong></p><p>回忆之前创建container的命令：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker run <span class="nt">-dp</span> 3000:3000 <span class="nt">-w</span> /app <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">:/app"</span> <span class="nt">--network</span> todo-app <span class="nt">-e</span> <span class="nv">MYSQL_HOST</span><span class="o">=</span>mysql <span class="nt">-e</span> <span class="nv">MYSQL_USER</span><span class="o">=</span>root <span class="nt">-e</span> <span class="nv">MYSQL_PASSWORD</span><span class="o">=</span>secret <span class="nt">-e</span> <span class="nv">MYSQL_DB</span><span class="o">=</span>todos node:12-alpine sh <span class="nt">-c</span> <span class="s2">"yarn install &amp;&amp; yarn run dev"</span>
</pre></table></code></div></div><ol><li><p>首先定义服务entry以及容器的镜像。可以为服务取任何名字，这个名字会被自动识别为一个network alias，便于容器通信。</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
<span class="err">	</span><span class="na">app</span><span class="pi">:</span>
<span class="err">		</span><span class="na">image</span><span class="pi">:</span> <span class="s">node:12-alpine</span>
</pre></table></code></div></div></li><li><p>通常我们会把command项和image放在一起（无硬性规定）。</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
<span class="err">	</span><span class="na">app</span><span class="pi">:</span>
<span class="err">		</span><span class="na">image</span><span class="pi">:</span> <span class="s">node:12-alpine</span>
<span class="err">		</span><span class="na">command</span><span class="pi">:</span> <span class="s">sh -c "yarn install &amp;&amp; yarn run dev"</span>
</pre></table></code></div></div></li><li><p>再加入端口号：</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
<span class="err">	</span><span class="na">app</span><span class="pi">:</span>
<span class="err">		</span><span class="na">image</span><span class="pi">:</span> <span class="s">node:12-alpine</span>
<span class="err">		</span><span class="na">command</span><span class="pi">:</span> <span class="s">sh -c "yarn install &amp;&amp; yarn run dev"</span>
<span class="err">		</span><span class="na">ports</span><span class="pi">:</span>
<span class="err">			</span><span class="pi">-</span> <span class="s">3000:3000</span>
</pre></table></code></div></div></li><li><p>接着加入工作目录配置和卷挂载，Docker Compose配置卷的一个好处是可以使用相对路径。</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
<span class="err">	</span><span class="na">app</span><span class="pi">:</span>
<span class="err">		</span><span class="na">image</span><span class="pi">:</span> <span class="s">node:12-alpine</span>
<span class="err">		</span><span class="na">command</span><span class="pi">:</span> <span class="s">sh -c "yarn install &amp;&amp; yarn run dev"</span>
<span class="err">		</span><span class="na">ports</span><span class="pi">:</span>
<span class="err">			</span><span class="pi">-</span> <span class="s">3000:3000</span>
<span class="err">		</span><span class="na">working_dir</span><span class="pi">:</span> <span class="s">/app</span>
<span class="err">		</span><span class="na">volumes</span><span class="pi">:</span>
<span class="err">			</span><span class="s">-</span><span class="err">	</span><span class="s">./:/app</span>
</pre></table></code></div></div></li><li><p>最后就是环境变量了：</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
<span class="err">	</span><span class="na">app</span><span class="pi">:</span>
<span class="err">		</span><span class="na">image</span><span class="pi">:</span> <span class="s">node:12-alpine</span>
<span class="err">		</span><span class="na">command</span><span class="pi">:</span> <span class="s">sh -c "yarn install &amp;&amp; yarn run dev"</span>
<span class="err">		</span><span class="na">ports</span><span class="pi">:</span>
<span class="err">			</span><span class="pi">-</span> <span class="s">3000:3000</span>
<span class="err">		</span><span class="na">working_dir</span><span class="pi">:</span> <span class="s">/app</span>
<span class="err">		</span><span class="na">volumes</span><span class="pi">:</span>
<span class="err">			</span><span class="s">-</span><span class="err">	</span><span class="s">./:/app</span>
<span class="err">		</span><span class="na">environment</span><span class="pi">:</span>
<span class="err">    	</span><span class="na">MYSQL_HOST</span><span class="pi">:</span> <span class="s">mysql</span>
      <span class="s">MYSQL_USER</span><span class="pi">:</span> <span class="s">root</span>
      <span class="s">MYSQL_PASSWORD</span><span class="pi">:</span> <span class="s">secret</span>
      <span class="s">MYSQL_DB</span><span class="pi">:</span> <span class="s">todos</span>
</pre></table></code></div></div></li></ol><p><strong>Define the MySQL service</strong></p><p>按照同样的步骤，定义MySQL服务：</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
<span class="err">	</span><span class="na">app</span><span class="pi">:</span> <span class="c1">#这里省略了上面的配置</span>
<span class="err">	</span><span class="na">mysql</span><span class="pi">:</span>
<span class="err">		</span><span class="na">image</span><span class="pi">:</span> <span class="s">mysql:5.7</span>
<span class="err">		</span><span class="na">volumes</span><span class="pi">:</span>
<span class="err">			</span><span class="s">-</span><span class="err">	</span><span class="s">todo-mysql-data:/var/lib/mysql</span>
<span class="err">		</span><span class="na">environment</span><span class="pi">:</span>
      <span class="na">MYSQL_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">secret</span>
      <span class="na">MYSQL_DATABASE</span><span class="pi">:</span> <span class="s">todos</span>
<span class="na">volumes</span><span class="pi">:</span>
<span class="err">	</span><span class="na">todo-mysql-data</span><span class="pi">:</span>
</pre></table></code></div></div><p>值得一提的是，我们在使用<code class="language-plaintext highlighter-rouge">docker run</code>运行容器时，会自动创建named volume，但是Docker Compose不会，所以需要配置<code class="language-plaintext highlighter-rouge">volumes entry</code>。</p><p><strong>Run the application stack</strong></p><p>写完<code class="language-plaintext highlighter-rouge">docker-compose.yml</code>了，尝试运行吧。</p><ol><li><p>首先删除已有容器：<code class="language-plaintext highlighter-rouge">docker rm -f $(docker ps -a)</code></p></li><li><p>启动：<code class="language-plaintext highlighter-rouge">docker-compose up -d</code>，-d表示后台运行。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c">#运行结果</span>
<span class="o">[</span>root@iZbp1jbdkmqdd5f5n4hkjfZ app]# docker-compose up <span class="nt">-d</span>
Creating network <span class="s2">"app_default"</span> with the default driver
Creating volume <span class="s2">"app_todo-mysql-data"</span> with default driver
Creating app_app_1   ... <span class="k">done
</span>Creating app_mysql_1 ... <span class="k">done</span>
</pre></table></code></div></div><p>可以发现，volume和network都被创建了。默认情况下，Docker Compose会自动创建一个网络，所以无需在配置文件中配置network。</p></li><li><p>使用<code class="language-plaintext highlighter-rouge">docker-compose logs -f</code>命令，可以看到每个服务的日志。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210708094718419.png" alt="image-20210708094718419" /></p><p>服务名显示在行首，如果你想要只看一个服务的日志，可以在命令后添加服务名：<code class="language-plaintext highlighter-rouge">docker-compose logs -f app</code>。</p></li><li><p>打开应用查看，可以发现应用都正常启动了。仅用了一行命令就启动完毕了！</p></li></ol><blockquote><p>小插曲</p><p>发现文档的这部分有语法错误：</p><p>“If you don’t already, you’ll see output that looks like this…”</p><p>于是我把它修改为”If you have done already, you’ll see output that looks like this…”</p><p>并提交了PR，被合并了，这是第一次提交PR，以后俺也是对开源社区有贡献的人了~</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210708101406411.png" alt="image-20210708101406411" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210708101444781.png" alt="image-20210708101444781" /></p></blockquote><p><strong>Tear it all down</strong></p><p>运行命令：<code class="language-plaintext highlighter-rouge">docker-compose down</code>可以关闭所有服务。</p><blockquote><p>警告：</p><p>默认情况下，以上命令不会溢出volumes，如果需要移除，在命令中添加<code class="language-plaintext highlighter-rouge">--volumes</code>参数。</p></blockquote><p>成功关闭后，可以再用<code class="language-plaintext highlighter-rouge">docker-compose up</code>去开启其他应用栈，这样就实现了多容器应用间快速的切换。</p><h3 id="part-9-image-building-best-practives">Part 9: Image-building best practives</h3><p>编译镜像的最佳实践~</p><p><strong>Security Scanning</strong></p><p>在编译完一个镜像后，最好用<code class="language-plaintext highlighter-rouge">docker scan</code>命令扫描一下查看是否存在安全漏洞。Docker集成了Snyk以提供漏洞扫描服务。</p><p><strong>Image layering</strong></p><p>可以用<code class="language-plaintext highlighter-rouge">docker image history</code>命令查看镜像是如何构成的。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210708110652897.png" alt="image-20210708110652897" /></p><p>以上输出的每一行对应着镜像中的一个layer。最上面的是最新层。同时可以看到每层的大小，方便定位占用内存大的层。</p><p>注意到有几行被截断了。 如果添加 –no-trunc 标志，将获得完整输出。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker image <span class="nb">history</span> <span class="nt">--no-trunc</span> getting-started
</pre></table></code></div></div><p><strong>Layer caching</strong></p><p>有一个非常重要的技巧需要学习，就是如何减少镜像的编译次数。一旦layer发生变化，所有下游layer也必须重新创建。</p><p>回顾Dockerfile的内容：</p><div class="language-dockerfile highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># syntax=docker/dockerfile:1</span>
<span class="k">FROM</span><span class="s"> node:12-alpine</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="k">RUN </span>yarn <span class="nb">install</span> <span class="nt">--production</span>
<span class="k">CMD</span><span class="s"> ["node", "src/index.js"]</span>
</pre></table></code></div></div><p>和<code class="language-plaintext highlighter-rouge">docker image history</code>的输出比较，我们发现Dockerfile的每行命令都形成了镜像的某一layer。每当我们对镜像进行了修改，yarn依赖会被重新安装一遍。完全没必要在编译时，都将相同的依赖安装一遍，是否有办法改进它？</p><p>为了解决这个问题，我们需要重新编写Dockerfile，让它支持依赖缓存。对于Node-based应用，这些依赖被定义在package.json文件中。</p><ol><li><p>更新Dockerfile文件，先拷贝package.json，安装依赖，然后将所有其他东西拷贝进来。</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1"># syntax=docker/dockerfile:1</span>
 <span class="s">FROM node:12-alpine</span>
 <span class="s">WORKDIR /app</span>
 <span class="s">COPY package.json yarn.lock ./</span>
 <span class="s">RUN yarn install --production</span>
 <span class="s">COPY . .</span>
 <span class="s">CMD ["node", "src/index.js"]</span>
</pre></table></code></div></div></li><li><p>在Dockerfile的同级目录下创建文件<code class="language-plaintext highlighter-rouge">.dockerignore</code>，并填入：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>node_modules
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">.dockerignore</code>文件是一种选择性地仅复制镜像相关文件的简单方法。在这个例子中，文件夹<code class="language-plaintext highlighter-rouge">node_modules</code>中的内容就会在第二个COPY命令中被省略。</p></li><li><p>创建新镜像：<code class="language-plaintext highlighter-rouge">docker build -t getting-started .</code>。</p></li><li><p>对镜像做一些修改，例如源文件中的某些项。</p></li><li><p>重新编译镜像，发现使用了缓存。并且飞一般的速度~</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210708152232455.png" alt="image-20210708152232455" /></p></li></ol><p><strong>Multi-stage builds</strong></p><p>多阶段构建是一个非常强大的工具，可以帮助使用多个阶段来创建映像。 它们有几个优点：</p><ul><li>将构建时依赖项与运行时依赖项分开。</li><li>通过仅传送应用程序需要运行的内容来减少整体镜像大小。</li></ul><p><strong>举例：Maven/Tomcat</strong></p><p>当编译基于Java的应用时，JDK是必须要的，但是在产品中不需要JDK。在构建应用时，也许还需要Maven或者gradle，但是这些在final image中也不需要。所以可以使用多阶段构建：</p><div class="language-dockerfile highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># syntax=docker/dockerfile:1</span>
<span class="k">FROM</span><span class="s"> maven AS build</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="k">RUN </span>mvn package

<span class="k">FROM</span><span class="s"> tomcat</span>
<span class="k">COPY</span><span class="s"> --from=build /app/target/file.war /usr/local/tomcat/webapps </span>
</pre></table></code></div></div><p>在上面这个例子中，我们使用第一个阶段（称作build）来用Maven构建Java程序。在第二个阶段（从<code class="language-plaintext highlighter-rouge">FROM tomcat</code>开始）我们将build阶段的而文件拷贝进来。最终的镜像中只有最后一个阶段的构建结果。</p><h3 id="part-10-what-next">Part 10: What next?</h3><p>在生产环境中运行容器很困难，我们并不像直接登录到服务器上，并运行docker run或者docker-coompose up之类的命令。</p><p>那么如何解决上述问题？</p><p>如果容器挂了会发生什么？</p><p>如何跨多台机器进行扩展？</p><p><strong>容器编排</strong>解决了上面的问题。诸如Kubernetes\Swarm\Nomad\ECS等工具都有助于解决这个问题，但方式略有不同。</p><p><strong>云原生计算基金会项目</strong>：CNCF is a vendor-neutral home for various open-source projects.</p><h2 id="language-specific-guidesnew">Language-specific guides(New)</h2></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/docker/'>docker</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/web/" class="post-tag no-text-decoration" >web</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Docker文档阅读笔记 - 黄玉才的博客&url=www.yucaihuang.com/posts/web-docker_docs/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Docker文档阅读笔记 - 黄玉才的博客&u=www.yucaihuang.com/posts/web-docker_docs/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Docker文档阅读笔记 - 黄玉才的博客&url=www.yucaihuang.com/posts/web-docker_docs/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/web-url-with-chinese-string/">URL包含中文，请求资源404</a></li><li><a href="/posts/web-docker_2/">Docker：入门</a></li><li><a href="/posts/web-docker_1/">Docker：概述</a></li><li><a href="/posts/web-delete-system-python-in-centos/">centOS误删系统自带python</a></li><li><a href="/posts/springboot-starter-id/">创建自定义Springboot starter</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/web-docker_1/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 7, 2020 <i class="unloaded">2020-09-07T19:37:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Docker：概述</h3><div class="text-muted small"><p> 核心思想：隔离。 Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付（shipping）应用、运行应用。 Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。 Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高...</p></div></div></a></div><div class="card"> <a href="/posts/web-docker_2/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 7, 2020 <i class="unloaded">2020-09-07T19:38:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Docker：入门</h3><div class="text-muted small"><p> Docker安装 环境准备 CentOS 7 环境查看 #系统内核是 3.10以上的 # uname -r 3.10.0-514.26.2.el7.x86_64 #系统版本 # cat /etc/os-release NAME="CentOS Linux" VERSION="7 (Core)" ID="centos" ID_LIKE="rhel fedora" ...</p></div></div></a></div><div class="card"> <a href="/posts/web-docker_3/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 7, 2020 <i class="unloaded">2020-09-07T19:39:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Docker：一些练习</h3><div class="text-muted small"><p> Docker 部署 Nginx #docker pull nginx # docker run -d --name nginx01 -p 2300:80 nginx #运行nginx，将容器的80端口映射到宿主机的2300端口 3dc65265a4822ac3d635ad26d008521a4ab5b0d9aa9ec880f9cd4b6339a62d7c # curl loca...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/algorithm-rbtree/" class="btn btn-outline-primary"><p>红黑树</p></a> <a href="/posts/leetcode-competition248/" class="btn btn-outline-primary"><p>Leetcode：第248场周赛记录</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-2</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
