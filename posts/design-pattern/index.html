<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>设计模式 | 黄玉才的博客</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="设计模式" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="设计模式的六大原则" /><meta property="og:description" content="设计模式的六大原则" /><link rel="canonical" href="www.yucaihuang.com/posts/design-pattern/" /><meta property="og:url" content="www.yucaihuang.com/posts/design-pattern/" /><meta property="og:site_name" content="黄玉才的博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-06T18:49:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="设计模式" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/posts/design-pattern/"},"url":"www.yucaihuang.com/posts/design-pattern/","author":{"@type":"Person","name":"Kol Huang"},"description":"设计模式的六大原则","dateModified":"2021-05-06T18:49:00+08:00","datePublished":"2021-05-06T18:49:00+08:00","headline":"设计模式","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">黄玉才的博客</a></div><div class="site-subtitle font-italic">把开源的变成自己的，把自己的变成祖传的!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>设计模式</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>设计模式</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, May 6, 2021, 6:49 PM +0800" > May 6 <i class="unloaded">2021-05-06T18:49:00+08:00</i> </span> by <span class="author"> Kol Huang</div></div><div class="post-content"><h2 id="设计模式的六大原则">设计模式的六大原则</h2><ul><li>开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。</li><li>单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li><li>里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</li><li>依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象放在程序设计的高层，并保持稳定，程序的细节变化由底层的实现层来完成。</li><li>迪米特法则：又名最少知道原则，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li><li>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</li></ul><h2 id="1构建型模式">1.构建型模式</h2><p>提供创建对象的机制，能够提升已有代码的灵活性和可复用性。</p><p>工厂方法：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p>建造者：将一个而复杂的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p><p>原型：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p>单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="11-工厂方法模式">1.1 工厂方法模式</h3><p>创建对象的接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">factory</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author kol Huang
 * @date 2021/5/6
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICommodity</span> <span class="o">{</span>
    <span class="cm">/**
     * 发放奖品
     * @param uId   用户ID
     * @param commodityId   奖品ID
     * @param bizId 业务ID
     * @param extMap    扩展字段，用于存放收货地址等
     * @throws Exception
     */</span>
    <span class="kt">void</span> <span class="nf">sendCommodity</span><span class="o">(</span><span class="nc">String</span> <span class="n">uId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">commodityId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">bizId</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">extMap</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>

</pre></table></code></div></div><p>子类实现接口，实现具体的创建过程：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">factory.impl</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">factory.dto.DeliverReq</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">factory.ICommodity</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">factory.Service.GoodsService</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="cm">/**
 * @author kol Huang
 * @date 2021/5/6
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GoodsCommodityService</span> <span class="kd">implements</span> <span class="nc">ICommodity</span> <span class="o">{</span>

    <span class="nc">GoodsService</span> <span class="n">goodsService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GoodsService</span><span class="o">();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendCommodity</span><span class="o">(</span><span class="nc">String</span> <span class="n">uId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">commodityId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">bizId</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">extMap</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">DeliverReq</span> <span class="n">deliverReq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeliverReq</span><span class="o">();</span>
<span class="c1">//        deliverReq.setXXX</span>
        <span class="nc">Boolean</span> <span class="n">isSuccess</span> <span class="o">=</span> <span class="n">goodsService</span><span class="o">.</span><span class="na">deliverGoods</span><span class="o">(</span><span class="n">deliverReq</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isSuccess</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"实物商品发放失败"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>工厂类统一处理创建：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">factory</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">factory.impl.CouponCommodityService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">factory.impl.GoodsCommodityService</span><span class="o">;</span>

<span class="cm">/**
 * @author kol Huang
 * @date 2021/5/6
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StoreFactory</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ICommodity</span> <span class="nf">getCommoditySerivce</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">commodityType</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="kc">null</span> <span class="o">==</span> <span class="n">commodityType</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">commodityType</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">CouponCommodityService</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">2</span> <span class="o">==</span> <span class="n">commodityType</span><span class="o">)</span>  <span class="k">return</span> <span class="k">new</span> <span class="nc">GoodsCommodityService</span><span class="o">();</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"不存在的商品服务类型"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>优点：满足单一职责，每个类只负责一种业务逻辑；满足开闭原则，对修改闭合，对扩展开放，新增奖品类型时只需要新创建类实现统一接口即可；工厂类封装避免创建者与具体产品逻辑耦合。</p><p>缺点：子类数量会非常多。</p><h3 id="12-抽象工厂模式">1.2 抽象工厂模式</h3><p>注意和简单工厂方法、工厂方法区分开来：</p><p><strong>简单工厂方法</strong>在创建产品时，传递一个参数到工厂类的构建方法中，然后根据参数返回特定的产品；问题就是新增一个型号的产品就要修改这个工厂类，所以有了工厂方法模式。</p><p><strong>工厂方法</strong>是将创建一个产品（比如鼠标Mouse）的功能抽象为一个接口（MouseFactory：Mouse +createMouse()），然后不同型号的鼠标生产工厂（HpMouseFactory、DellMouseFactory）去实现这个接口，编写具体如何生产鼠标，最终工厂的createMouse都是返回静态类型为Mouse，实际类型为xxxMouse的实例。这样在新增新的型号的产品时，只需要再实现MouseFactory接口，然后编写新型号鼠标的生产逻辑即可。</p><p>假设一个工厂能生产多个产品，比如pcFactory能够生产Mouse和Keyboard等，并且有多种pc生产商，比如惠普华为戴尔三星。那么工厂方法就需要进一步抽象，也就是抽象工厂方法。</p><p><strong>抽象工厂方法</strong>抽象出了一个中心工厂，这个中心工厂可以派生出多种生厂商，这些生厂商能够生产多种产品。比如我们有一个pcFactory抽象工厂接口，有生产鼠标和键盘的功能（createMouse、createKeyboard），然后我们创建一个HpFactory实现pcFactory和其抽象方法，完成鼠标和键盘的实际生产，其他工厂以此类推。<strong>所以说当产品只有一个的时候，抽象工厂方法就退化为了工厂方法，当产品有多个时，工厂方法就变为了抽象工厂方法。</strong></p><p>如果我们需要增加一个工厂，只需要实现pcFactory抽象工厂接口，然后实现具体的产品生产逻辑即可。如果我们要添加一个新的产品，那么需要在pcFactory中新增一个接口，然后各大产商去实现这个接口。</p><h3 id="13-建造者模式">1.3 建造者模式</h3><p>建造者模式所完成的内容就是将多个简单对象通过一步步的组装构建出一个复杂对象的过程。即 <strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</strong></p><p>这里采用设计角色的例子，为了便于理解，我们只创建两个角色，分别是普通角色和超级角色。他们都有设置头部、脸部、身体、气血值、魔法值、能量值等方法。值得注意的是设置脸部是依赖于设置头部的，要有先后顺序。</p><p>角色</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Role</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">head</span><span class="o">;</span> <span class="c1">//头部</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">face</span><span class="o">;</span> <span class="c1">//脸部（脸部依赖于头部）</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">body</span><span class="o">;</span> <span class="c1">//身体</span>
    <span class="kd">private</span> <span class="nc">Double</span> <span class="n">hp</span><span class="o">;</span>   <span class="c1">//生命值</span>
    <span class="kd">private</span> <span class="nc">Double</span> <span class="n">sp</span><span class="o">;</span>   <span class="c1">//能量值</span>
    <span class="kd">private</span> <span class="nc">Double</span> <span class="n">mp</span><span class="o">;</span>   <span class="c1">//魔法值</span>

    <span class="c1">//setter and getter </span>
     <span class="c1">// toString </span>
<span class="o">}</span>
</pre></table></code></div></div><p>抽象建造者：抽象建造步骤</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>

    <span class="kd">protected</span> <span class="nc">Role</span> <span class="n">role</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Role</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildHead</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildFace</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildBody</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildHp</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildSp</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildMp</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nc">Role</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">role</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>具体建造者：负责具体的建造步骤设计</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CommonRoleBuilder</span> <span class="kd">extends</span> <span class="nc">Builder</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Role</span> <span class="n">role</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Role</span><span class="o">();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildHead</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setBody</span><span class="o">(</span><span class="s">"common head"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildFace</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setFace</span><span class="o">(</span><span class="s">"common face"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildBody</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setBody</span><span class="o">(</span><span class="s">"common body"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildHp</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setHp</span><span class="o">(</span><span class="mi">100</span><span class="n">d</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildSp</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setSp</span><span class="o">(</span><span class="mi">100</span><span class="n">d</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildMp</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setMp</span><span class="o">(</span><span class="mi">100</span><span class="n">d</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Role</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">role</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SuperRoleBuilder</span> <span class="kd">extends</span> <span class="nc">Builder</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Role</span> <span class="n">role</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Role</span><span class="o">();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildHead</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setBody</span><span class="o">(</span><span class="s">"suoer head"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildFace</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setFace</span><span class="o">(</span><span class="s">"super face"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildBody</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setBody</span><span class="o">(</span><span class="s">"super body"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildHp</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setHp</span><span class="o">(</span><span class="mi">120</span><span class="n">d</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildSp</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setSp</span><span class="o">(</span><span class="mi">120</span><span class="n">d</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildMp</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">role</span><span class="o">.</span><span class="na">setMp</span><span class="o">(</span><span class="mi">120</span><span class="n">d</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Role</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">role</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>指挥者：管理统一的建造过程</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Director</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">construct</span><span class="o">(</span><span class="nc">Builder</span> <span class="n">builder</span><span class="o">){</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildBody</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildHead</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildFace</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildHp</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildMp</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildSp</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>当基本物料不变，而其组合经常变化的时候，适合使用建造者模式。</p><p>使用建造者模式的好处是不用担心忘了指定某个配置，保证了构建过程是稳定的。在 OkHttp、Retrofit 等著名框架的源码中都使用到了建造者模式。</p><p>该模式的主要优点如下：</p><ul><li>封装性好，构建和表示分离。</li><li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li><li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li></ul><p>其缺点如下：</p><ul><li>产品的组成部分必须相同，这限制了其使用范围。</li><li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li><li>产品越多，需要的具体建造者类也就越多。</li></ul><p>我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个”指挥者”的角色。与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。</p><p>也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p><p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p><h3 id="14-原型模式">1.4 原型模式</h3><p><strong>原型模式</strong>是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p><p>原型模式将克隆过程委派给被克隆的实际对象，该模式为所有支持克隆的对象声明了一个通用的接口，该接口允许我们能够克隆对象，同时无需将代码和对象所属类耦合，通常情况下，这样的接口中只包含一个克隆方法。废话不多说，上例子：</p><p>首先我们创建一个实现了Cloneable接口的抽象类：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Shape</span> <span class="kd">implements</span> <span class="nc">Cloneable</span> <span class="o">{</span>
   
   <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
   <span class="kd">protected</span> <span class="nc">String</span> <span class="n">type</span><span class="o">;</span>
   
   <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">();</span>
   
   <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getType</span><span class="o">(){</span>
      <span class="k">return</span> <span class="n">type</span><span class="o">;</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setId</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">Object</span> <span class="n">clone</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="k">try</span> <span class="o">{</span>
         <span class="n">clone</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">clone</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>然后创建抽象类的实体类：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">extends</span> <span class="nc">Shape</span> <span class="o">{</span>
 
   <span class="kd">public</span> <span class="nf">Rectangle</span><span class="o">(){</span>
     <span class="n">type</span> <span class="o">=</span> <span class="s">"Rectangle"</span><span class="o">;</span>
   <span class="o">}</span>
 
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Inside Rectangle::draw() method."</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Square</span> <span class="kd">extends</span> <span class="nc">Shape</span> <span class="o">{</span>
 
   <span class="kd">public</span> <span class="nf">Square</span><span class="o">(){</span>
     <span class="n">type</span> <span class="o">=</span> <span class="s">"Square"</span><span class="o">;</span>
   <span class="o">}</span>
 
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Inside Square::draw() method."</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>然后创建一个类，通过RPC获取一个实例放入缓存，之后通过缓存中实例自带的clone方法复制一个对象，这样就省去了重复RPC的过程，大大提高了实例的复制效率。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Hashtable</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShapeCache</span> <span class="o">{</span>
    
   <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Hashtable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Shape</span><span class="o">&gt;</span> <span class="n">shapeMap</span> 
      <span class="o">=</span> <span class="k">new</span> <span class="nc">Hashtable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Shape</span><span class="o">&gt;();</span>
 
   <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Shape</span> <span class="nf">getShape</span><span class="o">(</span><span class="nc">String</span> <span class="n">shapeId</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Shape</span> <span class="n">cachedShape</span> <span class="o">=</span> <span class="n">shapeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">shapeId</span><span class="o">);</span>
      <span class="k">return</span> <span class="o">(</span><span class="nc">Shape</span><span class="o">)</span> <span class="n">cachedShape</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
   <span class="o">}</span>
 
   <span class="c1">// 对每种形状都运行数据库查询，并创建该形状</span>
   <span class="c1">// shapeMap.put(shapeKey, shape);</span>
   <span class="c1">// 例如，我们要添加三种形状</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loadCache</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">Circle</span> <span class="n">circle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Circle</span><span class="o">();</span>
      <span class="n">circle</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
      <span class="n">shapeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">circle</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span><span class="n">circle</span><span class="o">);</span>
 
      <span class="nc">Square</span> <span class="n">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Square</span><span class="o">();</span>
      <span class="n">square</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
      <span class="n">shapeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">square</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span><span class="n">square</span><span class="o">);</span>
 
      <span class="nc">Rectangle</span> <span class="n">rectangle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">();</span>
      <span class="n">rectangle</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"3"</span><span class="o">);</span>
      <span class="n">shapeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">rectangle</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span><span class="n">rectangle</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="15-单例模式">1.5 单例模式</h3><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><p>单例模式有两种实现方式：饿汉式和懒汉式。</p><p>饿汉式：变量在声明时便初始化。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="n">pricate</span> <span class="nf">Sigleton</span><span class="o">(){</span>
        
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>饿汉式有一个弊端，那就是即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。</p><p>懒汉式：先声明一个空变量，需要用时才初始化。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">pricate</span> <span class="nf">Sigleton</span><span class="o">(){</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。</p><p>加上双重检验锁和防指令重排后：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">pricate</span> <span class="nf">Sigleton</span><span class="o">(){</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">this</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>再说一种Effective Java作者推荐使用的枚举单例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Singleton</span><span class="o">{</span>
  <span class="no">INSTANCE</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">(){</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>利用枚举的特性，让JVM来帮我们保证线程安全和单一实例的问题。除此之外，写法还特别简单.</p><p>还有一种常见的静态内部类方式保证懒汉式单例的线程安全：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonHolder</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">(){</span>
        
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">SingletonHolder</span><span class="o">.</span><span class="na">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>静态内部类方式是怎么实现懒加载的</li><li>静态内部类方式是怎么保证线程安全的</li></ul><p>Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执行类的 clinit 方法（clinit = class + initialize），包括为类的静态变量赋初始值和执行静态代码块中的内容。<strong>但不会立即加载内部类</strong>，<strong>内部类会在使用时才加载</strong>。所以当此 Singleton 类加载时，SingletonHolder 并不会被立即加载，所以不会像饿汉式那样占用内存。</p><p>另外，Java 虚拟机规定，当访问一个类的静态字段时，如果该类尚未初始化，则立即初始化此类。当调用Singleton 的 getInstance 方法时，由于其使用了 SingletonHolder 的静态变量 instance，所以这时才会去初始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。</p><p>第二个问题的答案是 Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。</p><p>一般的建议是：<strong>对于构建不复杂，加载完成后会立即使用的单例对象，推荐使用饿汉式。对于构建过程耗时较长，并不是所有使用此类都会用到的单例对象，推荐使用懒汉式。</strong></p><h2 id="2结构型模式">2.结构型模式</h2><h3 id="21-适配器模式">2.1 适配器模式</h3><p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。</p><p>在业务开发中，我们经常需要做不同接口的兼容，尤其是中台服务，中台需要把各个业务线的各种类型服务做统一包装，再对外提供接口进行使用。</p><p>比如我们的系统中有两套Redis服务，功能类似，但是方法名不同。需求就是我们不能随便修改方法名，并把这两套服务的方法统一，就可以用适配器模式：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cm">/**
 * @author kol Huang
 * @date 2021/5/6
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EGM</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">EGMget</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">EGMset</span><span class="o">(){</span>

    <span class="o">}</span>
<span class="o">}</span>


<span class="cm">/**
 * @author kol Huang
 * @date 2021/5/6
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IIR</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">IIRget</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">IIRset</span><span class="o">(){</span>

    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cm">/**
 * @author kol Huang
 * @date 2021/5/6
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICacheAdapter</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">get</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">();</span>
<span class="o">}</span>

</pre></table></code></div></div><p>适配：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="cm">/**
 * @author kol Huang
 * @date 2021/5/6
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EGMAdapter</span> <span class="kd">implements</span> <span class="nc">ICacheAdapter</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="no">EGM</span> <span class="n">egm</span> <span class="o">=</span> <span class="k">new</span> <span class="no">EGM</span><span class="o">();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">egm</span><span class="o">.</span><span class="na">EGMget</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">egm</span><span class="o">.</span><span class="na">EGMset</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/**
 * @author kol Huang
 * @date 2021/5/6
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IIRAdapter</span> <span class="kd">implements</span> <span class="nc">ICacheAdapter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">IIR</span> <span class="n">iir</span> <span class="o">=</span> <span class="k">new</span> <span class="no">IIR</span><span class="o">();</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">iir</span><span class="o">.</span><span class="na">IIRget</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">iir</span><span class="o">.</span><span class="na">IIRset</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="22-桥接模式">2.2 桥接模式</h3><p>考虑这样一个需求：绘制矩形、圆形、三角形这三种图案。按照面向对象的理念，我们至少需要三个具体类，对应三种不同的图形。</p><p>接下来我们有了新的需求，每种形状都需要有四种不同的颜色：红、蓝、黄、绿。两种设计方案：</p><ul><li>为了复用形状类，将每种形状定义为父类，每种不同颜色的图形继承自其形状父类。此时一共有 12 个类。</li><li>为了复用颜色类，将每种颜色定义为父类，每种不同颜色的图形继承自其颜色父类。此时一共有 12 个类。</li></ul><p>如果以后要增加一种颜色，比如黑色，那么我们就需要增加三个类；如果再要增加一种形状，我们又需要增加五个类，对应 5 种颜色。</p><p>不同的排列组合将会使工作量变得无比的庞大。看来我们不得不重新思考设计方案。</p><p>形状和颜色，都是图形的两个属性。他们两者的关系是平等的，所以不属于继承关系。更好的的实现方式是：<strong>将形状和颜色分离，根据需要对形状和颜色进行组合</strong>，这就是桥接模式的思想。</p><p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。</p><p>通俗地说，如果一个对象有两种或者多种分类方式，并且两种分类方式都容易变化，比如本例中的形状和颜色。这时使用继承很容易造成子类越来越多，所以更好的做法是把这种分类方式分离出来，让他们独立变化，使用时将不同的分类进行组合即可。</p><p>说到这里，不得不提一个设计原则：合成 / 聚合复用原则。虽然它没有被划分到六大设计原则中，但它在面向对象的设计中也非常的重要。</p><p><strong>合成 / 聚合复用原则</strong>：优先使用合成 / 聚合，而不是类继承。</p><p>继承虽然是面向对象的三大特性之一，但继承会导致子类与父类有非常紧密的依赖关系，它会限制子类的灵活性和子类的复用性。而使用合成 / 聚合，也就是使用接口实现的方式，就不存在依赖问题，一个类可以实现多个接口，可以很方便地拓展功能。</p><p>使用桥接模式实现本例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IColor</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getColor</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Red</span> <span class="kd">implements</span> <span class="nc">IColor</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getColor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"red"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Blue</span> <span class="kd">implements</span> <span class="nc">IColor</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getColor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"blue"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在每个形状类中桥接IColor接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span><span class="err">.</span> <span class="nc">interface</span> <span class="nc">IShape</span><span class="o">{</span>
  	<span class="kt">void</span> <span class="nf">draw</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">implements</span> <span class="nc">IShape</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">IColor</span> <span class="n">color</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">setColor</span><span class="o">(</span><span class="nc">IColor</span> <span class="n">color</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">color</span><span class="o">.</span><span class="na">getColor</span><span class="o">()+</span><span class="s">"的矩形"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Round</span> <span class="kd">implements</span> <span class="nc">IShape</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">IColor</span> <span class="n">color</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">setColor</span><span class="o">(</span><span class="nc">IColor</span> <span class="n">color</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">color</span><span class="o">.</span><span class="na">getColor</span><span class="o">()+</span><span class="s">"的圆形"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这时我们再来回顾一下官方定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<strong>抽象部分指的是父类</strong>，对应本例中的<strong>形状类</strong>，实现部分<strong>指的是不同子类的区别之处</strong>。将子类的区别方式 —— 也就是本例中的颜色 —— 分离成接口，通过<strong>组合的方式桥接颜色和形状</strong>，这就是桥接模式，它主要用于 <strong>两个或多个同等级的接口。</strong></p><h3 id="23-组合模式">2.3 组合模式</h3><p>组合模式和桥接模式的组合完全不一样。组合模式用于 整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。</p><p>文件夹和子文件夹的关系：文件夹中可以存放文件，也可以新建文件夹，子文件夹也一样。</p><p>在这些关系中，虽然整体包含了部分，但无论整体或部分，都具有一致的行为。</p><p>组合模式：又叫部分整体模式，是<strong>用于把一组相似的对象当作一个单一的对象。</strong>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Component</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">position</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">job</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Component</span><span class="o">(</span><span class="nc">String</span> <span class="n">position</span><span class="o">,</span> <span class="nc">String</span> <span class="n">job</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">position</span> <span class="o">=</span> <span class="n">position</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">job</span> <span class="o">=</span> <span class="n">job</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"我是"</span><span class="o">+</span><span class="n">position</span> <span class="o">+</span> <span class="s">",我正在"</span><span class="o">+</span><span class="n">job</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">addComponent</span><span class="o">(</span><span class="nc">Component</span> <span class="n">component</span><span class="o">);</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">removeComponent</span><span class="o">(</span><span class="nc">Component</span> <span class="n">component</span><span class="o">);</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Manager</span> <span class="kd">extends</span> <span class="nc">Component</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Component</span><span class="o">&gt;</span> <span class="n">components</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nf">Manager</span><span class="o">(</span><span class="nc">String</span> <span class="n">position</span><span class="o">,</span> <span class="nc">String</span> <span class="n">job</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">position</span><span class="o">,</span> <span class="n">job</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">addComponent</span><span class="o">(</span><span class="nc">Component</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">components</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">removeComponent</span><span class="o">(</span><span class="nc">Component</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">components</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">check</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">work</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Component</span> <span class="n">component</span> <span class="o">:</span> <span class="n">components</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">component</span><span class="o">.</span><span class="na">check</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">extends</span> <span class="nc">Component</span><span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Employee</span><span class="o">(</span><span class="nc">String</span> <span class="n">position</span><span class="o">,</span> <span class="nc">String</span> <span class="n">job</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">position</span><span class="o">,</span> <span class="n">job</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">addComponent</span><span class="o">(</span><span class="nc">Component</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"无权限"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">removeComponent</span><span class="o">(</span><span class="nc">Component</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"无权限"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">check</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">work</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><p>Manager 类和 Employee 类统一声明为 Component 对象。</p></li><li><p>统一调用 Component 对象的 addComponent 方法添加子对象即可。</p></li></ul><p><strong>组合模式中的安全方式与透明方式</strong></p><p>Employee 类虽然继承了父类的 addComponent 和 remove Component 方法，但是仅仅提供了一个空实现，因为 Employee 类是不支持添加和移除组件的。这违背了接口隔离原则。这种方式在组合模式中被称作<strong>透明方式</strong>。</p><p>透明方式：在 Component 中声明所有管理子对象的方法，包括 add、 remove 等，这样继承自 Component 的子类都具备了 add、 remove 方法。对于外界来说叶节点和枝节点是透明的，它们具备完全一致的接口。</p><p>这种方式有它的优点：让 Manager 类和 Employee 类具备完全一致的行为接口，调用者可以一致对待它们。</p><p>但它的缺点也显而易见：Employee 类并不支持管理子对象，不仅违背了接口隔离原则，而且客户端可以用 Employee 类调用 addComponent 和 remove Component 方法，导致程序出错，所以这种方式是不安全的。</p><p>所以我们可以把addComponent 和 remove Component 方法放到Manage中实现：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Manager</span> <span class="kd">extends</span> <span class="nc">Component</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Component</span><span class="o">&gt;</span> <span class="n">components</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nf">Manager</span><span class="o">(</span><span class="nc">String</span> <span class="n">position</span><span class="o">,</span> <span class="nc">String</span> <span class="n">job</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">position</span><span class="o">,</span> <span class="n">job</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addComponent</span><span class="o">(</span><span class="nc">Component</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">components</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeComponent</span><span class="o">(</span><span class="nc">Component</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">components</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">check</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">work</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Component</span> <span class="n">component</span> <span class="o">:</span> <span class="n">components</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">component</span><span class="o">.</span><span class="na">check</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>可以看到，我们在父类中去掉了 addComponent 和 removeComponent 这两个抽象方法，Manager 类单独实现了 addComponent 和 remove Component 这两个方法。这种方式在组合模式中称之为<strong>安全方式</strong>。</p><blockquote><p>安全方式：在 Component中不声明add和 remove等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。</p></blockquote><p>安全方式遵循了接口隔离原则，但由于不够透明， Manager 和 Employee 类不具有相同的接口在客户端中，我们无法将 Manager 和 Employee 统声明为 Component 类了，必须要区别对待，带来了使用上的不方便。</p><p>安全方式和透明方式各有好处，在使用组合模式时，需要根据实际情况决定。但大多数使用组合模式的场景都是采用的透明方式，虽然它有点不安全，但是客户端无需做任何判断来区分是叶子结点还是枝节点，用起来是真香。</p><h3 id="24-装饰模式">2.4 装饰模式</h3><p>在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，这些都可以使用装饰模式。它的主要作用就是：</p><ul><li>增强一个类原有的功能。</li><li>为一个类添加新的功能。</li></ul><p>并且<strong>装饰模式也不会改变原有的类</strong>。</p><p>在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰模式来实现。</p><p>装饰（Decorator）模式的定义：<strong>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</strong></p><p>主要优点有：</p><ul><li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用；</li><li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；</li><li>装饰器模式完全遵守开闭原则。</li></ul><p>其主要缺点是：装饰模式会增加许多子类，过度使用会增加程序得复杂性。</p><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。</p><p>如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，就可以在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式。下面来分析其基本结构和实现方法。</p><p><strong>装饰模式的结构</strong></p><p>装饰模式主要包含以下角色：</p><ol><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ol><h4 id="用于增强功能的装饰模式">用于增强功能的装饰模式</h4><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// 抽象构件角色：颜值接口</span>
<span class="k">class</span> <span class="nc">IBeauty</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">IBeauty</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">getBeautyValue</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 具体构件角色：Me类</span>
<span class="k">class</span> <span class="nc">Me</span><span class="o">:</span> <span class="k">public</span> <span class="n">IBeauty</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// @Override</span>
    <span class="kt">int</span> <span class="n">getBeautyValue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 具体装饰角色：戒指装饰类</span>
<span class="k">class</span> <span class="nc">RingDecorator</span><span class="o">:</span> <span class="k">public</span> <span class="n">IBeauty</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">RingDecorator</span><span class="p">(</span><span class="n">IBeauty</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">me</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// @Override</span>
    <span class="kt">int</span> <span class="n">getBeautyValue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">getBeautyValue</span><span class="p">()</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">public:</span>
    <span class="n">IBeauty</span> <span class="o">*</span><span class="n">me</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">IBeauty</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Me</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"我原本的颜值："</span> <span class="o">&lt;&lt;</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">getBeautyValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">IBeauty</span> <span class="o">*</span><span class="n">meWithRing</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RingDecorator</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"戴上了戒指后，我的颜值："</span> <span class="o">&lt;&lt;</span> <span class="n">meWithRing</span><span class="o">-&gt;</span><span class="n">getBeautyValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>装饰器也实现了 IBeauty 接口，并且没有添加新的方法，也就是说这里的装饰器<strong>仅用于增强功能</strong>，<strong>并不会改变 Me 原有的功能</strong>，这种装饰模式称之为<strong>透明装饰模式</strong>，由于没有改变接口，也没有新增方法，所以<strong>透明装饰模式可以无限装饰</strong>。</p><p>装饰模式是<strong>继承</strong>的一种替代方案。本例如果不使用装饰模式，而是改用继承实现的话，戴着戒指的 Me 需要派生一个子类、戴着项链的 Me 需要派生一个子类、戴着耳环的 Me 需要派生一个子类、戴着戒指 + 项链的需要派生一个子类……各种各样的排列组合会造成类爆炸。而采用了装饰模式就只需要为每个装饰品生成一个装饰类即可，所以说就<strong>增加对象功能</strong>来说，<strong>装饰模式比生成子类实现更为灵活</strong>。</p><h4 id="用于添加功能的装饰模式">用于添加功能的装饰模式</h4><p>我们用程序来模拟一下房屋装饰粘钩后，新增了挂东西功能的过程：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IHouse</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">live</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">House</span> <span class="kd">implements</span> <span class="nc">IHouse</span>
<span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">live</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"居住"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IStickyHookHouse</span> <span class="kd">extends</span> <span class="nc">IHouse</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">hangThings</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StickyHookDecorator</span> <span class="kd">implements</span> <span class="nc">IStickyHookHouse</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">IHouse</span> <span class="n">house</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">StickyHookDecorator</span><span class="o">(</span><span class="nc">IHouse</span> <span class="n">house</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">house</span> <span class="o">=</span> <span class="n">house</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">live</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">house</span><span class="o">.</span><span class="na">live</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hangThings</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"挂东西"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这就是用于<strong>新增功能</strong>的装饰模式。我们在接口中新增了方法：hangThings，然后在装饰器中将 House 类包装起来，之前 House 中的方法仍然调用 house 去执行，也就是说我们并没有修改原有的功能，只是扩展了新的功能，这种模式在装饰模式中称之为<strong>半透明装饰模式</strong>。</p><p>为什么叫半透明呢？由于新的接口 IStickyHookHouse 拥有之前 IHouse 不具有的方法，所以我们如果要使用装饰器中添加的功能，就不得不区别对待<strong>装饰前的对象和装饰后的对象</strong>。也就是说客户端要使用新方法，必须知道具体的装饰类 StickyHookDecorator，所以这个装饰类对客户端来说是可见的、不透明的。而被装饰者不一定要是 House，它可以是实现了 IHouse 接口的任意对象，所以被装饰者对客户端是不可见的、透明的。由于一半透明，一半不透明，所以称之为半透明装饰模式。</p><p>装饰模式，注意不要和适配器模式混淆了。两者在使用时都是包装一个类，但两者的区别其实也很明显：</p><ul><li>纯粹的适配器模式 <strong>仅用于改变接口</strong>，不改变其功能，部分情况下我们需要改变一点功能以适配新接口。但使用适配器模式时，接口一定会有一个 <strong>回炉重造</strong> 的过程。</li><li>装饰模式 <strong>不改变原有的接口</strong>，仅用于增强原有功能或添加新功能，强调的是 <strong>锦上添花</strong>。</li></ul><h3 id="25-外观模式">2.5 外观模式</h3><p>在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。</p><p>软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。</p><p>外观（Facade）模式又叫作门面模式，<strong>是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。</strong>该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2 个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方 SDK、开源类库，很大概率都会使用外观模式。</p><p>外观模式是“迪米特法则”的典型应用，它有以下主要优点。</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ul><p>外观模式的主要缺点如下。</p><ul><li>不能很好地限制客户使用子系统类，很容易带来未知风险。</li><li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><p>另外，在 MVC 架构中，C 层（Controller）就可以看作是外观类，Model 和 View 层通过 Controller 交互，减少了耦合。</p><h3 id="26-享元模式">2.6 享元模式</h3><p>享元模式体现的是 <strong>程序可复用</strong> 的特点，为了节约宝贵的内存</p><p>享元模式：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。</p><h3 id="27-代理模式">2.7 代理模式</h3><p><strong>代理模式</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p>在网络请求前后，分别打印将要发送的数据和接收到数据作为日志信息。此时我们就可以新建一个网络请求的代理类，让它代为处理网络请求，并在代理类中打印这些日志信息。</p><p>除了 打印日志，它还可以用来做权限管理。读者看到这里可能已经发现了，这个代理类看起来和装饰模式的 FilterInputStream 一模一样，但两者的目的不同，装饰模式是为了 增强功能或添加功能，代理模式主要是为了加以控制。</p><p>使用动态代理，需要把一个类传入，然后根据它正在调用的方法名判断是否需要加以控制。</p><h2 id="3行为模式">3.行为模式</h2><h3 id="31-责任链模式">3.1 责任链模式</h3><p>责任链模式允许我们将请求沿着处理者链进行发送，受到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下一个处理者。</p><h3 id="32-命令模式">3.2 命令模式</h3><p>命令模式可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让我们能够根据不同的请求将方法参数化、延迟请求执行或将其放入队列，且能实现可撤销操作。</p><h3 id="33-迭代器模式">3.3 迭代器模式</h3><p>迭代器模式能在不暴露集合底层表现形式的情况下遍历集合中所有的元素。迭代器模式的主要思想是将集合的遍历行为抽取为单独的<em>迭代器</em>对象。</p><p>除实现自身算法外， 迭代器还封装了遍历操作的所有细节， 例如当前位置和末尾剩余元素的数量。 因此， 多个迭代器可以在相互独立的情况下同时访问集合。</p><p>迭代器通常会提供一个获取集合元素的基本方法。 客户端可不断调用该方法直至它不返回任何内容， 这意味着迭代器已经遍历了所有元素。</p><p>所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。</p><h3 id="34-中介者模式">3.4 中介者模式</h3><p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p><h3 id="35-备忘录模式">3.5 备忘录模式</h3><p><strong>备忘录模式</strong>是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><p>模式建议将对象状态的副本存储在一个名为<em>备忘录</em> （Memento） 的特殊对象中。 除了创建备忘录的对象外， 任何对象都不能访问备忘录的内容。 其他对象必须使用受限接口与备忘录进行交互， 它们可以获取快照的元数据 （创建时间和操作名称等）， 但不能获取快照中原始对象的状态。</p><h3 id="36-观察者模式">3.6 观察者模式</h3><p><strong>观察者模式</strong>是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><p>拥有一些值得关注的状态的对象通常被称为<em>目标</em>， 由于它要将自身的状态改变通知给其他对象， 我们也将其称为<em>发布者</em> （publisher）。 所有希望关注发布者状态变化的其他对象被称为<em>订阅者</em> （subscribers）。</p><p>观察者模式建议你为发布者类添加订阅机制， 让每个对象都能订阅或取消订阅发布者事件流。 不要害怕！ 这并不像听上去那么复杂。 实际上， 该机制包括 1） 一个用于存储订阅者对象引用的列表成员变量； 2） 几个用于添加或删除该列表中订阅者的公有方法。</p><p>现在， 无论何时发生了重要的发布者事件， 它都要遍历订阅者并调用其对象的特定通知方法。</p><p>实际应用中可能会有十几个不同的订阅者类跟踪着同一个发布者类的事件， 你不会希望发布者与所有这些类相耦合的。 此外如果他人会使用发布者类， 那么你甚至可能会对其中的一些类一无所知。</p><p>因此， 所有订阅者都必须实现同样的接口， 发布者仅通过该接口与订阅者交互。 接口中必须声明通知方法及其参数， 这样发布者在发出通知时还能传递一些上下文数据。</p><p>如果你的应用中有多个不同类型的发布者， 且希望订阅者可兼容所有发布者， 那么你甚至可以进一步让所有订阅者遵循同样的接口。 该接口仅需描述几个订阅方法即可。 这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态。</p><h3 id="37-状态模式">3.7 状态模式</h3><p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><p>状态模式建议为对象的所有可能状态新建一个类， 然后将所有状态的对应行为抽取到这些类中。</p><p>原始对象被称为<em>上下文</em> （context）， 它并不会自行实现所有行为， 而是会保存一个指向表示当前状态的状态对象的引用， 且将所有与状态相关的工作委派给该对象。</p><p>如需将上下文转换为另外一种状态， 则需将当前活动的状态对象替换为另外一个代表新状态的对象。 采用这种方式是有前提的： 所有状态类都必须遵循同样的接口， 而且上下文必须仅通过接口与这些对象进行交互。</p><p>这个结构可能看上去与<a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>模式相似， 但有一个关键性的不同——在状态模式中， 特定状态知道其他所有状态的存在， 且能触发从一个状态到另一个状态的转换； 策略则几乎完全不知道其他策略的存在。</p><h3 id="38-策略模式">3.8 策略模式</h3><p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p><p>策略模式建议找出负责用许多不同方式完成特定任务的类， 然后将其中的算法抽取到一组被称为<em>策略</em>的独立类中。</p><p>名为<em>上下文</em>的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象。</p><p>上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。 实际上， 上下文并不十分了解策略， 它会通过同样的通用接口与所有策略进行交互， 而该接口只需暴露一个方法来触发所选策略中封装的算法即可。</p><p>因此， 上下文可独立于具体策略。 这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。</p><h3 id="39-模板方法模式">3.9 模板方法模式</h3><p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p><p>模板方法模式建议将算法分解为一系列步骤， 然后将这些步骤改写为方法， 最后在 “模板方法” 中依次调用这些方法。 步骤可以是 <code class="language-plaintext highlighter-rouge">抽象</code>的， 也可以有一些默认的实现。 为了能够使用算法， 客户端需要自行提供子类并实现所有的抽象步骤。 如有必要还需重写一些步骤 （但这一步中不包括模板方法自身）。</p><h3 id="310-访问者模式">3.10 访问者模式</h3><p><strong>访问者模式</strong>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p><p>访问者模式建议将新行为放入一个名为<em>访问者</em>的独立类中， 而不是试图将其整合到已有类中。 现在， 需要执行操作的原始对象将作为参数被传递给访问者中的方法， 让方法能访问对象所包含的一切必要数据。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=设计模式 - 黄玉才的博客&url=www.yucaihuang.com/posts/design-pattern/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=设计模式 - 黄玉才的博客&u=www.yucaihuang.com/posts/design-pattern/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=设计模式 - 黄玉才的博客&url=www.yucaihuang.com/posts/design-pattern/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/web-url-with-chinese-string/">URL包含中文，请求资源404</a></li><li><a href="/posts/web-docker_2/">Docker：入门</a></li><li><a href="/posts/web-docker_1/">Docker：概述</a></li><li><a href="/posts/web-delete-system-python-in-centos/">centOS误删系统自带python</a></li><li><a href="/posts/springboot-starter-id/">创建自定义Springboot starter</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/java-design-mode/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Feb 22 <i class="unloaded">2021-02-22T15:45:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式的六大原则 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象放在程序设计的高层，并保持稳定，层序的细节变化由底层...</p></div></div></a></div><div class="card"> <a href="/posts/java-access-control/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 12, 2020 <i class="unloaded">2020-09-12T18:39:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java访问控制</h3><div class="text-muted small"><p> 父类引用只能调用父类中定义的方法和变量。 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。 还有一种特殊情形，当子类重写了父类的某个方法时，子类的父类引用调用了一个父类的其他方法，这个方法中调用了被重写的父类方法，那么执行的结果会是被重写过后的父类方法，并不会执行原来的父类方法。具体示例如下： class F...</p></div></div></a></div><div class="card"> <a href="/posts/java-meta-annotation/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 25, 2020 <i class="unloaded">2020-09-25T10:17:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java的四个元注解</h3><div class="text-muted small"><p> @Target 描述注解的使用范围，即被修饰的注解可以用在什么地方。 注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数） publi...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/leetcode-evaluate-notation/" class="btn btn-outline-primary"><p>leetcode：表达式求值总结</p></a> <a href="/posts/java-nio/" class="btn btn-outline-primary"><p>浅析Java NIO</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-1</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
