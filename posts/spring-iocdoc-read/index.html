<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Spring IOC技术文档阅读笔记 | 银杏叶</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Spring IOC技术文档阅读笔记" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="1. The IoC Container" /><meta property="og:description" content="1. The IoC Container" /><link rel="canonical" href="www.yucaihuang.com/posts/spring-iocdoc-read/" /><meta property="og:url" content="www.yucaihuang.com/posts/spring-iocdoc-read/" /><meta property="og:site_name" content="银杏叶" /><meta property="og:image" content="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-06T10:47:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" /><meta property="twitter:title" content="Spring IOC技术文档阅读笔记" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"image":"https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/posts/spring-iocdoc-read/"},"url":"www.yucaihuang.com/posts/spring-iocdoc-read/","author":{"@type":"Person","name":"Kol Huang"},"description":"1. The IoC Container","dateModified":"2021-03-06T10:47:00+08:00","datePublished":"2021-03-06T10:47:00+08:00","headline":"Spring IOC技术文档阅读笔记","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">银杏叶</a></div><div class="site-subtitle font-italic">把开源的变成自己的，把自己的变成祖传的!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring IOC技术文档阅读笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring IOC技术文档阅读笔记</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Mar 6, 2021, 10:47 AM +0800" > Mar 6 <i class="unloaded">2021-03-06T10:47:00+08:00</i> </span> by <span class="author"> Kol Huang</div></div><div class="post-content"> <img src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" class="post-preview-img"><h2 id="1-the-ioc-container">1. The IoC Container</h2><p>The <code class="language-plaintext highlighter-rouge">org.springframework.beans</code> and <code class="language-plaintext highlighter-rouge">org.springframework.context</code> packages are the basis for Spring Framework’s IoC container.</p><p>这两个包是Spring框架IoC容器的基础</p><p>The <a href="https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code class="language-plaintext highlighter-rouge">BeanFactory</code></a> interface provides an advanced configuration mechanism capable of managing any type of object.</p><p>BeanFactory接口提供了管理任何类型对象的高级配置机制。ApplicationContext是BeanFactory的子接口。</p><p>It adds:</p><ul><li>Easier integration with Spring’s AOP features；更容易与SpringAOP特性整合</li><li>Message resource handling (for use in internationalization)；消息资源处理</li><li>Event publication；事件发布</li><li>Application-layer specific contexts such as the <code class="language-plaintext highlighter-rouge">WebApplicationContext</code> for use in web applications.</li></ul><p>In short, the <code class="language-plaintext highlighter-rouge">BeanFactory</code> provides the configuration framework and basic functionality, and the <code class="language-plaintext highlighter-rouge">ApplicationContext</code> adds more enterprise-specific functionality.</p><p>简单来说，BeanFactory提供了配置框架和基本的功能，ApplicationContext则添加了更多的企业特定功能。</p><p>在Spring中，用于组成应用脊柱并被IoC容器管理的对象称为beans。</p><p>you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.</p><p>您可以通过提供少量的XML配置来声明性地启用对这些其他元数据格式的支持，从而指示容器将Java注释或代码用作元数据格式。</p><p>The following diagram shows a high-level view of how Spring works. Your application classes are combined with configuration metadata so that, after the <code class="language-plaintext highlighter-rouge">ApplicationContext</code> is created and initialized, you have a fully configured and executable system or application.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/container-magic.png" alt="container magic" /></p><p>metadata支持三种配置方式：</p><ul><li>XML-based configuration</li><li>Annotation-based configuration</li><li>Java-based configuration：@Configuration配置类</li></ul><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-atconfigurable">Using AspectJ to dependency-inject domain objects with Spring</a>.</p><p>Often, each individual XML configuration file represents a logical layer or module in your architecture.</p><h3 id="using-container">Using Container</h3><p>The <code class="language-plaintext highlighter-rouge">ApplicationContext</code> is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies.</p><p>By using the method <code class="language-plaintext highlighter-rouge">T getBean(String name, Class&lt;T&gt; requiredType)</code>, you can retrieve instances of your beans.</p><p>ApplicationContext接口维护着不同Bean及其依赖的注册信息，通过getBean方法可以获取Bean的实例。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210227094138661.png" alt="image-20210227094138661" /></p><h3 id="bean-overview">Bean Overview</h3><p>Within the container itself, these bean definitions are represented as <code class="language-plaintext highlighter-rouge">BeanDefinition</code> objects, which contain (among other information) the following metadata:</p><ul><li>A package-qualified class name: typically, the actual implementation class of the bean being defined. 包限定类名。</li><li>Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).Bean行为控制的Elements，声明Bean在容器中的行为（如scope等）。</li><li>References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.依赖</li><li>Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.要在新创建对象中设置的其他配置。</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210227095127305.png" alt="image-20210227095127305" /></p><p>ApplicationContext实现允许用户在容器外创建的对象被注册到容器中。通过getBeanFactory()方法，获得一个DefaultListableBeanFactory实例，DefaultListableBeanFactory通过registerSingleton(..)<code class="language-plaintext highlighter-rouge"> and </code>registerBeanDefinition(..)支持注册。</p><h4 id="naming-beans">Naming Beans</h4><p>Every bean <strong>has one or more identifiers.</strong> These identifiers must be unique within the container that hosts the bean. <strong>A bean usually has only one identifier.</strong> However, if it requires more than one, the extra ones can be considered aliases.</p><p>In XML-based configuration metadata, you use the <code class="language-plaintext highlighter-rouge">id</code> attribute, the <code class="language-plaintext highlighter-rouge">name</code> attribute, or both to specify the bean identifiers.</p><p>id属性给Bean唯一标识，如果想给Bean取别名，可以使用name属性。在name属性中，用逗号、分号、空格来分割多个别名。</p><p>If you do not supply a <code class="language-plaintext highlighter-rouge">name</code> or <code class="language-plaintext highlighter-rouge">id</code> explicitly, the container generates a unique name for that bean.</p><p>如果不给Bean提供name和id属性，容器会自动为Bean生成一个独一无二的name。</p><p>但是如果想要在其他Bean的ref中使用这个Bean，那么就必须提供id属性或name属性。</p><p>Naming beans consistently makes your configuration easier to read and understand. Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.</p><p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by <code class="language-plaintext highlighter-rouge">java.beans.Introspector.decapitalize</code> (which Spring uses here).</p><p>如果有一个类前两个字符都是大写，那么容器在为其取Bean名的时候，会保留原样，即XXxxxService</p><p><strong>Aliasing a Bean outside the Bean Definition</strong></p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">"fromName"</span> <span class="na">alias=</span><span class="s">"toName"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>这种方法可以给在别处定义的Bean设置别名，例如<import>导入的Bean。</import></p><h4 id="instantiating-beans">Instantiating Beans</h4><p>实例化Bean的两种方法：</p><ul><li>Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code with the <code class="language-plaintext highlighter-rouge">new</code> operator.反射获取</li><li>To specify the actual class containing the <code class="language-plaintext highlighter-rouge">static</code> factory method that is invoked to create the object, in the less common case where the container invokes a <code class="language-plaintext highlighter-rouge">static</code> factory method on a class to create the bean. The object type returned from the invocation of the <code class="language-plaintext highlighter-rouge">static</code> factory method may be the same class or another class entirely.静态工厂方法创建</li></ul><p>If you want to configure a bean definition for a nested class, you may use either the binary name or the source name of the nested class.</p><p>定义内部类Bean的方法：</p><p>For example, if you have a class called <code class="language-plaintext highlighter-rouge">SomeThing</code> in the <code class="language-plaintext highlighter-rouge">com.example</code> package, and this <code class="language-plaintext highlighter-rouge">SomeThing</code> class has a <code class="language-plaintext highlighter-rouge">static</code> nested class called <code class="language-plaintext highlighter-rouge">OtherThing</code>, they can be separated by a dollar sign (<code class="language-plaintext highlighter-rouge">$</code>) or a dot (<code class="language-plaintext highlighter-rouge">.</code>). So the value of the <code class="language-plaintext highlighter-rouge">class</code> attribute in a bean definition would be <code class="language-plaintext highlighter-rouge">com.example.SomeThing$OtherThing</code> or <code class="language-plaintext highlighter-rouge">com.example.SomeThing.OtherThing</code>.</p><p><strong>Instantiation with a Constructor</strong></p><p>当使用构造器来实例化Bean： When you create a bean by the constructor approach, all normal classes are usable by and compatible with Spring. That is, the class being developed does not need to implement any specific interfaces or to be coded in a specific fashion. 对类无特殊要求，只需要指定Bean类就够了。</p><p>However, depending on what type of IoC you use for that specific bean, you may need a default (empty) constructor.</p><p>但是取决于使用的IoC类型，可能需要在类中添加默认的空构造器。</p><p>With XML-based configuration metadata you can specify your bean class as follows:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"exampleBean"</span> <span class="na">class=</span><span class="s">"examples.ExampleBean"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"anotherExample"</span> <span class="na">class=</span><span class="s">"examples.ExampleBeanTwo"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p><strong>Instantiation with a Static Factory Method</strong></p><p>当使用静态工厂方法来实例化Bean：</p><p>When defining a bean that you create with a static factory method, use the <code class="language-plaintext highlighter-rouge">class</code> attribute to specify the class that contains the <code class="language-plaintext highlighter-rouge">static</code> factory method and an attribute named <code class="language-plaintext highlighter-rouge">factory-method</code> to specify the name of the factory method itself.</p><p>需要在<factory-method>属性中提供具体的工厂方法。</factory-method></p><p>The following bean definition specifies that the bean be created by calling a factory method.</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"clientService"</span>
    <span class="na">class=</span><span class="s">"examples.ClientService"</span>
    <span class="na">factory-method=</span><span class="s">"createInstance"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>该定义不指定返回对象的类型（类），而仅指定包含工厂方法的类。</p><p>例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ClientService</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClientService</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nf">ClientService</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ClientService</span> <span class="nf">createInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Instantiation by Using an Instance Factory Method</strong></p><p>通过实例工厂方法实例化Bean：</p><p>让class属性置空，然后又在factory-bean属性中填入当前在容器中的用来实例化这个Bean的Bean名称，在factory-method填入那个Bean中的实例化方法。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"serviceLocator"</span> <span class="na">class=</span><span class="s">"examples.DefaultServiceLocator"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"clientService"</span>
    <span class="na">factory-bean=</span><span class="s">"serviceLocator"</span>
    <span class="na">factory-method=</span><span class="s">"createClientServiceInstance"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"accountService"</span>
    <span class="na">factory-bean=</span><span class="s">"serviceLocator"</span>
    <span class="na">factory-method=</span><span class="s">"createAccountServiceInstance"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultServiceLocator</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ClientService</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClientServiceImpl</span><span class="o">();</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">AccountService</span> <span class="n">accountService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AccountServiceImpl</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nc">ClientService</span> <span class="nf">createClientServiceInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">AccountService</span> <span class="nf">createAccountServiceInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">accountService</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>One factory class can also hold more than one factory method.</p><p>In Spring documentation, “factory bean” refers to a bean that is configured in the Spring container and that creates objects through an <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-instance-factory-method">instance</a> or <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-static-factory-method">static</a> factory method. By contrast, <code class="language-plaintext highlighter-rouge">FactoryBean</code> (notice the capitalization) refers to a Spring-specific <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factorybean"><code class="language-plaintext highlighter-rouge">FactoryBean</code> </a>implementation class.</p><p><strong>Determining a Bean’s Runtime Type</strong></p><p>A specified class in the bean metadata definition is just an initial class reference, potentially combined with a declared factory method or being a <code class="language-plaintext highlighter-rouge">FactoryBean</code> class which may lead to a different runtime type of the bean, or not being set at all in case of an instance-level factory method (which is resolved via the specified <code class="language-plaintext highlighter-rouge">factory-bean</code> name instead). Additionally, AOP proxying may wrap a bean instance with an interface-based proxy with limited exposure of the target bean’s actual type (just its implemented interfaces).</p><p>与声明的工厂方法结合或者是一个FactoryBean类可能会使Bean的运行时类型改变。AOP动态代理也可能会将Bean类型修改为interface-based代理类。</p><p>The recommended way to find out about the actual runtime type of a particular bean is a <code class="language-plaintext highlighter-rouge">BeanFactory.getType</code> call for the specified bean name.</p><p>用Bean name调用BeanFactory.getType方法可以获知Bean实际的运行时类型。</p><h3 id="dependencies">Dependencies</h3><p>A typical enterprise application does not consist of a single object (or bean in the Spring parlance).</p><h4 id="dependency-injection">Dependency Injection</h4><p>Dependency injection (DI) is a process whereby objects define their dependencies (that is, the other objects with which they work) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method.</p><p>DI exists in two major variants: <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection">Constructor-based dependency injection</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-setter-injection">Setter-based dependency injection</a>.</p><p>依赖注入有两种主要方法：基于构造器的注入、基于Setter方法的注入。</p><h5 id="constructor-based-dependency-injection"><strong>Constructor-based Dependency Injection</strong></h5><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleMovieLister</span> <span class="o">{</span>

    <span class="c1">// the SimpleMovieLister has a dependency on a MovieFinder</span>
    <span class="kd">private</span> <span class="nc">MovieFinder</span> <span class="n">movieFinder</span><span class="o">;</span>

    <span class="c1">// a constructor so that the Spring container can inject a MovieFinder</span>
    <span class="kd">public</span> <span class="nf">SimpleMovieLister</span><span class="o">(</span><span class="nc">MovieFinder</span> <span class="n">movieFinder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">movieFinder</span> <span class="o">=</span> <span class="n">movieFinder</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// business logic that actually uses the injected MovieFinder is omitted...</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>构造器参数解析问题</strong></p><p>当参数无歧义时，在<constructor-arg></constructor-arg>标签中无需指定type或index属性。如</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanOne"</span> <span class="na">class=</span><span class="s">"x.y.ThingOne"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;constructor-arg</span> <span class="na">ref=</span><span class="s">"beanTwo"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;constructor-arg</span> <span class="na">ref=</span><span class="s">"beanThree"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanTwo"</span> <span class="na">class=</span><span class="s">"x.y.ThingTwo"</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanThree"</span> <span class="na">class=</span><span class="s">"x.y.ThingThree"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><p>当有歧义时，如：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleBean</span> <span class="o">{</span>

    <span class="c1">// Number of years to calculate the Ultimate Answer</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">years</span><span class="o">;</span>

    <span class="c1">// The Answer to Life, the Universe, and Everything</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">ultimateAnswer</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ExampleBean</span><span class="o">(</span><span class="kt">int</span> <span class="n">years</span><span class="o">,</span> <span class="nc">String</span> <span class="n">ultimateAnswer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">years</span> <span class="o">=</span> <span class="n">years</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ultimateAnswer</span> <span class="o">=</span> <span class="n">ultimateAnswer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>单纯使用value属性无法区分String和int，因此Spring无法确定该注入到哪个构造器参数。</p><p>有三种方法：</p><ol><li><p>指定type，即参数的类型：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"exampleBean"</span> <span class="na">class=</span><span class="s">"examples.ExampleBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">type=</span><span class="s">"int"</span> <span class="na">value=</span><span class="s">"7500000"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">type=</span><span class="s">"java.lang.String"</span> <span class="na">value=</span><span class="s">"42"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div></li><li><p>指定index，即参数在构造器参数列表的索引（0-based）</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"exampleBean"</span> <span class="na">class=</span><span class="s">"examples.ExampleBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">index=</span><span class="s">"0"</span> <span class="na">value=</span><span class="s">"7500000"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">index=</span><span class="s">"1"</span> <span class="na">value=</span><span class="s">"42"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div></li><li><p>指定name，直接使用参数名字</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"exampleBean"</span> <span class="na">class=</span><span class="s">"examples.ExampleBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"years"</span> <span class="na">value=</span><span class="s">"7500000"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"ultimateAnswer"</span> <span class="na">value=</span><span class="s">"42"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>但是：Keep in mind that, to make this work out of the box, your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you cannot or do not want to compile your code with the debug flag, you can use the <a href="https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleBean</span> <span class="o">{</span>
   
    <span class="c1">// Fields omitted</span>
   
    <span class="nd">@ConstructorProperties</span><span class="o">({</span><span class="s">"years"</span><span class="o">,</span> <span class="s">"ultimateAnswer"</span><span class="o">})</span>
    <span class="kd">public</span> <span class="nf">ExampleBean</span><span class="o">(</span><span class="kt">int</span> <span class="n">years</span><span class="o">,</span> <span class="nc">String</span> <span class="n">ultimateAnswer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">years</span> <span class="o">=</span> <span class="n">years</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ultimateAnswer</span> <span class="o">=</span> <span class="n">ultimateAnswer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
   
</pre></table></code></div></div></li></ol><h5 id="setter-based-dependency-injection">Setter-based Dependency Injection</h5><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleMovieLister</span> <span class="o">{</span>

    <span class="c1">// the SimpleMovieLister has a dependency on the MovieFinder</span>
    <span class="kd">private</span> <span class="nc">MovieFinder</span> <span class="n">movieFinder</span><span class="o">;</span>

    <span class="c1">// a setter method so that the Spring container can inject a MovieFinder</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMovieFinder</span><span class="o">(</span><span class="nc">MovieFinder</span> <span class="n">movieFinder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">movieFinder</span> <span class="o">=</span> <span class="n">movieFinder</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// business logic that actually uses the injected MovieFinder is omitted...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies.</p><p>在强制依赖时，使用基于构造器的DI，在可选依赖时，使用基于Setter方法的DI。</p><p>Note that use of the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation">@Required</a> annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.</p><p>在Setter方法上使用@Required注解，能够使得这个属性成为一个必须注入的依赖。</p><p>Spring团队通常提倡构造函数注入，因为它可以让您将应用程序组件实现为不可变对象，并确保所需的依赖项不为null。 此外，构造函数注入的组件始终以完全初始化的状态返回到客户端（调用）代码。</p><p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later.</p><p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, <strong>then constructor injection may be the only available form of DI.</strong></p><p>在使用第三方类库时，如果其未定义Setter方法，那么构造器注入可能是唯一可用的形式。</p><h5 id="dependency-resolution-process">Dependency Resolution Process</h5><p>The container performs bean dependency resolution as follows:</p><ul><li>The <code class="language-plaintext highlighter-rouge">ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations.</li><li>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created.</li><li>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.</li><li>Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">boolean</code>, and so forth.Spring可以将String解析为所有内建类型</li></ul><p>Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Otherwise, the bean is created only when it is requested.</p><p><strong>Circular dependencies</strong></p><p>If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.</p><p>如果主要使用构造函数注入，则可能会创建无法解决的循环依赖方案。</p><p>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a <code class="language-plaintext highlighter-rouge">BeanCurrentlyInCreationException</code>.</p><p>One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.</p><h4 id="dependencies-and-configuration-in-detail">Dependencies and Configuration in Detail</h4><h5 id="straight-values-primitives-strings-and-so-on">Straight Values (Primitives, Strings, and so on)</h5><p>Spring’s <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core-convert-ConversionService-API">conversion service</a> is used to convert these values from a <code class="language-plaintext highlighter-rouge">String</code> to the actual type of the property or argument.</p><p>Spring的转换服务会将这些value从String转换到实际的类型。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"myDataSource"</span> <span class="na">class=</span><span class="s">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="na">destroy-method=</span><span class="s">"close"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- results in a setDriverClassName(String) call --&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"driverClassName"</span> <span class="na">value=</span><span class="s">"com.mysql.jdbc.Driver"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"url"</span> <span class="na">value=</span><span class="s">"jdbc:mysql://localhost:3306/mydb"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"username"</span> <span class="na">value=</span><span class="s">"root"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"password"</span> <span class="na">value=</span><span class="s">"misterkaoli"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>The following example uses the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace">p-namespace</a> for even more succinct XML configuration:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="na">xmlns:p=</span><span class="s">"http://www.springframework.org/schema/p"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"myDataSource"</span> <span class="na">class=</span><span class="s">"org.apache.commons.dbcp.BasicDataSource"</span>
        <span class="na">destroy-method=</span><span class="s">"close"</span>
        <span class="na">p:driverClassName=</span><span class="s">"com.mysql.jdbc.Driver"</span>
        <span class="na">p:url=</span><span class="s">"jdbc:mysql://localhost:3306/mydb"</span>
        <span class="na">p:username=</span><span class="s">"root"</span>
        <span class="na">p:password=</span><span class="s">"misterkaoli"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><p>The preceding XML is more succinct. However, typos are discovered at runtime rather than design time, unless you use an IDE (such as <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> or the <a href="https://spring.io/tools">Spring Tools for Eclipse</a>) that supports automatic property completion when you create bean definitions. Such IDE assistance is highly recommended.</p><p><strong>The</strong> <code class="language-plaintext highlighter-rouge">idref</code> <strong>element</strong></p><p>idref元素只是将容器中另一个bean的id（字符串值-不是引用）传递给<constructor-arg></constructor-arg>或<property></property>元素的一种防错方法。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"theTargetBean"</span> <span class="na">class=</span><span class="s">"..."</span><span class="nt">/&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"theClientBean"</span> <span class="na">class=</span><span class="s">"..."</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"targetName"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;idref</span> <span class="na">bean=</span><span class="s">"theTargetBean"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>与下面等价：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"theTargetBean"</span> <span class="na">class=</span><span class="s">"..."</span> <span class="nt">/&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"client"</span> <span class="na">class=</span><span class="s">"..."</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"targetName"</span> <span class="na">value=</span><span class="s">"theTargetBean"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

</pre></table></code></div></div><p>第一种形式优于第二种形式，因为使用idref标记可使容器在部署时验证所引用的名为bean的实际存在。</p><p>A common place (at least in versions earlier than Spring 2.0) where the <code class="language-plaintext highlighter-rouge">&lt;idref/&gt;</code> element brings value is in the configuration of <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-1">AOP interceptors</a> in a <code class="language-plaintext highlighter-rouge">ProxyFactoryBean</code> bean definition. Using <code class="language-plaintext highlighter-rouge">&lt;idref/&gt;</code> elements when you specify the interceptor names prevents you from misspelling an interceptor ID.</p><idref /><p>元素带来价值的一个常见地方（至少在Spring 2.0之前的版本中）是在ProxyFactoryBean bean定义中的AOP拦截器的配置中。 在指定拦截器名称时使用<idref></idref>元素可防止您拼写错误的拦截器ID。</p><h5 id="references-to-other-beans-collaborators">References to Other Beans (Collaborators)</h5><p>Specifying the target bean through the <code class="language-plaintext highlighter-rouge">bean</code> attribute of the <code class="language-plaintext highlighter-rouge">&lt;ref/&gt;</code> tag is the most general form and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file.</p><p>通过<ref></ref>标记的bean属性指定目标bean是最通用的形式，它允许在同一容器或父容器中创建对任何bean的引用，而不管它是否在同一XML文件中。 bean属性的值可以与目标bean的id属性相同，也可以与目标bean的name属性中的值之一相同。</p><p>通过parent属性指定目标Bean会创建对当前容器的父容器中Bean的引用。 父属性的值可以与目标Bean的id属性或目标Bean的名称属性中的值之一相同。 目标Bean必须位于当前容器的父容器中。 主要在具有容器层次结构并且要使用与父bean名称相同的代理将现有bean封装在父容器中时，才应使用此bean参考变量。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- in the parent context --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"accountService"</span> <span class="na">class=</span><span class="s">"com.something.SimpleAccountService"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- insert dependencies as required as here --&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

</pre></table></code></div></div><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- in the child (descendant) context --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"accountService"</span> <span class="err">&lt;!--</span> <span class="err">bean</span> <span class="err">name</span> <span class="err">is</span> <span class="err">the</span> <span class="err">same</span> <span class="err">as</span> <span class="err">the</span> <span class="err">parent</span> <span class="err">bean</span> <span class="err">--</span><span class="nt">&gt;</span>
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"target"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;ref</span> <span class="na">parent=</span><span class="s">"accountService"</span><span class="nt">/&gt;</span> <span class="c">&lt;!-- notice how we refer to the parent bean --&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="c">&lt;!-- insert other configuration and dependencies as required here --&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><h5 id="inner-beans">Inner Beans</h5><p>A <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code> element inside the <code class="language-plaintext highlighter-rouge">&lt;property/&gt;</code> or <code class="language-plaintext highlighter-rouge">&lt;constructor-arg/&gt;</code> elements defines an inner bean, as the following example shows:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"outer"</span> <span class="na">class=</span><span class="s">"..."</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"target"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.example.Person"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- this is the inner bean --&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"name"</span> <span class="na">value=</span><span class="s">"Fiona Apple"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"age"</span> <span class="na">value=</span><span class="s">"25"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/bean&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>An inner bean definition does not require a defined ID or name. The container also ignores the <code class="language-plaintext highlighter-rouge">scope</code> flag on creation, because inner beans are always anonymous and a<strong>re always created with the outer bean.</strong>It is not possible to access inner beans independently or to inject them into collaborating beans other than into the enclosing bean.</p><h5 id="collections">Collections</h5><p>The <code class="language-plaintext highlighter-rouge">&lt;list/&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;set/&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;map/&gt;</code>, and <code class="language-plaintext highlighter-rouge">&lt;props/&gt;</code> elements set the properties and arguments of the Java <code class="language-plaintext highlighter-rouge">Collection</code> types <code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Set</code>, <code class="language-plaintext highlighter-rouge">Map</code>, and <code class="language-plaintext highlighter-rouge">Properties</code>, respectively. The following example shows how to use them:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"moreComplexObject"</span> <span class="na">class=</span><span class="s">"example.ComplexObject"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"adminEmails"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;props&gt;</span>
            <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">"administrator"</span><span class="nt">&gt;</span>administrator@example.org<span class="nt">&lt;/prop&gt;</span>
            <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">"support"</span><span class="nt">&gt;</span>support@example.org<span class="nt">&lt;/prop&gt;</span>
            <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">"development"</span><span class="nt">&gt;</span>development@example.org<span class="nt">&lt;/prop&gt;</span>
        <span class="nt">&lt;/props&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="c">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"someList"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;list&gt;</span>
            <span class="nt">&lt;value&gt;</span>a list element followed by a reference<span class="nt">&lt;/value&gt;</span>
            <span class="nt">&lt;ref</span> <span class="na">bean=</span><span class="s">"myDataSource"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/list&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="c">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"someMap"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;map&gt;</span>
            <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"an entry"</span> <span class="na">value=</span><span class="s">"just some string"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;entry</span> <span class="na">key =</span><span class="s">"a ref"</span> <span class="na">value-ref=</span><span class="s">"myDataSource"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/map&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="c">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"someSet"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;set&gt;</span>
            <span class="nt">&lt;value&gt;</span>just some string<span class="nt">&lt;/value&gt;</span>
            <span class="nt">&lt;ref</span> <span class="na">bean=</span><span class="s">"myDataSource"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/set&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>The value of a map key or value, or a set value, can also be any of the following elements:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>bean | ref | idref | list | set | map | props | value | null
</pre></table></code></div></div><p><strong>Collection Merging</strong></p><p>The Spring container also supports merging collections. An application developer can define a parent<list></list>, &lt;map/&gt;, <set></set> or<props></props> element and have child<list></list>, &lt;map/&gt;, <set></set> or<props></props> elements inherit and override values from the parent collection.</p><p>也就是说，子集合的值是<strong>合并</strong>父集合和子集合的元素的结果，子集合的元素会<strong>覆盖</strong>父集合中指定的值。</p><p>The following example demonstrates collection merging:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"parent"</span> <span class="na">abstract=</span><span class="s">"true"</span> <span class="na">class=</span><span class="s">"example.ComplexObject"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"adminEmails"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;props&gt;</span>
                <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">"administrator"</span><span class="nt">&gt;</span>administrator@example.com<span class="nt">&lt;/prop&gt;</span>
                <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">"support"</span><span class="nt">&gt;</span>support@example.com<span class="nt">&lt;/prop&gt;</span>
            <span class="nt">&lt;/props&gt;</span>
        <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"child"</span> <span class="na">parent=</span><span class="s">"parent"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"adminEmails"</span><span class="nt">&gt;</span>
            <span class="c">&lt;!-- the merge is specified on the child collection definition --&gt;</span>
            <span class="nt">&lt;props</span> <span class="na">merge=</span><span class="s">"true"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">"sales"</span><span class="nt">&gt;</span>sales@example.com<span class="nt">&lt;/prop&gt;</span>
                <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">"support"</span><span class="nt">&gt;</span>support@example.co.uk<span class="nt">&lt;/prop&gt;</span>
            <span class="nt">&lt;/props&gt;</span>
        <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;beans&gt;</span>
</pre></table></code></div></div><p>结果如下：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
</pre></table></code></div></div><p>This merging behavior applies similarly to the <code class="language-plaintext highlighter-rouge">&lt;list/&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;map/&gt;</code>, and <code class="language-plaintext highlighter-rouge">&lt;set/&gt;</code> collection types.</p><h5 id="null-and-empty-string-values">Null and Empty String Values</h5><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"ExampleBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"email"</span> <span class="na">value=</span><span class="s">""</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"ExampleBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"email"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;null/&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><h5 id="xml-shortcut-with-the-p-namespace">XML Shortcut with the p-namespace</h5><p>The p-namespace lets you use the <code class="language-plaintext highlighter-rouge">bean</code> element’s attributes (instead of nested <code class="language-plaintext highlighter-rouge">&lt;property/&gt;</code> elements) to describe your property values collaborating beans, or both.</p><p>Spring支持带有名称空间的可扩展配置格式，这些名称空间基于XML Schema定义。 本章讨论的bean配置格式是在XML Schema文档中定义的。 但是，p命名空间未在XSD文件中定义，仅存在于Spring的核心中。</p><p>The following example shows two XML snippets (the first uses standard XML format and the second uses the p-namespace) that resolve to the same result:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="na">xmlns:p=</span><span class="s">"http://www.springframework.org/schema/p"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"classic"</span> <span class="na">class=</span><span class="s">"com.example.ExampleBean"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"email"</span> <span class="na">value=</span><span class="s">"someone@somewhere.com"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"p-namespace"</span> <span class="na">class=</span><span class="s">"com.example.ExampleBean"</span>
        <span class="na">p:email=</span><span class="s">"someone@somewhere.com"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><h5 id="xml-shortcut-with-the-c-namespace">XML Shortcut with the c-namespace</h5><p>Similar to the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace">XML Shortcut with the p-namespace</a>, the c-namespace, introduced in Spring 3.1, allows inlined attributes for configuring the constructor arguments rather then nested <code class="language-plaintext highlighter-rouge">constructor-arg</code> elements.</p><p>使用c:行内属性来配置构造器参数。</p><p>The following example uses the <code class="language-plaintext highlighter-rouge">c:</code> namespace to do the same thing as the from <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection">Constructor-based Dependency Injection</a>:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="na">xmlns:c=</span><span class="s">"http://www.springframework.org/schema/c"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanTwo"</span> <span class="na">class=</span><span class="s">"x.y.ThingTwo"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanThree"</span> <span class="na">class=</span><span class="s">"x.y.ThingThree"</span><span class="nt">/&gt;</span>

    <span class="c">&lt;!-- traditional declaration with optional argument names --&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanOne"</span> <span class="na">class=</span><span class="s">"x.y.ThingOne"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"thingTwo"</span> <span class="na">ref=</span><span class="s">"beanTwo"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"thingThree"</span> <span class="na">ref=</span><span class="s">"beanThree"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"email"</span> <span class="na">value=</span><span class="s">"something@somewhere.com"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

    <span class="c">&lt;!-- c-namespace declaration with argument names --&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanOne"</span> <span class="na">class=</span><span class="s">"x.y.ThingOne"</span> <span class="na">c:thingTwo-ref=</span><span class="s">"beanTwo"</span>
        <span class="na">c:thingThree-ref=</span><span class="s">"beanThree"</span> <span class="na">c:email=</span><span class="s">"something@somewhere.com"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><p>he <code class="language-plaintext highlighter-rouge">c:</code> namespace uses the same conventions as the <code class="language-plaintext highlighter-rouge">p:</code> one (a trailing <code class="language-plaintext highlighter-rouge">-ref</code> for bean references) for setting the constructor arguments by their names.</p><p>For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), you can use fallback to the argument indexes, as follows:</p><p>当构造器参数名不可用时，可使用索引代替</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- c-namespace index declaration --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanOne"</span> <span class="na">class=</span><span class="s">"x.y.ThingOne"</span> <span class="na">c:_0-ref=</span><span class="s">"beanTwo"</span> <span class="na">c:_1-ref=</span><span class="s">"beanThree"</span>
    <span class="na">c:_2=</span><span class="s">"something@somewhere.com"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><h5 id="compound-property-names">Compound Property Names</h5><p>You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not <code class="language-plaintext highlighter-rouge">null</code>. Consider the following bean definition:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"something"</span> <span class="na">class=</span><span class="s">"things.ThingOne"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"fred.bob.sammy"</span> <span class="na">value=</span><span class="s">"123"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">something</code> bean has a <code class="language-plaintext highlighter-rouge">fred</code> property, which has a <code class="language-plaintext highlighter-rouge">bob</code> property, which has a <code class="language-plaintext highlighter-rouge">sammy</code> property, and that final <code class="language-plaintext highlighter-rouge">sammy</code> property is being set to a value of <code class="language-plaintext highlighter-rouge">123</code>. In order for this to work, the <code class="language-plaintext highlighter-rouge">fred</code> property of <code class="language-plaintext highlighter-rouge">something</code> and the <code class="language-plaintext highlighter-rouge">bob</code> property of <code class="language-plaintext highlighter-rouge">fred</code> must not be <code class="language-plaintext highlighter-rouge">null</code> after the bean is constructed. Otherwise, a <code class="language-plaintext highlighter-rouge">NullPointerException</code> is thrown.</p><h4 id="using-depends-on">Using <code class="language-plaintext highlighter-rouge">depends-on</code></h4><p>用这个标签表示一个Bean是另一个Bean的属性，和<ref></ref>元素差不多。由于有时候两个Bean之间的依赖没有那么直接，那么就可以用这个了。</p><p>However, sometimes dependencies between beans are less direct. An example is when <strong>a static initializer in a class needs to be triggered</strong>, such as for database driver registration. The <code class="language-plaintext highlighter-rouge">depends-on</code> attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized.</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"beanOne"</span> <span class="na">class=</span><span class="s">"ExampleBean"</span> <span class="na">depends-on=</span><span class="s">"manager"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"manager"</span> <span class="na">class=</span><span class="s">"ManagerBean"</span> <span class="nt">/&gt;</span>
</pre></table></code></div></div><h4 id="lazy-initialized-beans">Lazy-initialized Beans</h4><p>默认情况下，ApplicationContext会在初始化过程中，就创建和配置所有单例Bean。通常来说，这种方式是令人满意的，因为这样可以及早发现配置或环境中的问题。</p><p>但是在某些情况下需要让单例Bean延迟加载。</p><p>In XML, this behavior is controlled by the <code class="language-plaintext highlighter-rouge">lazy-init</code> attribute on the <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code> element, as the following example shows:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"lazy"</span> <span class="na">class=</span><span class="s">"com.something.ExpensiveToCreateBean"</span> <span class="na">lazy-init=</span><span class="s">"true"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"not.lazy"</span> <span class="na">class=</span><span class="s">"com.something.AnotherBean"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>However, when a <strong>lazy-initialized bean is a dependency of a singleton bean that is not lazy-initialized,</strong> the <code class="language-plaintext highlighter-rouge">ApplicationContext</code> <strong>creates the lazy-initialized bean at startup</strong>, because it must satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.</p><p>You can also control lazy-initialization at the container level by using the <code class="language-plaintext highlighter-rouge">default-lazy-init</code> attribute on the <code class="language-plaintext highlighter-rouge">&lt;beans/&gt;</code> element, as the following example shows:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans</span> <span class="na">default-lazy-init=</span><span class="s">"true"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- no beans will be pre-instantiated... --&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><h4 id="autowiring-collaborators">Autowiring Collaborators</h4><p>The Spring container can autowire relationships between collaborating beans.</p><p>Autowiring has the following advantages:</p><ul><li>Autowiring can significantly <strong>reduce the need to specify properties or constructor arguments.</strong> (Other mechanisms such as a bean template <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions">discussed elsewhere in this chapter</a> are also valuable in this regard.)</li><li>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</li></ul><p>When using XML-based configuration metadata (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators">Dependency Injection</a>), you can specify the autowire mode for a bean definition with the <code class="language-plaintext highlighter-rouge">autowire</code> attribute of the <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code> element.</p><p>自动注入功能有四种模式：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210301145713825.png" alt="image-20210301145713825" /></p><p>You can autowire strongly-typed <code class="language-plaintext highlighter-rouge">Map</code> instances if the expected key type is <code class="language-plaintext highlighter-rouge">String</code></p><p>#####</p><h5 id="excluding-a-bean-from-autowiring">Excluding a Bean from Autowiring</h5><p>On a per-bean basis, you can exclude a bean from autowiring. In Spring’s XML format, set the <code class="language-plaintext highlighter-rouge">autowire-candidate</code> attribute of the <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code> element to <code class="language-plaintext highlighter-rouge">false</code></p><h4 id="method-injection">Method Injection</h4><p>当单例Bean需要与另一个单例Bean协作或非单例Bean需要与另一个非单例Bean协作时，通常可以通过将一个Bean定义为另一个Bean的属性来处理依赖性。 当bean的生命周期不同时，就会出现问题。 假设单例bean A需要使用非单例（多利）bean B，也许在A的每个方法调用上都使用。容器仅创建一次单例bean A，因此只有一次机会来设置属性。 每次需要时，容器都无法为bean A提供一个新的bean B实例。</p><p>一个解决方案是放弃某些控制反转。You can <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware">make bean A aware of the container</a> by implementing the <code class="language-plaintext highlighter-rouge">ApplicationContextAware</code> interface, and by <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-client">making a <code class="language-plaintext highlighter-rouge">getBean("B")</code> call to the container</a> ask for (a typically new) bean B instance every time bean A needs it.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// a class that uses a stateful Command-style class to perform some processing</span>
<span class="kn">package</span> <span class="nn">fiona.apple</span><span class="o">;</span>

<span class="c1">// Spring-API imports</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.BeansException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContextAware</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CommandManager</span> <span class="kd">implements</span> <span class="nc">ApplicationContextAware</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">process</span><span class="o">(</span><span class="nc">Map</span> <span class="n">commandState</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// grab a new instance of the appropriate Command</span>
        <span class="nc">Command</span> <span class="n">command</span> <span class="o">=</span> <span class="n">createCommand</span><span class="o">();</span>
        <span class="c1">// set the state on the (hopefully brand new) Command instance</span>
        <span class="n">command</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="n">commandState</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">command</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="nc">Command</span> <span class="nf">createCommand</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// notice the Spring API dependency!</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"command"</span><span class="o">,</span> <span class="nc">Command</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setApplicationContext</span><span class="o">(</span>
            <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC container, lets you handle this use case cleanly.</p><p>上面的解决方案不够优雅，因为业务代码与Spring 框架产生了耦合。</p><h5 id="lookup-method-injection">Lookup Method Injection</h5><p>查找方法注入是容器重写容器管理的Bean上的方法并返回容器中另一个命名Bean的查找结果的能力。</p><p>The Spring Framework implements this method injection by using bytecode generation from the <strong>CGLIB library</strong> to dynamically generate a subclass that overrides the method.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">fiona.apple</span><span class="o">;</span>

<span class="c1">// no more Spring imports!</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">CommandManager</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">process</span><span class="o">(</span><span class="nc">Object</span> <span class="n">commandState</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// grab a new instance of the appropriate Command interface</span>
        <span class="nc">Command</span> <span class="n">command</span> <span class="o">=</span> <span class="n">createCommand</span><span class="o">();</span>
        <span class="c1">// set the state on the (hopefully brand new) Command instance</span>
        <span class="n">command</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="n">commandState</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">command</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// okay... but where is the implementation of this method?</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="nc">Command</span> <span class="nf">createCommand</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>In the client class that contains the method to be injected (the <code class="language-plaintext highlighter-rouge">CommandManager</code> in this case), the method to be injected requires a signature of the following form:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;public</span><span class="err">|protected</span><span class="nt">&gt;</span> [abstract] <span class="nt">&lt;return-type&gt;</span> theMethodName(no-arguments);
</pre></table></code></div></div><p>XML方式配置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"myCommand"</span> <span class="na">class=</span><span class="s">"fiona.apple.AsyncCommand"</span> <span class="na">scope=</span><span class="s">"prototype"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- inject dependencies here as required --&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="c">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"commandManager"</span> <span class="na">class=</span><span class="s">"fiona.apple.CommandManager"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;lookup-method</span> <span class="na">name=</span><span class="s">"createCommand"</span> <span class="na">bean=</span><span class="s">"myCommand"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>Alternatively, within the annotation-based component model, you can declare a lookup method through the <code class="language-plaintext highlighter-rouge">@Lookup</code> annotation, as the following example shows:</p><p>注解方式配置：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">CommandManager</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">process</span><span class="o">(</span><span class="nc">Object</span> <span class="n">commandState</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Command</span> <span class="n">command</span> <span class="o">=</span> <span class="n">createCommand</span><span class="o">();</span>
        <span class="n">command</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="n">commandState</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">command</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Lookup</span><span class="o">(</span><span class="s">"myCommand"</span><span class="o">)</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="nc">Command</span> <span class="nf">createCommand</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>The bean identified as <code class="language-plaintext highlighter-rouge">commandManager</code> calls its own <code class="language-plaintext highlighter-rouge">createCommand()</code> method whenever it needs a new instance of the <code class="language-plaintext highlighter-rouge">myCommand</code> bean. You must be careful to deploy the <code class="language-plaintext highlighter-rouge">myCommand</code> bean as a prototype if that is actually what is needed. If it is a <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton">singleton</a>, the same instance of the <code class="language-plaintext highlighter-rouge">myCommand</code> bean is returned each time.</p><h5 id="arbitrary-method-replacement">Arbitrary Method Replacement</h5><h3 id="bean-scopes">Bean Scopes</h3><p>You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition <strong>but also control the scope of the objects created from a particular bean definition.</strong></p><p>Spring框架支持6种范围：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210301153408900.png" alt="image-20210301153408900" /></p><p>As of Spring 3.0, a thread scope is available but is not registered by default. For more information, see the documentation for <a href="https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/context/support/SimpleThreadScope.html"><code class="language-plaintext highlighter-rouge">SimpleThreadScope</code></a>. For instructions on how to register this or any other custom scope, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-custom-using">Using a Custom Scope</a>.</p><h4 id="the-singleton-scope">The Singleton Scope</h4><p>容器仅仅管理一个singleton bean的共享实例，并且所有对该Bean的请求都将返回这一个Bean实例。</p><p>when you define a bean definition and it is scoped as a singleton, the Spring IoC container <strong>creates exactly one instance of the object defined by that bean definition</strong>. This single instance is stored in a cache of such singleton beans, and all subsequent requests and references for that <strong>named bean return the cached object.</strong></p><p>The following image shows how the singleton scope works:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/singleton.png" alt="singleton" /></p><p>if you define one bean for a particular class <strong>in a single Spring container</strong>, the Spring container creates one and only one instance of the class defined by that bean definition. <strong>The singleton scope is the default scope in Spring.</strong> To define a bean as a singleton in XML, you can define a bean as shown in the following example:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"accountService"</span> <span class="na">class=</span><span class="s">"com.something.DefaultAccountService"</span><span class="nt">/&gt;</span>

<span class="c">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"accountService"</span> <span class="na">class=</span><span class="s">"com.something.DefaultAccountService"</span> <span class="na">scope=</span><span class="s">"singleton"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><h4 id="the-prototype-scope">The Prototype Scope</h4><p>为每个请求都新创建一个Bean实例。</p><p>As a rule, you should use the prototype scope for all stateful beans and the singleton scope for stateless beans.</p><p>对于有状态Bean，应该使用多例；对于无状态Bean，应该使用单例。</p><p>The following diagram illustrates the Spring prototype scope:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/prototype.png" alt="prototype" /></p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"accountService"</span> <span class="na">class=</span><span class="s">"com.something.DefaultAccountService"</span> <span class="na">scope=</span><span class="s">"prototype"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>和其他范围不同，Spring并不管理prototype bean的完整生命周期。容器instantiates, configures, and otherwise assembles 一个多例对象并交付给客户端，然后就不会有该实例的进一步记录了。因此，即使初始化生命周期回调函数的调用与scope无关，但是对于prototype类型的bean，配置的销毁生命周期回调函数不会被调用。</p><p>客户端代码必须对prototype类型对象进行清理，并释放对象持有的昂贵资源。使用自定义的bean post-processor来让Spring 容器释放prototype对象持有的资源，bean post-processor持有着该被清理的bean的引用。</p><h4 id="singleton-beans-with-prototype-bean-dependencies">Singleton Beans with Prototype-bean Dependencies</h4><p>当单例Bean的依赖中存在多例Bean，依赖的解析在实例化阶段完成。</p><p>Thus, if you dependency-inject <strong>a prototype-scoped bean into a singleton-scoped bean</strong>, a new prototype bean is instantiated and then dependency-injected into the singleton bean.</p><p>However, suppose you want the singleton-scoped bean to acquire a new instance of the prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into your singleton bean, because that injection occurs only once, when the Spring container instantiates the singleton bean and resolves and injects its dependencies. If you need a new instance of a prototype bean at runtime more than once, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection">Method Injection</a></p><p>在正常情况下，无法为单例Bean重新注入一个新的多例Bean。可以用Method Infection来解决。</p><h4 id="request-session-application-and-websocket-scopes">Request, Session, Application, and WebSocket Scopes</h4><p>The <code class="language-plaintext highlighter-rouge">request</code>, <code class="language-plaintext highlighter-rouge">session</code>, <code class="language-plaintext highlighter-rouge">application</code>, and <code class="language-plaintext highlighter-rouge">websocket</code> scopes are available only if you use a web-aware Spring <code class="language-plaintext highlighter-rouge">ApplicationContext</code> implementation (such as <code class="language-plaintext highlighter-rouge">XmlWebApplicationContext</code>). If you use these scopes with regular Spring IoC containers, such as the <code class="language-plaintext highlighter-rouge">ClassPathXmlApplicationContext</code>, an <code class="language-plaintext highlighter-rouge">IllegalStateException</code> that complains about an unknown bean scope is thrown.</p><p>这四种scope只在web-aware的容器实现中才能使用。</p><p>DispatcherServlet将HTTP请求对象绑定到服务这个请求的Thread。</p><h5 id="request-scope">Request scope</h5><p>Consider the following XML configuration for a bean definition:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"loginAction"</span> <span class="na">class=</span><span class="s">"com.something.LoginAction"</span> <span class="na">scope=</span><span class="s">"request"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>对于每个HTTP请求，Spring容器会创建一个新的LoginAction实例。</p><p>When using annotation-driven components or Java configuration, the <code class="language-plaintext highlighter-rouge">@RequestScope</code> annotation can be used to assign a component to the <code class="language-plaintext highlighter-rouge">request</code> scope. The following example shows how to do so:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">@RequestScope</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginAction</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="session-scope">Session Scope</h5><p>Consider the following XML configuration for a bean definition:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userPreferences"</span> <span class="na">class=</span><span class="s">"com.something.UserPreferences"</span> <span class="na">scope=</span><span class="s">"session"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>对于每一个HTTP Session，Spring容器创建一个新的UserPreferences实例。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">@SessionScope</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserPreferences</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="application-scope">Application Scope</h5><p>Consider the following XML configuration for a bean definition:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"appPreferences"</span> <span class="na">class=</span><span class="s">"com.something.AppPreferences"</span> <span class="na">scope=</span><span class="s">"application"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>对于整个Web应用，Spring容器创建一个新的AppPreferences对象。</p><p>这种范围与Spring单例Bean有些类似，但是有两个不同点：</p><ul><li>对于ServletContext来说，这是单例的；而Singleton范围是针对ApplicationContext，ApplicationContext对于给定的Web application可能存在多个。</li><li>Application Scope的Bean可以被作为ServletContext的一个属性访问。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">@ApplicationScope</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppPreferences</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="scoped-beans-as-dependencies">Scoped Beans as Dependencies</h5><p>If you want to inject (for example) an HTTP request-scoped bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject a proxy object that exposes the same public interface as the scoped object but that can also retrieve the real target object from the relevant scope (such as an HTTP request) and delegate method calls onto the real object.</p><p>上面这段没懂。</p><p>如果要将一个HTTP 请求范围的Bean注入到一个生存周期更长的范围Bean中，可以选择注入一个AOP代理来替代该范围Bean。也就是说，您需要注入一个代理对象，该对象公开与范围对象相同的公共接口，但也可以从相关范围（例如HTTP请求）中检索真实的目标对象，并将方法调用委托给真实的对象。</p><p>考虑下面的例子：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userPreferences"</span> <span class="na">class=</span><span class="s">"com.something.UserPreferences"</span> <span class="na">scope=</span><span class="s">"session"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userManager"</span> <span class="na">class=</span><span class="s">"com.something.UserManager"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"userPreferences"</span> <span class="na">ref=</span><span class="s">"userPreferences"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>userManager是单例的，所以在实例化时就会注入属性，所以userPreferences也会在userManager实例化时实例化。而且在userManager的生命周期中，不会再重新创建userPreferences属性，这是不符合我们的想法的。既然我们将userPreferences设置为session-scoped，那么我们就希望能够为每个session都创建一个userPreferences实例，上面这种配置方式会让userManager在整个容器中都复用一个userPreferences，即使是对不同的session。</p><p>解决方法就是通过AOP动态代理的方式。容器创建一个对象，其暴露了与userPreferences相同的公共接口，然后容器将这个对象注入到userManager中。当UserManager调用userPreferences的方法时，实际上是在调用代理对象的方法。这个代理对象就会从HTTP session中取出真正的UserPreferences对象，并调用其方法。这样就保证了一个单例对象能够对每个HTTP session都能正确地使用userPreferences属性。</p><p>配置方式也很简单：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userPreferences"</span> <span class="na">class=</span><span class="s">"com.something.UserPreferences"</span> <span class="na">scope=</span><span class="s">"session"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;aop:scoped-proxy/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userManager"</span> <span class="na">class=</span><span class="s">"com.something.UserManager"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"userPreferences"</span> <span class="na">ref=</span><span class="s">"userPreferences"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p><strong>Choosing the Type of Proxy to Create</strong></p><p>对于前文的AOP代理，容器默认使用的是CGLIB-based动态代理。</p><blockquote><p>CGLIB proxies intercept only <strong>public method calls</strong>! Do not call non-public methods on such a proxy. They are not delegated to the actual scoped target object.</p></blockquote><p>可以通过配置来修改动态代理的方式。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userPreferences"</span> <span class="na">class=</span><span class="s">"com.stuff.DefaultUserPreferences"</span> <span class="na">scope=</span><span class="s">"session"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;aop:scoped-proxy</span> <span class="na">proxy-target-class=</span><span class="s">"false"</span><span class="nt">/&gt;</span><span class="c">&lt;!--JDK 基于接口的动态代理--&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userManager"</span> <span class="na">class=</span><span class="s">"com.stuff.UserManager"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"userPreferences"</span> <span class="na">ref=</span><span class="s">"userPreferences"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><h3 id="customizing-the-nature-of-a-bean">Customizing the Nature of a Bean</h3><p>The Spring Framework provides a number of interfaces you can use to customize the nature of a bean. This section groups them as follows:</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle">Lifecycle Callbacks</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware"><code class="language-plaintext highlighter-rouge">ApplicationContextAware</code> and <code class="language-plaintext highlighter-rouge">BeanNameAware</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aware-list">Other <code class="language-plaintext highlighter-rouge">Aware</code> Interfaces</a></li></ul><h4 id="lifecycle-callbacks">Lifecycle Callbacks</h4><p>To interact with the container’s management of the bean lifecycle, you can implement the Spring <code class="language-plaintext highlighter-rouge">InitializingBean</code> and <code class="language-plaintext highlighter-rouge">DisposableBean</code> interfaces.</p><p>容器会为前者调用afterPropertiesSet方法，并为后者调用destroy方法，以使Bean在初始化和销毁的时候执行某些操作。</p><p>Spring框架内部使用BeanPostProcessor实现来处理任何回调接口并调用合适的方法。如果想要定制特征或者其他生命周期相关的行为，Spring不会默认提供，需要自己实现BeanPostProcessor。</p><p>In addition to the initialization and destruction callbacks, Spring-managed objects may also implement the <code class="language-plaintext highlighter-rouge">Lifecycle</code> interface so that those objects can participate in the startup and shutdown process, as driven by the container’s own lifecycle. 该接口包括以下方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="initialization-callbacks">Initialization Callbacks</h5><p>org.springframework.beans.factory.InitializingBean接口让Bean可以在容器处理完所有必要的属性后进行一些初始化工作。The <code class="language-plaintext highlighter-rouge">InitializingBean</code> interface specifies a single method:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
</pre></table></code></div></div><p>官方并不建议使用这个接口，因为会造成与Spring框架的耦合。作为替代，官方建议使用@PostConstruct注解或者指定一个POJO的初始化方法。</p><p>在基于XML的配置方式中，使用init-method属性来制定一个初始化方法名（无参数无返回值）。</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"exampleInitBean"</span> <span class="na">class=</span><span class="s">"examples.ExampleBean"</span> <span class="na">init-method=</span><span class="s">"init"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleBean</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do some initialization work</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在基于Java代码的配置方式中，使用@Bean注解的initMethod属性来配置。</p><p>上面两种方式与以下的方式作用相同：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"exampleInitBean"</span> <span class="na">class=</span><span class="s">"examples.AnotherExampleBean"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnotherExampleBean</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do some initialization work</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>However, the first of the two preceding examples does not couple the code to Spring.</p><h5 id="destruction-callbacks">Destruction Callbacks</h5><p>org.springframework.beans.factory.DisposableBean让Bean在销毁时进行一些操作。The <code class="language-plaintext highlighter-rouge">DisposableBean</code> interface specifies a single method:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
</pre></table></code></div></div><p>同理，也不建议使用以上方式，建议以下两种方式：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"exampleInitBean"</span> <span class="na">class=</span><span class="s">"examples.ExampleBean"</span> <span class="na">destroy-method=</span><span class="s">"cleanup"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleBean</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cleanup</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do some destruction work (like releasing pooled connections)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>使用@Bean的destroyMethod属性。</p><p>You can assign the <code class="language-plaintext highlighter-rouge">destroy-method</code> attribute of a <code class="language-plaintext highlighter-rouge">&lt;bean&gt;</code> element a special <code class="language-plaintext highlighter-rouge">(inferred)</code> value, which instructs Spring to automatically detect a public <code class="language-plaintext highlighter-rouge">close</code> or <code class="language-plaintext highlighter-rouge">shutdown</code> method on the specific bean class. (Any class that implements <code class="language-plaintext highlighter-rouge">java.lang.AutoCloseable</code> or <code class="language-plaintext highlighter-rouge">java.io.Closeable</code> would therefore match.) You can also set this special <code class="language-plaintext highlighter-rouge">(inferred)</code> value on the <code class="language-plaintext highlighter-rouge">default-destroy-method</code> attribute of a <code class="language-plaintext highlighter-rouge">&lt;beans&gt;</code> element to apply this behavior to an entire set of beans (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-default-init-destroy-methods">Default Initialization and Destroy Methods</a>). Note that this is the default behavior with Java configuration.</p><p>Suppose that your initialization callback methods are named <code class="language-plaintext highlighter-rouge">init()</code> and your destroy callback methods are named <code class="language-plaintext highlighter-rouge">destroy()</code>. Your class then resembles the class in the following example:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultBlogService</span> <span class="kd">implements</span> <span class="nc">BlogService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">BlogDao</span> <span class="n">blogDao</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setBlogDao</span><span class="o">(</span><span class="nc">BlogDao</span> <span class="n">blogDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">blogDao</span> <span class="o">=</span> <span class="n">blogDao</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// this is (unsurprisingly) the initialization callback method</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">blogDao</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"The [blogDao] property must be set."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nt">&lt;beans</span> <span class="na">default-init-method=</span><span class="s">"init"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"blogService"</span> <span class="na">class=</span><span class="s">"com.something.DefaultBlogService"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"blogDao"</span> <span class="na">ref=</span><span class="s">"blogDao"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><p>You can configure destroy method callbacks similarly (in XML, that is) by using the <code class="language-plaintext highlighter-rouge">default-destroy-method</code> attribute on the top-level <code class="language-plaintext highlighter-rouge">&lt;beans/&gt;</code> element.</p><h5 id="combining-lifecycle-mechanisms">Combining Lifecycle Mechanisms</h5><p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior:</p><ul><li>The <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean"><code class="language-plaintext highlighter-rouge">InitializingBean</code></a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean"><code class="language-plaintext highlighter-rouge">DisposableBean</code></a> callback interfaces</li><li>Custom <code class="language-plaintext highlighter-rouge">init()</code> and <code class="language-plaintext highlighter-rouge">destroy()</code> methods</li><li>The <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations"><code class="language-plaintext highlighter-rouge">@PostConstruct</code> and <code class="language-plaintext highlighter-rouge">@PreDestroy</code> annotations</a>. You can combine these mechanisms to control a given bean.</li></ul><p>If <strong>multiple lifecycle mechanisms are configured for a bean and each mechanism is configured with a different method name, then each configured method is run in the order listed after this note</strong>. However, if <strong>the same method name is configured</strong> — for example, <code class="language-plaintext highlighter-rouge">init()</code> for an initialization method — for more than one of these lifecycle mechanisms, that <strong>method is run once,</strong> as explained in the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-default-init-destroy-methods">preceding section</a>.</p><p>Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:调用顺序如下：</p><ol><li>Methods annotated with <code class="language-plaintext highlighter-rouge">@PostConstruct</code></li><li><code class="language-plaintext highlighter-rouge">afterPropertiesSet()</code> as defined by the <code class="language-plaintext highlighter-rouge">InitializingBean</code> callback interface</li><li>A custom configured <code class="language-plaintext highlighter-rouge">init()</code> method</li></ol><p>Destroy methods are called in the same order:</p><ol><li>Methods annotated with <code class="language-plaintext highlighter-rouge">@PreDestroy</code></li><li><code class="language-plaintext highlighter-rouge">destroy()</code> as defined by the <code class="language-plaintext highlighter-rouge">DisposableBean</code> callback interface</li><li>A custom configured <code class="language-plaintext highlighter-rouge">destroy()</code> method</li></ol><h4 id="applicationcontextaware-and-beannameaware"><code class="language-plaintext highlighter-rouge">ApplicationContextAware</code> and <code class="language-plaintext highlighter-rouge">BeanNameAware</code></h4><p>当ApplicationContext创建一个实现了ApplicationContextAware接口的实例bean后，该实例拥有此ApplicationContext的引用。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ApplicationContextAware</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">setApplicationContext</span><span class="o">(</span><span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>该实例就能通过ApplicationContext接口（或者子类）来操作ApplicationContext了。一种用途就是调用其他bean。</p><p>However, in general, you should avoid it, because it couples the code to Spring and does not follow the Inversion of Control style, where collaborators are provided to beans as properties.</p><p>Other methods of the <code class="language-plaintext highlighter-rouge">ApplicationContext</code> provide access to file resources, publishing application events, and accessing a <code class="language-plaintext highlighter-rouge">MessageSource</code></p><p>Autowiring是获取ApplicationContext的替代解决方案。</p><p>自动装配是获得对ApplicationContext的引用的另一种方法。 传统的构造函数和byType自动装配模式（如“自动装配协作器”中所述）可以分别为构造函数参数或setter方法参数提供ApplicationContext类型的依赖项。 要获得更大的灵活性，包括能够自动连接字段和使用多个参数方法，请使用基于注释的自动装配功能。 如果这样做，则将ApplicationContext自动连接到需要使用ApplicationContext类型的字段，构造函数参数或方法参数中（如果有问题的字段，构造函数或方法带有@Autowired批注）。</p><p>当ApplicationContext创建一个实现org.springframework.beans.factory.BeanNameAware接口的类时，该类将获得对其关联对象定义中定义的名称的引用。</p><p>The following listing shows the definition of the BeanNameAware interface:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BeanNameAware</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">setBeanName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>The callback is invoked <strong>after population of normal bean properties</strong> but <strong>before an initialization callback</strong> such as <code class="language-plaintext highlighter-rouge">InitializingBean</code>, <code class="language-plaintext highlighter-rouge">afterPropertiesSet</code>, or a custom init-method.</p><h4 id="other-aware-interfaces">Other <code class="language-plaintext highlighter-rouge">Aware</code> Interfaces</h4><p>The following table summarizes the most important <code class="language-plaintext highlighter-rouge">Aware</code> interfaces:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name<th style="text-align: center">Injected Dependency<th style="text-align: center">Explained in…<tbody><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">ApplicationContextAware</code><td style="text-align: center">Declaring <code class="language-plaintext highlighter-rouge">ApplicationContext</code>.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware"><code class="language-plaintext highlighter-rouge">ApplicationContextAware</code> and <code class="language-plaintext highlighter-rouge">BeanNameAware</code></a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">ApplicationEventPublisherAware</code><td style="text-align: center">Event publisher of the enclosing <code class="language-plaintext highlighter-rouge">ApplicationContext</code>.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction">Additional Capabilities of the <code class="language-plaintext highlighter-rouge">ApplicationContext</code></a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">BeanClassLoaderAware</code><td style="text-align: center">Class loader used to load the bean classes.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class">Instantiating Beans</a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">BeanFactoryAware</code><td style="text-align: center">Declaring <code class="language-plaintext highlighter-rouge">BeanFactory</code>.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware"><code class="language-plaintext highlighter-rouge">ApplicationContextAware</code> and <code class="language-plaintext highlighter-rouge">BeanNameAware</code></a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">BeanNameAware</code><td style="text-align: center">Name of the declaring bean.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware"><code class="language-plaintext highlighter-rouge">ApplicationContextAware</code> and <code class="language-plaintext highlighter-rouge">BeanNameAware</code></a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">LoadTimeWeaverAware</code><td style="text-align: center">Defined weaver for processing class definition at load time.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">MessageSourceAware</code><td style="text-align: center">Configured strategy for resolving messages (with support for parametrization and internationalization).<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction">Additional Capabilities of the <code class="language-plaintext highlighter-rouge">ApplicationContext</code></a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">NotificationPublisherAware</code><td style="text-align: center">Spring JMX notification publisher.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx-notifications">Notifications</a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">ResourceLoaderAware</code><td style="text-align: center">Configured loader for low-level access to resources.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources">Resources</a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">ServletConfigAware</code><td style="text-align: center">Current <code class="language-plaintext highlighter-rouge">ServletConfig</code> the container runs in. Valid only in a web-aware Spring <code class="language-plaintext highlighter-rouge">ApplicationContext</code>.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc">Spring MVC</a><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">ServletContextAware</code><td style="text-align: center">Current <code class="language-plaintext highlighter-rouge">ServletContext</code> the container runs in. Valid only in a web-aware Spring <code class="language-plaintext highlighter-rouge">ApplicationContext</code>.<td style="text-align: center"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc">Spring MVC</a></table></div><p>Note again that using these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As a result, we recommend them for infrastructure beans that require programmatic access to the container.</p><h3 id="bean-definition-inheritance">Bean Definition Inheritance</h3><p>Bean Definition包含了许多配置信息，比如构造器参数、属性值，还包含了容器相关的信息，比如初始化方法、一个静态工厂方法名等。子Bean Definition从父Bean Definition继承了以上配置数据，并允许根据需要覆盖或者添加一些值。使用父bean和子bean定义可以节省很多输入。 实际上，这是一种模板模式。</p><p>When you use XML-based configuration metadata, you can indicate a child bean definition by using the <code class="language-plaintext highlighter-rouge">parent</code> attribute, specifying the parent bean as the value of this attribute. The following example shows how to do so:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"inheritedTestBean"</span> <span class="na">abstract=</span><span class="s">"true"</span>
        <span class="na">class=</span><span class="s">"org.springframework.beans.TestBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"name"</span> <span class="na">value=</span><span class="s">"parent"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"age"</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"inheritsWithDifferentClass"</span>
        <span class="na">class=</span><span class="s">"org.springframework.beans.DerivedTestBean"</span>
        <span class="na">parent=</span><span class="s">"inheritedTestBean"</span> <span class="na">init-method=</span><span class="s">"initialize"</span><span class="nt">&gt;</span>  
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"name"</span> <span class="na">value=</span><span class="s">"override"</span><span class="nt">/&gt;</span>
    <span class="c">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>子bean definition从父bean definition继承范围，构造函数参数值，属性值和方法替代，并可以选择添加新值。 您指定的任何范围，初始化方法，destroy方法或“静态”工厂方法设置都会覆盖相应的父设置。</p><p>其余设置始终从子定义中获取：依赖项，自动装配模式，依赖项检查，单例和惰性初始化。</p><p>The preceding example explicitly marks the parent bean definition as abstract by using the <code class="language-plaintext highlighter-rouge">abstract</code> attribute. If the <strong>parent definition does not specify a class</strong>, explicitly marking the parent bean definition as <code class="language-plaintext highlighter-rouge">abstract</code> is required, as the following example shows:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"inheritedTestBeanWithoutClass"</span> <span class="na">abstract=</span><span class="s">"true"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"name"</span> <span class="na">value=</span><span class="s">"parent"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"age"</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"inheritsWithClass"</span> <span class="na">class=</span><span class="s">"org.springframework.beans.DerivedTestBean"</span>
        <span class="na">parent=</span><span class="s">"inheritedTestBeanWithoutClass"</span> <span class="na">init-method=</span><span class="s">"initialize"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"name"</span> <span class="na">value=</span><span class="s">"override"</span><span class="nt">/&gt;</span>
    <span class="c">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as <code class="language-plaintext highlighter-rouge">abstract</code>. When a definition is <code class="language-plaintext highlighter-rouge">abstract</code>, <strong>it is usable only as a pure template bean definition that serves as a parent definition for child definitions.</strong></p><p>Trying to use such an <code class="language-plaintext highlighter-rouge">abstract</code> parent bean on its own, by referring to it as a ref property of another bean or doing an explicit <code class="language-plaintext highlighter-rouge">getBean()</code> call with the parent bean ID returns an error. Similarly, the container’s internal <code class="language-plaintext highlighter-rouge">preInstantiateSingletons()</code> method ignores bean definitions that are defined as abstract.</p><blockquote><p><code class="language-plaintext highlighter-rouge">ApplicationContext</code> pre-instantiates all singletons by default. Therefore, it is important (at least for singleton beans) that if you have a (parent) bean definition which you intend to use only as a template, and this definition specifies a class, you must make sure to set the <em>abstract</em> attribute to <em>true</em>, otherwise the application context will actually (attempt to) pre-instantiate the <code class="language-plaintext highlighter-rouge">abstract</code> bean.</p></blockquote><h3 id="container-extension-points">Container Extension Points</h3><h4 id="customizing-beans-by-using-a-beanpostprocessor">Customizing Beans by Using a <code class="language-plaintext highlighter-rouge">BeanPostProcessor</code></h4><p>如果想要在Spring容器完成实例化、配置以及初始化Bean后执行一些定制化逻辑，可以plug in 一些BeanPostProcessor实现。</p><blockquote><p><code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> instances operate on bean (or object) instances. That is, the Spring IoC container instantiates a bean instance and then <code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> instances do their work.</p><p><code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> instances are scoped per-container.</p></blockquote><p>ApplicationContext会自动检测配置元数据中实现了BeanPostProcessor接口的所有Bean，ApplicationContext会提前把这些Bean注册为post-processors，这样就可以在实例化其他Bean时使用这些post-processors。</p><p>除了自动检测BeanPostProcessor，还可以调用ConfigurableBeanFactory的addBeanPostProcessor方法手动添加。</p><p>Note also that <code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> instances registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.</p><blockquote><p>All <code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> instances and beans that they directly reference are instantiated on startup, as part of the special startup phase of the <code class="language-plaintext highlighter-rouge">ApplicationContext</code>. Next, all <code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> instances are registered in a sorted fashion and applied to all further beans in the container.</p><p>因为AOP自动代理是作为BeanPostProcessor本身实现的，所以BeanPostProcessor实例或它们直接引用的bean都不适合进行自动代理，因此，没有织入的切面。</p></blockquote><p>The following listing shows the custom <code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> implementation class definition:</p><p>创建自定义的BeanPostProcessor：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InstantiationTracingBeanPostProcessor</span> <span class="kd">implements</span> <span class="nc">BeanPostProcessor</span> <span class="o">{</span>

    <span class="c1">// simply return the instantiated bean as-is</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">postProcessBeforeInitialization</span><span class="o">(</span><span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">bean</span><span class="o">;</span> <span class="c1">// we could potentially return any object reference here...</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">postProcessAfterInitialization</span><span class="o">(</span><span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"' created : "</span> <span class="o">+</span> <span class="n">bean</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">bean</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在bean.xml中配置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.yucaihuang.beanpostprocessor.InstantiationTracingBeanPostProcessor"</span><span class="nt">/&gt;</span>
</pre></table></code></div></div><p>在容器实例化Bean时，就会调用postProcessAfterInitialization方法了。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">ClassPathXmlApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"bean.xml"</span><span class="o">);</span>
        <span class="nc">SimpleMovieLister</span> <span class="n">simpleMovieLister</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"simpleMovieLister"</span><span class="o">,</span> <span class="nc">SimpleMovieLister</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">simpleMovieLister</span><span class="o">);</span>
</pre></table></code></div></div><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Bean <span class="s1">'simpleMovieLister'</span> created : com.yucaihuang.domain.SimpleMovieLister@293a5bf6
Bean <span class="s1">'movieFinder'</span> created : com.yucaihuang.domain.MovieFinder@6aeb35e6
</pre></table></code></div></div><h4 id="customizing-configuration-metadata-with-a-beanfactorypostprocessor">Customizing Configuration Metadata with a <code class="language-plaintext highlighter-rouge">BeanFactoryPostProcessor</code></h4><p>此接口与BeanPostProcessor非常相似，只不过BeanFactoryPostProcessor处理的是configuration metadata。也就是说，Spring容器允许BeanFactoryPostProcessor读取配置数据，并在容器实例化Bean之前加以修改。</p><p>您可以使用PropertySourcesPlaceholderConfigurer来通过使用标准Java属性格式将来自Bean定义的属性值外部化到一个单独的文件中。 这样做使部署应用程序的人员可以自定义特定于环境的属性，例如数据库URL和密码，而无需为修改容器的主要XML定义文件而复杂或冒风险。</p><p>Consider the following XML-based configuration metadata fragment, where a <code class="language-plaintext highlighter-rouge">DataSource</code> with placeholder values is defined:</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c">&lt;!--在Spring2.5后，可以使用以下配置替代
&lt;context:property-placeholder location="classpath:com/something/jdbc.properties"/&gt;
--&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"locations"</span> <span class="na">value=</span><span class="s">"classpath:com/something/jdbc.properties"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource"</span> <span class="na">destroy-method=</span><span class="s">"close"</span>
        <span class="na">class=</span><span class="s">"org.apache.commons.dbcp.BasicDataSource"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"driverClassName"</span> <span class="na">value=</span><span class="s">"${jdbc.driverClassName}"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"url"</span> <span class="na">value=</span><span class="s">"${jdbc.url}"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"username"</span> <span class="na">value=</span><span class="s">"${jdbc.username}"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"password"</span> <span class="na">value=</span><span class="s">"${jdbc.password}"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><h4 id="customizing-instantiation-logic-with-a-factorybean">Customizing Instantiation Logic with a <code class="language-plaintext highlighter-rouge">FactoryBean</code></h4><p>The <code class="language-plaintext highlighter-rouge">FactoryBean</code> interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own <code class="language-plaintext highlighter-rouge">FactoryBean</code>, write the complex initialization inside that class, and then plug your custom <code class="language-plaintext highlighter-rouge">FactoryBean</code> into the container.</p><h3 id="annotation-based-container-configuration">Annotation-based Container Configuration</h3><p>Annotation injection is performed before XML injection. Thus, <strong>the XML configuration overrides the annotations for properties wired through both approaches.</strong></p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c">&lt;!--开启注解的支持--&gt;</span>
<span class="nt">&lt;context:annotation-config/&gt;</span>
</pre></table></code></div></div><blockquote><p><code class="language-plaintext highlighter-rouge">&lt;context:annotation-config/&gt;</code> only looks for annotations on beans in the same application context in which it is defined. This means that, if you put <code class="language-plaintext highlighter-rouge">&lt;context:annotation-config/&gt;</code> in a <code class="language-plaintext highlighter-rouge">WebApplicationContext</code> for a <code class="language-plaintext highlighter-rouge">DispatcherServlet</code>, it only checks for <code class="language-plaintext highlighter-rouge">@Autowired</code> beans in your controllers, and not your services.</p></blockquote><h4 id="required">@Required</h4><p>The <code class="language-plaintext highlighter-rouge">@Required</code> annotation applies to bean property setter methods, as in the following example:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleMovieLister</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">MovieFinder</span> <span class="n">movieFinder</span><span class="o">;</span>

    <span class="nd">@Required</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMovieFinder</span><span class="o">(</span><span class="nc">MovieFinder</span> <span class="n">movieFinder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">movieFinder</span> <span class="o">=</span> <span class="n">movieFinder</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>此注解指示必须在配置时通过bean定义中的显式属性值或通过自动装配来填充受影响的bean属性。</p><blockquote><p>Spring5.1开始，此注解被弃用了。</p></blockquote><h4 id="autowired">@Autowired</h4><p>You can apply the <code class="language-plaintext highlighter-rouge">@Autowired</code> annotation to constructors, as the following example shows:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MovieRecommender</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CustomerPreferenceDao</span> <span class="n">customerPreferenceDao</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">MovieRecommender</span><span class="o">(</span><span class="nc">CustomerPreferenceDao</span> <span class="n">customerPreferenceDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">customerPreferenceDao</span> <span class="o">=</span> <span class="n">customerPreferenceDao</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p>从Spring4.3开始，如果目标Bean只有一个构造器时，就无需使用Autowired，如果有多个构造器，那么还是需要使用Autowired来告诉容器默认该使用哪个。</p></blockquote><p>You can also apply the <code class="language-plaintext highlighter-rouge">@Autowired</code> annotation to <em>traditional</em> setter methods, as the following example shows:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleMovieLister</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">MovieFinder</span> <span class="n">movieFinder</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMovieFinder</span><span class="o">(</span><span class="nc">MovieFinder</span> <span class="n">movieFinder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">movieFinder</span> <span class="o">=</span> <span class="n">movieFinder</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>You can also apply the annotation to methods with arbitrary names and multiple arguments, as the following example shows:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MovieRecommender</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">MovieCatalog</span> <span class="n">movieCatalog</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">CustomerPreferenceDao</span> <span class="n">customerPreferenceDao</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="nc">MovieCatalog</span> <span class="n">movieCatalog</span><span class="o">,</span>
            <span class="nc">CustomerPreferenceDao</span> <span class="n">customerPreferenceDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">movieCatalog</span> <span class="o">=</span> <span class="n">movieCatalog</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">customerPreferenceDao</span> <span class="o">=</span> <span class="n">customerPreferenceDao</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>You can apply <code class="language-plaintext highlighter-rouge">@Autowired</code> to fields as well and even mix it with constructors, as the following example shows:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MovieRecommender</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CustomerPreferenceDao</span> <span class="n">customerPreferenceDao</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MovieCatalog</span> <span class="n">movieCatalog</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">MovieRecommender</span><span class="o">(</span><span class="nc">CustomerPreferenceDao</span> <span class="n">customerPreferenceDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">customerPreferenceDao</span> <span class="o">=</span> <span class="n">customerPreferenceDao</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="fine-tuning-annotation-based-autowiring-with-primary">Fine-tuning Annotation-based Autowiring with <code class="language-plaintext highlighter-rouge">@Primary</code></h4><p>Because autowiring by type may lead to multiple candidates, it is often necessary to have more control over the selection process.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MovieConfiguration</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Primary</span>
    <span class="kd">public</span> <span class="nc">MovieCatalog</span> <span class="nf">firstMovieCatalog</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MovieCatalog</span> <span class="nf">secondMovieCatalog</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="fine-tuning-annotation-based-autowiring-with-qualifiers">Fine-tuning Annotation-based Autowiring with Qualifiers</h4><p>When you need more control over the selection process, you can use Spring’s <code class="language-plaintext highlighter-rouge">@Qualifier</code> annotation.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MovieRecommender</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"main"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">MovieCatalog</span> <span class="n">movieCatalog</span><span class="o">;</span>

    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"example.SimpleMovieCatalog"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;qualifier</span> <span class="na">value=</span><span class="s">"main"</span><span class="nt">/&gt;</span> 

        <span class="c">&lt;!-- inject any dependencies required by this bean --&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"example.SimpleMovieCatalog"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;qualifier</span> <span class="na">value=</span><span class="s">"action"</span><span class="nt">/&gt;</span> 
</pre></table></code></div></div><p>For a fallback match, <strong>the bean name is considered a default qualifier value.</strong></p><h4 id="injection-with-resource">Injection with <code class="language-plaintext highlighter-rouge">@Resource</code></h4><p>Spring支持在setter方法上使用@Resource注解</p><p><code class="language-plaintext highlighter-rouge">@Resource</code> takes a name attribute. By default, Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in the following example:</p><p>If no name is explicitly specified, the default name is derived from the field name or setter method. In case of a field, it takes the field name. In case of a setter method, it takes the bean property name.</p><h4 id="using-value">Using <code class="language-plaintext highlighter-rouge">@Value</code></h4><p><code class="language-plaintext highlighter-rouge">@Value</code> is typically used to inject externalized properties:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MovieRecommender</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">catalog</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MovieRecommender</span><span class="o">(</span><span class="nd">@Value</span><span class="o">(</span><span class="s">"${catalog.name}"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">catalog</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">catalog</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="nd">@PropertySource</span><span class="o">(</span><span class="s">"classpath:application.properties"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span> <span class="o">}</span>
</pre></table></code></div></div><div class="language-properties highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="py">catalog.name</span><span class="p">=</span><span class="s">MovieCatalog</span>
</pre></table></code></div></div><p>在上述例子中，属性catalog会被赋值为MovieCatalog。</p><h3 id="classpath-scanning-and-managed-components">Classpath Scanning and Managed Components</h3><h4 id="component-and-further-stereotype-annotations"><code class="language-plaintext highlighter-rouge">@Component</code> and Further Stereotype Annotations</h4><p>@Component注解是@Service、@Controller、@Repository的通用构造型，使用@Service、@Controller、@Repository来注释组件类能够使这些类更容易通过工具进行处理，以及这些注释是切入点的理想目标。在Spring框架的未来版本中，也可能带有其他语义。</p><h4 id="using-meta-annotations-and-composed-annotations">Using Meta-annotations and Composed Annotations</h4><h4 id="automatically-detecting-classes-and-registering-bean-definitions">Automatically Detecting Classes and Registering Bean Definitions</h4><p><code class="language-plaintext highlighter-rouge">@ComponentScan("org.example")</code>).</p><p>或者：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="na">xmlns:context=</span><span class="s">"http://www.springframework.org/schema/context"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"org.example"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><p>Furthermore, the <code class="language-plaintext highlighter-rouge">AutowiredAnnotationBeanPostProcessor</code> and <code class="language-plaintext highlighter-rouge">CommonAnnotationBeanPostProcessor</code> are both implicitly included when you use the component-scan element. That means that the two components are autodetected and wired together — all without any bean configuration metadata provided in XML.</p><h4 id="using-filters-to-customize-scanning">Using Filters to Customize Scanning</h4><p>略</p><h4 id="defining-bean-metadata-within-components">Defining Bean Metadata within Components</h4><p>略</p><h3 id="using-jsr-330-standard-annotations">Using JSR 330 Standard Annotations</h3><p>略</p><h3 id="java-based-container-configuration">Java-based Container Configuration</h3><h4 id="basic-concepts-bean-and-configuration">Basic Concepts: <code class="language-plaintext highlighter-rouge">@Bean</code> and <code class="language-plaintext highlighter-rouge">@Configuration</code></h4><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">myService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyServiceImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>当@Bean注解的方法声明在未加@Configuration注解的类中时，这些方法就会被以”lite”模式处理。</p><p>在@Component或甚至在简单的旧类中声明的Bean方法被认为是“精简版”，其中包含类具有不同的主要用途，而@Bean方法在那里具有某种优势。</p><h4 id="instantiating-the-spring-container-by-using-annotationconfigapplicationcontext">Instantiating the Spring Container by Using <code class="language-plaintext highlighter-rouge">AnnotationConfigApplicationContext</code></h4><p>When <code class="language-plaintext highlighter-rouge">@Configuration</code> classes are provided as input, the <code class="language-plaintext highlighter-rouge">@Configuration</code> class itself is registered as a bean definition and all declared <code class="language-plaintext highlighter-rouge">@Bean</code> methods within the class are also registered as bean definitions.</p><h5 id="simple-construction">Simple Construction</h5><p>与ClassPathXmlApplicationContext以xml文件为输入相似，我们可以用@Configuration注解的类作为AnnotationConfigApplicationContext的输入来注册Bean Definition。如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nc">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">myService</span><span class="o">.</span><span class="na">doStuff</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>而且任何@Component或JSR-330注解的类都能作为其输入。</p><h5 id="building-the-container-programmatically-by-using-registerclass">Building the Container Programmatically by Using <code class="language-plaintext highlighter-rouge">register(Class&lt;?&gt;…)</code></h5><p>用register方法来注册Bean。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">AnnotationConfigApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">();</span>
    <span class="n">ctx</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">OtherConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">ctx</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="nc">AdditionalConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">ctx</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
    <span class="nc">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">myService</span><span class="o">.</span><span class="na">doStuff</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="enabling-component-scanning-with-scanstring">Enabling Component Scanning with <code class="language-plaintext highlighter-rouge">scan(String…)</code></h5><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">AnnotationConfigApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">();</span>
    <span class="n">ctx</span><span class="o">.</span><span class="na">scan</span><span class="o">(</span><span class="s">"com.acme"</span><span class="o">);</span><span class="c1">//手动扫描包</span>
    <span class="n">ctx</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
    <span class="nc">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="support-for-web-applications-with-annotationconfigwebapplicationcontext">Support for Web Applications with <code class="language-plaintext highlighter-rouge">AnnotationConfigWebApplicationContext</code></h5><h4 id="using-the-bean-annotation">Using the <code class="language-plaintext highlighter-rouge">@Bean</code> Annotation</h4><p><code class="language-plaintext highlighter-rouge">@Bean</code> is a method-level annotation and a direct analog of the XML <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code> element. The annotation supports some of the attributes offered by <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code>, such as: * <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean">init-method</a> * <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean">destroy-method</a> * <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire">autowiring</a> * <code class="language-plaintext highlighter-rouge">name</code>.</p><h5 id="声明一个bean">声明一个Bean</h5><p>在方法上添加@Bean注解来注册一个Bean，默认的Bean名是方法名。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">TransferServiceImpl</span> <span class="nf">transferService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">TransferServiceImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>当然返回值也可以是接口:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">TransferService</span> <span class="nf">transferService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">TransferServiceImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>但是，这将高级类型预测的可见性限制为指定的接口类型（TransferService）。 然后，使用仅一次容器已知的完整类型（TransferServiceImpl），就可以实例化受影响的单例bean。 非惰性单例bean根据其声明顺序实例化，因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试按非声明类型进行匹配</p><p><code class="language-plaintext highlighter-rouge">@Autowired TransferServiceImpl</code>, which resolves only once the <code class="language-plaintext highlighter-rouge">transferService</code> bean has been instantiated.</p><p>对于实现多个接口的组件或由其实现类型潜在引用的组件，声明可能的最具体的返回类型（至少与引用您的bean的注入点所要求的具体类型一样）更为安全。</p><h5 id="bean-dependencies">Bean Dependencies</h5><p>方法参数即属性依赖。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">TransferService</span> <span class="nf">transferService</span><span class="o">(</span><span class="nc">AccountRepository</span> <span class="n">accountRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">TransferServiceImpl</span><span class="o">(</span><span class="n">accountRepository</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="receiving-lifecycle-callbacks">Receiving Lifecycle Callbacks</h5><p>接收生命周期回调。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanOne</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// initialization logic</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanTwo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cleanup</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// destruction logic</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="n">initMethod</span> <span class="o">=</span> <span class="s">"init"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">BeanOne</span> <span class="nf">beanOne</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BeanOne</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="n">destroyMethod</span> <span class="o">=</span> <span class="s">"cleanup"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">BeanTwo</span> <span class="nf">beanTwo</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BeanTwo</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Using the</strong> <code class="language-plaintext highlighter-rouge">@Scope</code> <strong>Annotation</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyConfiguration</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Encryptor</span> <span class="nf">encryptor</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="using-the-configuration-annotation">Using the <code class="language-plaintext highlighter-rouge">@Configuration</code> annotation</h4><h5 id="injecting-inter-bean-dependencies">Injecting Inter-bean Dependencies</h5><p>通过构造器参数注入依赖：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">BeanOne</span> <span class="nf">beanOne</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BeanOne</span><span class="o">(</span><span class="n">beanTwo</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">BeanTwo</span> <span class="nf">beanTwo</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BeanTwo</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="lookup-method-injection-1">Lookup Method Injection</h5><p>在单例Bean中使用多例Bean的依赖，需要使用此方法解决。</p><p>在基于XML的配置中，将创建新多例Bean的方法声明为抽象方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="o">&lt;</span><span class="kd">public</span><span class="o">|</span><span class="kd">protected</span><span class="o">&gt;</span> <span class="o">[</span><span class="kd">abstract</span><span class="o">]</span> <span class="o">&lt;</span><span class="k">return</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;</span> <span class="nf">theMethodName</span><span class="o">(</span><span class="n">no</span><span class="o">-</span><span class="n">arguments</span><span class="o">);</span>
</pre></table></code></div></div><p>然后在配置文件中配置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"myCommand"</span> <span class="na">class=</span><span class="s">"fiona.apple.AsyncCommand"</span> <span class="na">scope=</span><span class="s">"prototype"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- inject dependencies here as required --&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="c">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"commandManager"</span> <span class="na">class=</span><span class="s">"fiona.apple.CommandManager"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;lookup-method</span> <span class="na">name=</span><span class="s">"createCommand"</span> <span class="na">bean=</span><span class="s">"myCommand"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</pre></table></code></div></div><p>这样就能在调用createCommand方法的时候重新创建一个新的Bean：myCommand。</p><p>用注解方式更为简洁：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">CommandManager</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">process</span><span class="o">(</span><span class="nc">Object</span> <span class="n">commandState</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Command</span> <span class="n">command</span> <span class="o">=</span> <span class="n">createCommand</span><span class="o">();</span>
        <span class="n">command</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="n">commandState</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">command</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Lookup</span><span class="o">(</span><span class="s">"myCommand"</span><span class="o">)</span><span class="c1">//用来替换配置文件中的&lt;lookup-method&gt;属性</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="nc">Command</span> <span class="nf">createCommand</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="further-information-about-how-java-based-configuration-works-internally">Further Information About How Java-based Configuration Works Internally</h5><p>看以下例子：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ClientService</span> <span class="nf">clientService1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ClientServiceImpl</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClientServiceImpl</span><span class="o">();</span>
        <span class="n">clientService</span><span class="o">.</span><span class="na">setClientDao</span><span class="o">(</span><span class="n">clientDao</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ClientService</span> <span class="nf">clientService2</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ClientServiceImpl</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClientServiceImpl</span><span class="o">();</span>
        <span class="n">clientService</span><span class="o">.</span><span class="na">setClientDao</span><span class="o">(</span><span class="n">clientDao</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ClientDao</span> <span class="nf">clientDao</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ClientDaoImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>你可能会认为在注入clientService1和clientService2的时候调用了两次clientDao()方法，那么肯定注入了两个不同的ClientDaoImpl实例。但是在Spring中，Bean默认的Scope是单例的，并且用了@Configuration注解的类在启动时都使用了CGLIB进行了子类化。在子类中，子方法在调用父类方法进行Bean实例化之前，会首先检查Spring容器中是否存在任何缓存的Bean。所以，这两个service实例注入的是同一个ClientDaoImpl实例。</p><p>The behavior could be different according to the scope of your bean. We are talking about singletons here.</p><p>由于CGLIB在启动时会动态添加属性，所以这里有一些限制：</p><ul><li>configuration类必须不是final的。</li><li>如果不想要CGLIB带来的限制，那么就在无@Configuration注解的类中定义Bean。</li></ul><h3 id="environment-abstraction">Environment Abstraction</h3><p>Environment接口是集成在容器中的抽象，它对应用程序环境的两个关键方面进行建模：profiles和properties。</p><p>Environment接口对profiles的作用就是决定目前哪个profiles是active的，决定哪些profiles应该默认被active。</p><p>Environment接口与properties有关的作用是为用户提供方便的服务界面，用于配置属性源并从中解析属性。</p><h3 id="beanfactory-or-applicationcontext"><code class="language-plaintext highlighter-rouge">BeanFactory</code> or <code class="language-plaintext highlighter-rouge">ApplicationContext</code>?</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210306100749625.png" alt="image-20210306100749625" /></p><p>ApplicationContext 和 BeanFactory 另一个最大的不同之处在于：ApplicationContext会利用 Java 反射机制自动识别出配置文件中定义的 BeanPostProcessor、 InstantiationAwareBeanPostProcessor 和 BeanFactoryPostProcessor，并自动将它们注册到应用上下文中；而后者需要在代码中通过手工调用 addBeanPostProcessor()方法进行注册。这也是为什么在应用开发时，我们普遍使用 ApplicationContext 而很少使用 BeanFactory 的原因之一。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/javaweb/'>Javaweb</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring IOC技术文档阅读笔记 - 银杏叶&url=www.yucaihuang.com/posts/spring-iocdoc-read/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring IOC技术文档阅读笔记 - 银杏叶&u=www.yucaihuang.com/posts/spring-iocdoc-read/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring IOC技术文档阅读笔记 - 银杏叶&url=www.yucaihuang.com/posts/spring-iocdoc-read/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/web-url-with-chinese-string/">URL包含中文，请求资源404</a></li><li><a href="/posts/web-docker_2/">Docker：入门</a></li><li><a href="/posts/web-docker_1/">Docker：概述</a></li><li><a href="/posts/web-delete-system-python-in-centos/">centOS误删系统自带python</a></li><li><a href="/posts/springboot-starter-id/">创建自定义Springboot starter</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-circular-dependency/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 1 <i class="unloaded">2021-03-01T16:25:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring循环依赖及其解决方案</h3><div class="text-muted small"><p> 问题描述 在Spring的文档中，这样描述循环依赖问题： If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario. For example: Class A requires an instance of c...</p></div></div></a></div><div class="card"> <a href="/posts/spring-ioc-analyze/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 6 <i class="unloaded">2021-03-06T13:14:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring IOC原理总结</h3><div class="text-muted small"><p> 转载自：https://zhuanlan.zhihu.com/p/29344811 Spring容器高层视图 Spring 启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。 Bean缓存池：HashMap实现 IOC容器介绍 Spr...</p></div></div></a></div><div class="card"> <a href="/posts/design-pattern/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > May 6 <i class="unloaded">2021-05-06T18:49:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式的六大原则 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象放在程序设计的高层，并保持稳定，程序的细节变化由底层...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-circular-dependency/" class="btn btn-outline-primary"><p>Spring循环依赖及其解决方案</p></a> <a href="/posts/spring-ioc-analyze/" class="btn btn-outline-primary"><p>Spring IOC原理总结</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-1</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
