<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Leetcode题解 | 黄玉才的博客</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Leetcode题解" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><meta property="og:description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><link rel="canonical" href="www.yucaihuang.com/posts/leetcode-solutions/" /><meta property="og:url" content="www.yucaihuang.com/posts/leetcode-solutions/" /><meta property="og:site_name" content="黄玉才的博客" /><meta property="og:image" content="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-09-23T08:29:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" /><meta property="twitter:title" content="Leetcode题解" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"image":"https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/posts/leetcode-solutions/"},"url":"www.yucaihuang.com/posts/leetcode-solutions/","author":{"@type":"Person","name":"Kol Huang"},"description":"A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.","dateModified":"2020-09-23T08:29:00+08:00","datePublished":"2020-09-23T08:29:00+08:00","headline":"Leetcode题解","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">黄玉才的博客</a></div><div class="site-subtitle font-italic">Focus!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Leetcode题解</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Leetcode题解</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 23, 2020, 8:29 AM +0800" > Sep 23, 2020 <i class="unloaded">2020-09-23T08:29:00+08:00</i> </span> by <span class="author"> Kol Huang</div><div> Updated <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Jan 23, 2021, 2:09 PM +0800" > Jan 23 <i class="unloaded">2021-01-23T14:09:08+08:00</i> </span></div></div><div class="post-content"> <img src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_cover.jpg" class="post-preview-img"><p><span id="jump1"></span></p><h2 id="1两数之和">1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">给定</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">15</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">9</span>

<span class="n">因为</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">所以返回</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><p>哈希法</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hashTable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">//遍历每个nums[i]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//查询哈希表中是否存在target-nums[i]项，如果存在就找到了答案</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hashTable</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">hashTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]),</span><span class="n">i</span><span class="o">};</span>
            <span class="o">}</span>
            <span class="c1">//否则将nums[i]放入哈希表</span>
            <span class="n">hashTable</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="2两数相加">2.两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">6</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">7</span> <span class="o">-&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">8</span>
<span class="n">原因</span><span class="err">：</span><span class="mi">342</span> <span class="o">+</span> <span class="mi">465</span> <span class="o">=</span> <span class="mi">807</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
    
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="c1">//当两个链表都还没到尾部时，按位相加</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
            <span class="c1">//有进位</span>
            <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">){</span>
                <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">-</span> <span class="mi">10</span><span class="o">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//无进位</span>
                <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//当l1还有剩余的位时</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
            <span class="c1">//如果有进位</span>
            <span class="k">if</span><span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">){</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
                    <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="c1">//如果没有进位</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//同样处理l2</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">){</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
                    <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//最后还有一个进位，就增加一个节点，值为1</span>
        <span class="k">if</span><span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>


    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>官方的简便写法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">carry</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="3无重复字符的最长子串">3.无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"abcabcbb"</span>
<span class="nl">输出:</span> <span class="mi">3</span> 
<span class="nl">解释:</span> <span class="n">因为无重复字符的最长子串是</span> <span class="s">"abc"</span><span class="err">，</span><span class="n">所以其长度为</span> <span class="mi">3</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"bbbbb"</span>
<span class="nl">输出:</span> <span class="mi">1</span>
<span class="nl">解释:</span> <span class="n">因为无重复字符的最长子串是</span> <span class="s">"b"</span><span class="err">，</span><span class="n">所以其长度为</span> <span class="mi">1</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"pwwkew"</span>
<span class="nl">输出:</span> <span class="mi">3</span>
<span class="nl">解释:</span> <span class="n">因为无重复字符的最长子串是</span> <span class="s">"wke"</span><span class="err">，</span><span class="n">所以其长度为</span> <span class="mi">3</span><span class="err">。</span>
     <span class="n">请注意</span><span class="err">，</span><span class="n">你的答案必须是</span> <span class="n">子串</span> <span class="n">的长度</span><span class="err">，</span><span class="s">"pwke"</span> <span class="n">是一个子序列</span><span class="err">，</span><span class="n">不是子串</span><span class="err">。</span>
</pre></table></code></div></div><p>滑动窗口：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">n</span><span class="o">;</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//滑动窗口，探索每个以start开始的子串</span>
        <span class="c1">//假设我们找到了当前最长的某个无重复子串：</span>
        <span class="c1">//即[start,end)都没有重复字符，那么[start+1,end)肯定也是无重复字符的</span>
        <span class="c1">//所以可以在此基础上继续增大end，探索更长的无重复子串</span>
        <span class="k">while</span><span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">end</span><span class="o">])){</span>
                <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">end</span><span class="o">]);</span>
                <span class="n">end</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">]);</span>
            <span class="n">start</span><span class="o">++;</span>
            
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c">//用map定义一个set</span>
    <span class="n">set</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="n">start</span> <span class="o">:=</span> <span class="m">0</span>
    <span class="n">end</span> <span class="o">:=</span> <span class="m">0</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="m">0</span>
    
    <span class="k">for</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
        <span class="c">//判断set中有没有s[end]这个元素</span>
        <span class="k">for</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">set</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="c">//把s[end]放入set</span>
            <span class="n">set</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span><span class="o">++</span>
            <span class="n">end</span><span class="o">++</span>
        <span class="p">}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="c">//从set中删除s[start]</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">])</span>
        <span class="n">start</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><span id="jump4"></span></p><h2 id="4-寻找两个正序数组的中位数">4. 寻找两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p><p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mf">2.00000</span>
<span class="n">解释</span><span class="err">：</span><span class="n">合并数组</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="err">，</span><span class="n">中位数</span> <span class="mi">2</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mf">2.50000</span>
<span class="n">解释</span><span class="err">：</span><span class="n">合并数组</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="err">，</span><span class="n">中位数</span> <span class="o">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">=</span> <span class="mf">2.5</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mf">0.00000</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mf">1.00000</span>
</pre></table></code></div></div><p>示例 5：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[]</span>
<span class="n">输出</span><span class="err">：</span><span class="mf">2.00000</span>
</pre></table></code></div></div><p>提示：</p><ul><li>nums1.length == m</li><li>nums2.length == n</li><li>0 &lt;= m &lt;= 1000</li><li>0 &lt;= n &lt;= 1000</li><li>1 &lt;= m + n &lt;= 2000</li><li>-106 &lt;= nums1[i], nums2[i] &lt;= 106</li></ul><p>用二分才能达到这样的时间复杂度</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="cm">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
* 这里的 "/" 表示整除
* nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
* nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
* 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个
* 这样 pivot 本身最大也只能是第 k-1 小的元素
* 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
* 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
* 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
*/</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>
        <span class="c1">//总长为奇数</span>
        <span class="k">if</span><span class="o">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="c1">//中位数在合并数组中的的索引为mid</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">//找到两个数组中第mid+1小的数就是中位数</span>
            <span class="k">return</span> <span class="nf">getKthElement</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid1</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">mid2</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">getKthElement</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="n">mid1</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">getKthElement</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="n">mid2</span><span class="o">+</span><span class="mi">1</span><span class="o">))*</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//找到两个数组中第k小的数</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getKthElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">cur1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cur2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>


        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="c1">//超出数组边界了，就从另外一个数组中找第k小的数直接返回</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur1</span> <span class="o">==</span> <span class="n">m</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">nums2</span><span class="o">[</span><span class="n">cur2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur2</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">nums1</span><span class="o">[</span><span class="n">cur1</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="c1">//两个都没有超出边界，且k == 1就从两个数组的当前首索引找出一个最小值返回</span>
            <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">cur1</span><span class="o">],</span> <span class="n">nums2</span><span class="o">[</span><span class="n">cur2</span><span class="o">]);</span>
            <span class="o">}</span>

            <span class="c1">//k &gt; 1，且两个数组都未越界</span>
            <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">//本来是比较 nums1[k/2-1]和nums2[k/2-1]的值的</span>
            <span class="c1">//但是k/2-1可能会越界，如果越界了就取数组最后一个元素比较</span>
            <span class="kt">int</span> <span class="n">newCur1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">cur1</span> <span class="o">+</span> <span class="n">half</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">newCur2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">cur2</span> <span class="o">+</span> <span class="n">half</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

            <span class="k">if</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">newCur1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">newCur2</span><span class="o">]){</span>
                <span class="c1">//更新k，排除了多少个数，就把k缩小多少</span>
                <span class="n">k</span> <span class="o">-=</span> <span class="o">(</span><span class="n">newCur1</span> <span class="o">-</span> <span class="n">cur1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">cur1</span> <span class="o">=</span> <span class="n">newCur1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">k</span> <span class="o">-=</span> <span class="o">(</span><span class="n">newCur2</span> <span class="o">-</span> <span class="n">cur2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">cur2</span> <span class="o">=</span> <span class="n">newCur2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump5"></span></p><h2 id="5最长回文子串">5.最长回文子串</h2><p><a href="HYCBlog/posts/algorithm-manacher">点这里跳转</a></p><p><span id="jump6"></span></p><h2 id="6-z-字形变换">6. Z 字形变换</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="no">P</span>   <span class="no">A</span>   <span class="no">H</span>   <span class="no">N</span>
<span class="no">A</span> <span class="no">P</span> <span class="no">L</span> <span class="no">S</span> <span class="no">I</span> <span class="no">I</span> <span class="no">G</span>
<span class="no">Y</span>   <span class="no">I</span>   <span class="no">R</span>
</pre></table></code></div></div><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">convert</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//n == 1的时候，直接返回S即可</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">StringBuilder</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span><span class="c1">//从上往下填</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">break</span><span class="o">;</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">++));</span>
                <span class="o">}</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span><span class="c1">//从下往右上方填</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">break</span><span class="o">;</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">++));</span>
                <span class="o">}</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump7"></span></p><h2 id="7-整数反转">7. 整数反转</h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rev</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//逐渐地从尾部弹出一个数字</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">//pop是有可能为负数的</span>
            <span class="kt">int</span> <span class="n">pop</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
            <span class="c1">//抹除最后一位</span>
            <span class="n">x</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
            <span class="c1">//如果当前rev &gt; INTMAX / 10，那么说明rev * 10 + pop肯定溢出</span>
            <span class="c1">//如果rev == INTMAX/10呢？那就判断弹出来的这个个位数是否大于7</span>
            <span class="c1">//同理如果当前rev &lt; INTMIN / 10，那么说明rev * 10 + pop肯定溢出</span>
            <span class="c1">//如果rev == INTMIN/10呢？那就判断弹出来的这个个位数是否小于-8</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rev</span> <span class="o">&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">||</span> <span class="o">(</span><span class="n">rev</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">pop</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="o">))</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rev</span> <span class="o">&lt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">||</span> <span class="o">(</span><span class="n">rev</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">pop</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">8</span><span class="o">))</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="n">rev</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">pop</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">rev</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump8"></span></p><h2 id="8-字符串转换整数-atoi">8. 字符串转换整数 (atoi)</h2><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><p>读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">myAtoi</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">//遇到数字和符号了没？</span>
    <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
      <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
      <span class="c1">//去除多余前导空格</span>
      <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">&amp;&amp;!</span><span class="n">flag</span><span class="o">){</span>
      <span class="o">}</span>
      <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">&amp;&amp;!</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">&amp;&amp;!</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">else</span> <span class="nf">if</span><span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
          <span class="n">cur</span><span class="o">++;</span>
          <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
          <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>

      <span class="o">}</span>
      <span class="n">cur</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">//判断是否溢出</span>
    <span class="nc">String</span> <span class="n">base</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">"2147483648"</span> <span class="o">:</span> <span class="s">"2147483647"</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span><span class="n">base</span><span class="o">)){</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">())</span> <span class="o">*</span> <span class="n">sign</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
  <span class="o">}</span>


  <span class="kt">boolean</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s2</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr2</span><span class="o">))</span>   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr2</span><span class="o">))</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
      <span class="n">ptr1</span><span class="o">++;</span>
      <span class="n">ptr2</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump9"></span></p><h2 id="9-回文数">9. 回文数</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p><p>当然可以转换为字符串再处理，直接用数字处理速度更快</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//判断回文数</span>
        <span class="c1">//负数肯定不是回文数</span>
        <span class="c1">//如果数字最后一位为0，那么这个数字只能是0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">)</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">reveretedNum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">reveretedNum</span><span class="o">){</span><span class="c1">//这个判断是关键！</span>
            <span class="n">reveretedNum</span> <span class="o">=</span> <span class="n">reveretedNum</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
            <span class="n">x</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">reveretedNum</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">reveretedNum</span><span class="o">/</span><span class="mi">10</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump10"></span></p><h2 id="10-正则表达式匹配">10. 正则表达式匹配</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>’.’ 匹配任意单个字符 ‘*’ 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"aa"</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="s">"a"</span> <span class="n">无法匹配</span> <span class="s">"aa"</span> <span class="n">整个字符串</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"aa"</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"a*"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">因为</span> <span class="sc">'*'</span> <span class="n">代表可以匹配零个或多个前面的那一个元素</span><span class="o">,</span> <span class="n">在这里前面的元素就是</span> <span class="sc">'a'</span><span class="err">。</span><span class="n">因此</span><span class="err">，</span><span class="n">字符串</span> <span class="s">"aa"</span> <span class="n">可被视为</span> <span class="sc">'a'</span> <span class="n">重复了一次</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"ab"</span> <span class="n">p</span> <span class="o">=</span> <span class="s">".*"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="s">".*"</span> <span class="n">表示可匹配零个或多个</span><span class="err">（</span><span class="sc">'*'</span><span class="err">）</span><span class="n">任意字符</span><span class="err">（</span><span class="sc">'.'</span><span class="err">）。</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"aab"</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"c*a*b"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">因为</span> <span class="sc">'*'</span> <span class="n">表示零个或多个</span><span class="err">，</span><span class="n">这里</span> <span class="sc">'c'</span> <span class="n">为</span> <span class="mi">0</span> <span class="n">个</span><span class="o">,</span> <span class="sc">'a'</span> <span class="n">被重复一次</span><span class="err">。</span><span class="n">因此可以匹配字符串</span> <span class="s">"aab"</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 5：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"mississippi"</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"mis*is*p*."</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 20</li><li>0 &lt;= p.length &lt;= 30</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//dp[i][j]标识s的前i个字符和p的前j个字符是否能够匹配</span>
        <span class="c1">//  1.如果p的第j个字符是一个小写字母，那么必须在s中匹配一个相同的小写字母</span>
        <span class="c1">//  2.如果p的第j个字符是'.'，那么p[j]一定匹配成功s中的任意一个小写字母</span>
        <span class="c1">//  3.如果p的第j个字符是'*'，那么就可以对p的第j-1个字符匹配任意次</span>
        <span class="c1">//      字母+*的组合在匹配过程中本质只有两种情况：</span>
                    <span class="c1">//1.匹配s末尾的一个字符，将该字符丢掉，而该组合还可以继续匹配</span>
                    <span class="c1">//2.不匹配字符，将该组合扔掉，不再进行匹配</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="c1">//空配空</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//边界情况：dp[0]表示用p匹配空字符串的情况</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'*'</span><span class="o">)</span>    <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="c1">//如果当前p字符是'*'</span>
                <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'*'</span><span class="o">){</span>
                    <span class="c1">//如果s[i] = p[j-1]</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">matches</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)){</span>
                        <span class="c1">//不妨把类似 'a*', 'b*' 等的当成整体看待。</span>
                        <span class="c1">//可以只把 i 前移一位，而不丢弃 'b*', 转化为子问题 dp[i-1][j]</span>
                        <span class="c1">//反过来说，就是只要dp[i-1][j]成立，那么dp[i][j]就成立，因为s[i] = p[j-1]</span>
                        <span class="c1">//当然也可以丢弃'a*'这样的整体，就需要把 j 前移2位，转化为子问题dp[i][j-2]</span>
                        <span class="c1">//反过来说，就是只要dp[i][j-2]成立，那么dp[i][j]就成立，忽略'a*'整体</span>
                        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="c1">//s[i] != p[j-1]只能选择不匹配</span>
                        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">matches</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)){</span>
                        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        
    <span class="o">}</span>

    <span class="c1">//判断对应位置上的字符是否匹配</span>
    <span class="kt">boolean</span> <span class="nf">matches</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'.'</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump11"></span></p><h2 id="11盛最多水的容器">11.盛最多水的容器</h2><p>给你 n 个非负整数 <code class="language-plaintext highlighter-rouge">a1，a2，...，an</code>，每个数代表坐标中的一个点 <code class="language-plaintext highlighter-rouge">(i, ai)</code> 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 <code class="language-plaintext highlighter-rouge">(i, ai)</code> 和<code class="language-plaintext highlighter-rouge"> (i, 0)</code> 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p>暴力枚举+剪枝优化：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max_l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max_h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">max_h</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max_h</span><span class="o">,</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">*</span> <span class="n">max_h</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//剪枝（1）</span>
            <span class="k">if</span><span class="o">(</span><span class="n">max_l</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="kt">int</span> <span class="n">max_r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                    <span class="c1">//剪枝（2）</span>
                    <span class="k">if</span><span class="o">((</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">*</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="o">){</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="c1">//剪枝（3）</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">max_r</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">height</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">*</span> <span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">));</span>
                        <span class="n">max_r</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="o">}</span>
                    
                <span class="o">}</span>
                <span class="n">max_l</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>双指针内缩短板，一句话理解：只有不断克服短板，才能增加成功的可能性</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//双指针指向两端，不断将短板内缩，因为只有将短板内缩才有可能把短板增大，容量才有可能增大</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">l</span><span class="o">],</span><span class="n">height</span><span class="o">[</span><span class="n">r</span><span class="o">])</span> <span class="o">*</span> <span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                <span class="n">r</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">l</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>golang</p><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">maxArea</span><span class="p">(</span><span class="n">height</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="m">0</span>

    <span class="n">l</span><span class="p">,</span><span class="n">r</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">r</span><span class="o">--</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">l</span><span class="o">++</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>


<span class="k">func</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">min</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><span id="jump12"></span></p><h2 id="12-整数转罗马数字">12. 整数转罗马数字</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">字符</span>          <span class="n">数值</span>
<span class="no">I</span>             <span class="mi">1</span>
<span class="no">V</span>             <span class="mi">5</span>
<span class="no">X</span>             <span class="mi">10</span>
<span class="no">L</span>             <span class="mi">50</span>
<span class="no">C</span>             <span class="mi">100</span>
<span class="no">D</span>             <span class="mi">500</span>
<span class="no">M</span>             <span class="mi">1000</span>
</pre></table></code></div></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">intToRoman</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中，并且按照阿拉伯数字的大小降序排列</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1000</span><span class="o">,</span> <span class="mi">900</span><span class="o">,</span> <span class="mi">500</span><span class="o">,</span> <span class="mi">400</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">90</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">romans</span> <span class="o">=</span> <span class="o">{</span><span class="s">"M"</span><span class="o">,</span> <span class="s">"CM"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"CD"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"XC"</span><span class="o">,</span> <span class="s">"L"</span><span class="o">,</span> <span class="s">"XL"</span><span class="o">,</span> <span class="s">"X"</span><span class="o">,</span> <span class="s">"IX"</span><span class="o">,</span> <span class="s">"V"</span><span class="o">,</span> <span class="s">"IV"</span><span class="o">,</span> <span class="s">"I"</span><span class="o">};</span>

    <span class="c1">//贪心取最大的先分配</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
      <span class="c1">//比如300，它大于100，那么回先取个C，再连续取2个C</span>
      <span class="c1">//如果是400，那么会在CD的地方就被卡住，直接取了CD</span>
      <span class="k">while</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="o">){</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">romans</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="n">num</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
      <span class="o">}</span>
      <span class="n">idx</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump13"></span></p><h2 id="13-罗马数字转整数">13. 罗马数字转整数</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">romanToInt</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//能用来做减法的有 I、X、C</span>
    <span class="c1">//那么在遇到这些字符的时候，检查一下后一个字符是啥，</span>
    <span class="c1">//如果是重复字符就继续读取</span>
    <span class="c1">//如果不是重复字符，那就说明是做减法了</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1000</span><span class="o">,</span> <span class="mi">900</span><span class="o">,</span> <span class="mi">500</span><span class="o">,</span> <span class="mi">400</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">90</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">romans</span> <span class="o">=</span> <span class="o">{</span><span class="s">"M"</span><span class="o">,</span> <span class="s">"CM"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"CD"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"XC"</span><span class="o">,</span> <span class="s">"L"</span><span class="o">,</span> <span class="s">"XL"</span><span class="o">,</span> <span class="s">"X"</span><span class="o">,</span> <span class="s">"IX"</span><span class="o">,</span> <span class="s">"V"</span><span class="o">,</span> <span class="s">"IV"</span><span class="o">,</span> <span class="s">"I"</span><span class="o">};</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">romans</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
      <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">romans</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
      <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
      <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'C'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'X'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'I'</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
          <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
          <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
            <span class="n">i</span><span class="o">++;</span>
            <span class="k">continue</span><span class="o">;</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">+</span><span class="s">""</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump14"></span></p><h2 id="14-最长公共前缀">14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 ““。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">strs</span> <span class="o">=</span> <span class="o">[</span><span class="s">"flower"</span><span class="o">,</span><span class="s">"flow"</span><span class="o">,</span><span class="s">"flight"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"fl"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= strs.length &lt;= 200</li><li>0 &lt;= strs[i].length &lt;= 200</li><li>strs[i] 仅由小写英文字母组成</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">strs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">String</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">prefix</span> <span class="o">=</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">prefix</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="nc">String</span> <span class="n">str1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">str2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">str1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">index</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">str1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump15"></span></p><h2 id="15三数之和">15.三数之和</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">给定数组</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">]</span><span class="err">，</span>

<span class="n">满足要求的三元组集合为</span><span class="err">：</span>
<span class="o">[</span>
  <span class="o">[-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
  <span class="o">[-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">threeSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span>  <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//剪枝：nums[i]太小了，即使最大的数字*2加起来，都没办法使其大于等于0</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]*</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">continue</span><span class="o">;</span>
            <span class="c1">//剪枝：nums[i]大于0了，后面再加肯定都是大于0的</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="c1">//去重</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>   <span class="k">continue</span><span class="o">;</span>
            <span class="c1">//双指针</span>
            <span class="c1">//让指针right指向最右端</span>
            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">l</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]&gt;</span><span class="mi">0</span><span class="o">)</span>   <span class="k">break</span><span class="o">;</span>
                <span class="c1">//去重</span>
                <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>   <span class="k">continue</span><span class="o">;</span>
                <span class="c1">//右指针向左移动,缩小nums[l] + nums[r]</span>
                <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                    <span class="o">--</span><span class="n">r</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//指针重合了，那么l继续增加也没有意义了，因为最小的nums[l] + nums[r]都大于target了</span>
                <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="o">){</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]);</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]);</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump16"></span></p><h2 id="16最接近三数之和">16.最接近三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>示例：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
</pre></table></code></div></div><p>提示：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>3 &lt;= nums.length &lt;= 10^3
-10^3 &lt;= nums[i] &lt;= 10^3
-10^4 &lt;= target &lt;= 10^4
</pre></table></code></div></div><h3 id="暴力解法">暴力解法</h3><p>固定一个数，遍历其他两个数，找出<code class="language-plaintext highlighter-rouge">target - sum</code>最小的<code class="language-plaintext highlighter-rouge">sum</code>作为结果。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
                    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]);</span>
                    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">),</span> <span class="n">min</span><span class="o">);</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">min</span><span class="o">){</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">x</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">y</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">z</span><span class="o">];</span>
</pre></table></code></div></div><h3 id="排序双指针">排序+双指针</h3><p>我们首先考虑枚举第一个元素 a，对于剩下的两个元素 b 和 c，我们希望它们的和最接近 <code class="language-plaintext highlighter-rouge">target - a</code>。对于 b 和 c，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，借助双指针，我们就可以对枚举的过程进行优化。</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>如果a+b+c≥target，那么就将 p_c向左移动一个位置；
如果a+b+c&lt;target，那么就将 p_b向右移动一个位置。
</pre></table></code></div></div><p>####</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre>        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">best</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
          <span class="c1">//保证此次第i个数与前一个不同</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
          <span class="c1">//维护两个指针，l和r，分别代表b和c</span>
            <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
              <span class="c1">//计算当前的和</span>
                <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
              <span class="c1">//若当前的和跟target更接近，则更新距离最小值</span>
                <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">target</span><span class="o">)</span> <span class="o">&lt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">best</span> <span class="o">-</span><span class="n">target</span><span class="o">)){</span>
                    <span class="n">best</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
                <span class="o">}</span>
              <span class="c1">//移动指针l</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                    <span class="kt">int</span> <span class="n">l0</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                  <span class="c1">//保证移动后，与前一个数字不同</span>
                    <span class="k">while</span><span class="o">(</span><span class="n">l0</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">l0</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">])</span>
                        <span class="o">++</span><span class="n">l0</span><span class="o">;</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">l0</span><span class="o">;</span>
                <span class="o">}</span>
              <span class="c1">//移动指针r</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                    <span class="kt">int</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
                  <span class="c1">//保证移动后，与前一个数字不同</span>
                    <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">r0</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">])</span>
                        <span class="o">--</span><span class="n">r0</span><span class="o">;</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">r0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">best</span><span class="o">;</span>
</pre></table></code></div></div><p><span id="jump17"></span></p><h2 id="17电话号码的字母组合">17.电话号码的字母组合</h2><p>给定一个仅包含数字 <code class="language-plaintext highlighter-rouge">2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"23"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"ad"</span><span class="o">,</span> <span class="s">"ae"</span><span class="o">,</span> <span class="s">"af"</span><span class="o">,</span> <span class="s">"bd"</span><span class="o">,</span> <span class="s">"be"</span><span class="o">,</span> <span class="s">"bf"</span><span class="o">,</span> <span class="s">"cd"</span><span class="o">,</span> <span class="s">"ce"</span><span class="o">,</span> <span class="s">"cf"</span><span class="o">].</span>
</pre></table></code></div></div><p>说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h3 id="回溯法">回溯法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">letterCombinations</span><span class="o">(</span><span class="nc">String</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//先建立数字和字符串的映射关系</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="s">"def"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="s">"ghi"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="s">"jkl"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span><span class="s">"mno"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span><span class="s">"pqrs"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span><span class="s">"tuv"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span><span class="s">"wxyz"</span><span class="o">);</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">digits</span><span class="o">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//取出第一个数字对应的字符串</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="c1">//以字符串的第i位字符作为根节点，开始回溯</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="n">backtrack</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">StringBuffer</span> <span class="n">sb</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="o">){</span>
        <span class="c1">//若已访问到根节点，就将这个字符串记录到res中</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
            <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="c1">//回溯</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                <span class="n">backtrack</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump18"></span></p><h2 id="18四数之和">18.四数之和</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">给定数组</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="err">，</span><span class="n">和</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="err">。</span>

<span class="n">满足要求的四元组集合为</span><span class="err">：</span>
<span class="o">[</span>
  <span class="o">[-</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
  <span class="o">[-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span>
  <span class="o">[-</span><span class="mi">2</span><span class="o">,</span>  <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>回溯法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">fourSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>

        <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">4</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//去重</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span>   <span class="k">continue</span><span class="o">;</span>
            <span class="c1">//剪枝：当剩余的元素个数不满足所需个数时，返回</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">(</span><span class="mi">4</span><span class="o">-</span><span class="n">size</span><span class="o">))</span> <span class="k">return</span><span class="o">;</span>
            <span class="c1">//剪枝：当剩余所需元素都用后续最小元素来填充时，还是超过了target，就返回</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="mi">3</span><span class="o">-</span><span class="n">size</span><span class="o">)</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
            <span class="c1">//剪枝：当剩余所需元素都用后续最大元素来填充时，还是比target小时，就跳过此次添加，去添加更大的元素，期望逼近target</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="mi">3</span><span class="o">-</span><span class="n">size</span><span class="o">)</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="c1">//回溯</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">list</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>排序+双指针：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">fourSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">quadruplets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">quadruplets</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">3</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">quadruplets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]));</span>
                        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                            <span class="n">left</span><span class="o">++;</span>
                        <span class="o">}</span>
                        <span class="n">left</span><span class="o">++;</span>
                        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                            <span class="n">right</span><span class="o">--;</span>
                        <span class="o">}</span>
                        <span class="n">right</span><span class="o">--;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">left</span><span class="o">++;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">right</span><span class="o">--;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">quadruplets</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump19"></span></p><h2 id="19删除链表的倒数第n个节点">19.删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">给定一个链表:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">,</span> <span class="n">和</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span>

<span class="n">当删除了倒数第二个节点后</span><span class="err">，</span><span class="n">链表变为</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">.</span>
</pre></table></code></div></div><p>说明：</p><ul><li>给定的 n 保证是有效的。</li></ul><p>进阶：</p><ul><li>你能尝试使用一趟扫描实现吗？</li></ul><p>双指针移动，先让一个指针移动n位，再让两个指针同时移动，这样当后一个指针到头时，前一个指针就指向倒数第n个节点。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
      	<span class="c1">//用一个伪头节点降低代码复杂度</span>
        <span class="nc">ListNode</span> <span class="n">fake_head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
      	<span class="c1">//指向需要被删除节点的前一个节点</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">fake_head</span><span class="o">;</span>
      	<span class="c1">//指向需要被删除的节点</span>
        <span class="nc">ListNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
              	<span class="c1">//先让right指针移动n位</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">n</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
      	<span class="c1">//删除节点</span>
        <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      	<span class="c1">//help GC </span>
        <span class="n">left</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump20"></span></p><h2 id="20有效的括号">20.有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"()"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"()[]{}"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"(]"</span>
<span class="nl">输出:</span> <span class="kc">false</span>
</pre></table></code></div></div><p>示例 4:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"([)]"</span>
<span class="nl">输出:</span> <span class="kc">false</span>
</pre></table></code></div></div><p>示例 5:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"{[]}"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'{'</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'['</span><span class="o">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="nc">Character</span> <span class="n">c</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'('</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'}'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'{'</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'['</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()==</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump21"></span></p><h2 id="21合并两个有序链表">21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">4</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
      	<span class="c1">//直接接在后面即可</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">l2</span> <span class="o">:</span> <span class="n">l1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump22"></span></p><h2 id="22括号生成">22.括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span>
       <span class="s">"((()))"</span><span class="o">,</span>
       <span class="s">"(()())"</span><span class="o">,</span>
       <span class="s">"(())()"</span><span class="o">,</span>
       <span class="s">"()(())"</span><span class="o">,</span>
       <span class="s">"()()()"</span>
     <span class="o">]</span>
</pre></table></code></div></div><p>回溯法，判断是排左括号还是右括号，当左右括号都排完了，就记录。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(),</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
        <span class="c1">//左右括号都排完了</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//左右括号数量相等，只能排左括号</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'('</span><span class="o">);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
          	<span class="c1">//回溯</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="c1">//左括号排完了，只能排右括号</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">')'</span><span class="o">);</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
              	<span class="c1">//回溯</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//左右括号都可以排</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'('</span><span class="o">);</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
                <span class="c1">//回溯</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">')'</span><span class="o">);</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
	              <span class="c1">//回溯</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="23-合并k个升序链表">23. 合并K个升序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">lists</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表数组如下</span><span class="err">：</span>
<span class="o">[</span>
  <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">,</span>
  <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">,</span>
  <span class="mi">2</span><span class="o">-&gt;</span><span class="mi">6</span>
<span class="o">]</span>
<span class="n">将它们合并到一个有序链表中得到</span><span class="err">。</span>
<span class="mi">1</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">6</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">lists</span> <span class="o">=</span> <span class="o">[]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[]</span>
<span class="n">示例</span> <span class="mi">3</span><span class="err">：</span>

<span class="n">输入</span><span class="err">：</span><span class="n">lists</span> <span class="o">=</span> <span class="o">[[]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>k == lists.length</li><li>0 &lt;= k &lt;= 10^4</li><li>0 &lt;= lists[i].length &lt;= 500</li><li>-10^4 &lt;= <code class="language-plaintext highlighter-rouge">lists[i][j]</code> &lt;= 10^4</li><li>lists[i] 按 升序 排列</li><li>lists[i].length 的总和不超过 10^4</li></ul><p>链表数组的归并排序</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeKLists</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lists</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">merge_sort</span><span class="o">(</span><span class="n">lists</span><span class="o">,</span><span class="mi">0</span> <span class="o">,</span><span class="n">lists</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//归并排序</span>
    <span class="nc">ListNode</span> <span class="nf">merge_sort</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">l</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">lists</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">l</span><span class="o">;</span>
        
        <span class="nc">ListNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="o">(</span><span class="n">lists</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="o">(</span><span class="n">lists</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>

        <span class="c1">//合并left链表和right链表</span>
        <span class="nc">ListNode</span> <span class="n">cur_l</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur_r</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">mList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">mList</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur_l</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur_r</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur_l</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">cur_r</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur_l</span><span class="o">;</span>
                <span class="n">cur_l</span> <span class="o">=</span> <span class="n">cur_l</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur_r</span><span class="o">;</span>
                <span class="n">cur_r</span> <span class="o">=</span> <span class="n">cur_r</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur_l</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">cur_l</span> <span class="o">:</span> <span class="n">cur_r</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">mList</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump24"></span></p><h2 id="24两两交换链表中的节点">24.两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">给定</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">,</span> <span class="n">你应该返回</span> <span class="mi">2</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">.</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">swapPairs</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">fake_head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//建立一个伪头节点</span>
        <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fake_head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//存在成对的未交换节点才继续</span>
        <span class="k">while</span><span class="o">(</span><span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//交换节点</span>
            <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">q</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
            <span class="c1">//交换完毕，移向下一组</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//返回头节点</span>
        <span class="k">return</span> <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump25"></span></p><h2 id="25-k-个一组翻转链表">25. K 个一组翻转链表</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？ 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></table></code></div></div><p>按照区间翻转，调用92题的方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseKGroup</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">curHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//遍历一遍统计节点个数</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">curHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">count</span><span class="o">++;</span>
            <span class="n">curHead</span> <span class="o">=</span> <span class="n">curHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//计算需要翻转多少组</span>
        <span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="n">k</span><span class="o">;</span>
        <span class="c1">//开始翻转</span>
        <span class="n">curHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">times</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">curHead</span> <span class="o">=</span> <span class="n">reverseBetween</span><span class="o">(</span><span class="n">curHead</span><span class="o">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">k</span><span class="o">);</span>
            <span class="c1">// for(int j = 1; j &lt; k; ++j){</span>
            <span class="c1">//     curHead = curHead.next;</span>
            <span class="c1">// }</span>
            
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">curHead</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseBetween</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">==</span> <span class="n">left</span><span class="o">)</span>   <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">fakeNead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
        <span class="n">fakeNead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">fakeNead</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span><span class="c1">//此时ptr已经指向了需要翻转部分的前一个节点</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">//开始翻转</span>
        <span class="k">while</span><span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">len</span><span class="o">--;</span>
        <span class="o">}</span>
				<span class="c1">//修改翻转部分的头尾指向</span>
        <span class="k">if</span><span class="o">(</span><span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">fakeNead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump26"></span></p><h2 id="26-删除有序数组中的重复项">26. 删除有序数组中的重复项</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//双指针，将重复序列的第一个数字放到l处</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
                <span class="n">l</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">r</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">l</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump27"></span></p><h2 id="27-移除元素">27. 移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//剔除数字的同时，要将该位置填充为其他数字</span>
        <span class="c1">//这跟前面的移除重复数字很像啊</span>
        <span class="c1">//双指针移动</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">!=</span> <span class="n">val</span><span class="o">){</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
                <span class="n">l</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">r</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">l</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="29-两数相除">29. 两数相除</h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p><p>提示：</p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</li></ul><p>思路：递归，60/8 = (60-32)/8 + 4 = (60-32-16)/8 + 2 + 4 = 1 + 2 + 4 = 7</p><p>将dividend和divisor都转化为负数计算，因为-(1«31)转为正数会溢出，(1 « 31)转为负数不会溢出</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">divide</span><span class="o">(</span><span class="kt">int</span> <span class="n">dividend</span><span class="o">,</span> <span class="kt">int</span> <span class="n">divisor</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//除数和被除数都是32位有符号整数，那怎么可能会溢出呢？难道是-2^31 / -1</span>
        <span class="k">if</span><span class="o">(</span><span class="n">dividend</span> <span class="o">==</span> <span class="o">-(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">divisor</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">dividend</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//用加法逼近</span>

        <span class="k">if</span><span class="o">(</span><span class="n">divisor</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="n">dividend</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">divisor</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>   <span class="k">return</span> <span class="o">-</span><span class="n">dividend</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">((</span><span class="n">dividend</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">divisor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">dividend</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">divisor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)){</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">dividend</span> <span class="o">=</span> <span class="n">dividend</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="n">dividend</span> <span class="o">:</span> <span class="n">dividend</span><span class="o">;</span>
        <span class="n">divisor</span> <span class="o">=</span> <span class="n">divisor</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="n">divisor</span> <span class="o">:</span> <span class="n">divisor</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">div</span><span class="o">(</span><span class="n">dividend</span><span class="o">,</span> <span class="n">divisor</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="o">-</span><span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">div</span><span class="o">(</span><span class="kt">long</span> <span class="n">a</span><span class="o">,</span> <span class="kt">long</span> <span class="n">b</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">tmp</span> <span class="o">+</span> <span class="n">tmp</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">){</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">cnt</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span> <span class="o">+</span> <span class="n">div</span><span class="o">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><h2 id="30-串联所有单词的子串">30. 串联所有单词的子串</h2><p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"barfoothefoobarman"</span><span class="o">,</span> <span class="n">words</span> <span class="o">=</span> <span class="o">[</span><span class="s">"foo"</span><span class="o">,</span><span class="s">"bar"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">从索引</span> <span class="mi">0</span> <span class="n">和</span> <span class="mi">9</span> <span class="n">开始的子串分别是</span> <span class="s">"barfoo"</span> <span class="n">和</span> <span class="s">"foobar"</span> <span class="err">。</span>
<span class="n">输出的顺序不重要</span><span class="o">,</span> <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="n">也是有效答案</span><span class="err">。</span>
</pre></table></code></div></div><p>滑动窗口，窗口大小是固定的，单词长度是固定的，那么只需要检查这个窗口内的单词是否能被words正好覆盖即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//首先需要完全匹配words内的全部内容，那其实拼接起来的字符串长度是固定的</span>
        <span class="c1">//假设拼接的字符串长度大于s，那就不用匹配了，肯定不存在</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="n">words</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">//我们把words的单词放到一个Hash表里，key是单词，value是单词出现的次数</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">words</span><span class="o">){</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//遍历字符串s，遇到一个单词，就记录到hash表2中</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//窗口滑动，找一个单词出来</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">winMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="o">(</span><span class="n">idx</span><span class="o">*</span><span class="n">size</span><span class="o">),</span> <span class="n">i</span> <span class="o">+</span> <span class="o">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">)*</span><span class="n">size</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">break</span><span class="o">;</span>
                <span class="n">winMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">winMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

                <span class="k">if</span><span class="o">(</span><span class="n">winMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">))</span>    <span class="k">break</span><span class="o">;</span>
                <span class="n">idx</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>  <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump31"></span></p><h2 id="31下一个排列">31.下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="err">→</span> <span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span>
<span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span> <span class="err">→</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span> <span class="err">→</span> <span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span>
</pre></table></code></div></div><p>观察变化规律，每次都是从数组结尾开始找到一个逆序对，即<code class="language-plaintext highlighter-rouge">nums[i] &lt;= nums[i+1]</code>的元素，然后再从数组结尾开始找到第一个比<code class="language-plaintext highlighter-rouge">nums[i]</code>大的，二者交换，再反转<code class="language-plaintext highlighter-rouge">[i+1,end]</code></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span>
<span class="o">...</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">nextPermutation</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>        
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">//让r指针从右往左走，直到下一个元素比num[r]小，这个位置的元素需要换到后面来增大字典序</span>
        <span class="c1">//所以还需要从后面找到一个比这个位置元素大的元素，二者交换</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]){</span>
            <span class="n">r</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">//如果r == -1，就直接reverse全部</span>
        <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">//从后面的序列中，找到第一个比nums[r]大的元素，换到前面去</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                <span class="o">--</span><span class="n">cur</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">cur</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//将逆序序列变为正序</span>
        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">){</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">,</span><span class="n">j</span><span class="o">);</span>
            <span class="o">++</span><span class="n">i</span><span class="o">;</span>
            <span class="o">--</span><span class="n">j</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump32"></span></p><h2 id="32-最长有效括号">32. 最长有效括号</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"(()"</span>
<span class="nl">输出:</span> <span class="mi">2</span>
<span class="nl">解释:</span> <span class="n">最长有效括号子串为</span> <span class="s">"()"</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">")()())"</span>
<span class="nl">输出:</span> <span class="mi">4</span>
<span class="nl">解释:</span> <span class="n">最长有效括号子串为</span> <span class="s">"()()"</span>
</pre></table></code></div></div><p>双向扫描</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestValidParentheses</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//统计连续的括号对数量</span>
        <span class="c1">//维护两个变量：left和right分别作为当前子序列的左括号数和右括号数</span>
        <span class="c1">//当右括号数大于左括号数时，全部归0</span>
        <span class="c1">//当左括号数等于右括号数时，有效的“括号对”等于右括号数</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">){</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">left</span><span class="o">){</span>
                <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">==</span> <span class="n">left</span><span class="o">){</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">right</span> <span class="o">*</span> <span class="mi">2</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//反向扫描一次，因为上面的从左到右会出现left始终大于right的情况</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">){</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">){</span>
                <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">==</span> <span class="n">left</span><span class="o">){</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">right</span> <span class="o">*</span> <span class="mi">2</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>动态规划：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestValidParentheses</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//dp[i]表示以第i个字符为结尾的最长有效括号子串长度</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="o">:</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//如果连续两个字符为)，假设倒数第二个字符)为一个有效括号子串str的结尾，</span>
                    <span class="c1">//那么如果最后一个)是有效括号子串结尾，则str的前一个元素必须是(</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">){</span>
                        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span> 
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump33"></span></p><h2 id="33搜索旋转排序数组">33.搜索旋转排序数组</h2><p>给你一个升序排列的整数数组 nums ，和一个整数 target 。</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。</p><p>请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="o">-</span><span class="mi">1</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="o">-</span><span class="mi">1</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>nums 中的每个值都 独一无二</li><li>nums 肯定会在某个点上旋转</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul><p>二分法，判断target和nums[mid]在分段函数的位置来更新l和r指针。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">l</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
              	<span class="c1">//二者都在左分段</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                  	<span class="c1">//二者都在右分段</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>    
                    <span class="c1">//mid在右分段，target在左分段</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="n">输入一个非递减排序的数组的一个旋转</span><span class="err">，</span><span class="n">输出旋转数组的最小元素</span><span class="err">。</span>
<span class="no">NOTE</span><span class="err">：</span><span class="n">给出的所有元素都大于0</span><span class="err">，</span><span class="n">若数组大小为0</span><span class="err">，</span><span class="n">请返回0</span><span class="err">。</span>
  
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minNumberInRotateArray</span><span class="o">(</span><span class="kt">int</span> <span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">//没有旋转过的数组</span>
        <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">[</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span>    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">//其实就是二分找到左端点，左端点有一个性质，其左边的数比它大，右边的数比它小</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="o">((</span><span class="n">h</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="o">[</span><span class="n">h</span><span class="o">]){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">array</span><span class="o">[</span><span class="n">h</span><span class="o">]){</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump34"></span></p><h2 id="34重要在排序数组中查找元素的第一个和最后一个位置">34.[重要]在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><ul><li>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</li></ul><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 105</li><li>-109 &lt;= nums[i] &lt;= 109</li><li>nums 是一个非递减数组</li><li>-109 &lt;= target &lt;= 109</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">searchRange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//二分查找左边界和右边界的问题</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">};</span>
        <span class="c1">//查找左边界</span>
        <span class="kt">int</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">target</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        

        <span class="c1">//查找右边界</span>
        <span class="kt">int</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">target</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">upper</span> <span class="o">&amp;&amp;</span> <span class="n">upper</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">lower</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">upper</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">lower</span><span class="o">,</span><span class="n">upper</span><span class="o">};</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">};</span>
    <span class="o">}</span>
    <span class="c1">//lower==true表示找到左边界，否则就是右边界</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">lower</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="o">||</span> <span class="o">(</span><span class="n">lower</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="o">)){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="35-搜索插入位置">35. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],</span> <span class="mi">5</span>
<span class="nl">输出:</span> <span class="mi">2</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">searchInsert</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//二分查找</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="o">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">l</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="36-有效的数独">36. 有效的数独</h2><p>请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p>注意：</p><p>一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidSudoku</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">rows</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">9</span><span class="o">][</span><span class="mi">10</span><span class="o">];</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">cols</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">9</span><span class="o">][</span><span class="mi">10</span><span class="o">];</span>
        <span class="kt">boolean</span><span class="o">[][][]</span> <span class="n">block</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">3</span><span class="o">][</span><span class="mi">3</span><span class="o">][</span><span class="mi">10</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'.'</span><span class="o">){</span>
                    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">rows</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">||</span> <span class="n">cols</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">||</span> <span class="n">block</span><span class="o">[</span><span class="n">i</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">j</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">k</span><span class="o">])</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">rows</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">cols</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">block</span><span class="o">[</span><span class="n">i</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">j</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump37"></span></p><h2 id="37解数独">37.解数独</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><p>数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 ‘.’ 表示。</p><p><strong>Note:</strong></p><ul><li>给定的数独序列只包含数字 <code class="language-plaintext highlighter-rouge">1-9</code> 和字符 <code class="language-plaintext highlighter-rouge">'.'</code> 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 <code class="language-plaintext highlighter-rouge">9x9</code> 形式的。</li></ul><p>回溯法，这题的难点在于（1）方块区域的访问判断；（2）下一步往哪儿递归；（3）什么条件下回溯。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">row_visited</span><span class="o">;</span>
    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">col_visited</span><span class="o">;</span>
    <span class="kt">boolean</span><span class="o">[][][]</span> <span class="n">block_visited</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">solveSudoku</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//判断某行是否访问过k元素,1&lt;=k&lt;=9</span>
        <span class="n">row_visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">9</span><span class="o">][</span><span class="mi">10</span><span class="o">];</span>
        <span class="c1">//判断某列是否访问过k元素,1&lt;=k&lt;=9</span>
        <span class="n">col_visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">9</span><span class="o">][</span><span class="mi">10</span><span class="o">];</span>
        <span class="c1">//判断某3*3方块区域是否访问过k元素,1&lt;=k&lt;=9</span>
        <span class="n">block_visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">3</span><span class="o">][</span><span class="mi">3</span><span class="o">][</span><span class="mi">10</span><span class="o">];</span>
        <span class="c1">//预填充，自带的数字先加入访问数组中</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'.'</span><span class="o">){</span>
                    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
                    <span class="n">row_visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">col_visited</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">block_visited</span><span class="o">[</span><span class="n">i</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">j</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="c1">//若首次超出了边界，即x == 8,y == 9，就说明找到了答案</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">9</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//若当前不是可填充区域，就向右移动，若到达了右边界，就x+1，从下一行的开头开始填充</span>
        <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'.'</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">8</span><span class="o">){</span>
                <span class="n">new_x</span><span class="o">++;</span>
                <span class="n">new_y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">new_x</span><span class="o">,</span><span class="n">new_y</span><span class="o">);</span>
        <span class="o">}</span>
				<span class="c1">//当前是可填充区域</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
            <span class="c1">//若当前数字目前来看是合法的</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">row_visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">col_visited</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">block_visited</span><span class="o">[</span><span class="n">x</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">y</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">k</span><span class="o">]){</span>
                <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">k</span><span class="o">+</span><span class="mi">48</span><span class="o">);</span>
                <span class="n">row_visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">col_visited</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">block_visited</span><span class="o">[</span><span class="n">x</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">y</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="c1">//向右移动，若到达了右边界，就x+1，从下一行的开头开始填充</span>
                <span class="kt">int</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">8</span><span class="o">){</span>
                    <span class="n">new_x</span><span class="o">++;</span>
                    <span class="n">new_y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//在后边的遍历过程中，发现当前数字不合法，回溯，修改数字</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">new_x</span><span class="o">,</span><span class="n">new_y</span><span class="o">)){</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="o">;</span>
                    <span class="n">row_visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">col_visited</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">block_visited</span><span class="o">[</span><span class="n">x</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">y</span><span class="o">/</span><span class="mi">3</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//填充当前的x,y区域，发现所有数字都无法填充进去，那么就要求回溯</span>
        <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'.'</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="38-外观数列">38. 外观数列</h2><p>给定一个正整数 n ，输出外观数列的第 n 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><p>countAndSay(1) = “1” countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。</p><p>前五项如下：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="p">1.</span>     1
<span class="p">2.</span>     11
<span class="p">3.</span>     21
<span class="p">4.</span>     1211
<span class="p">5.</span>     111221
       第一项是数字 1 
       描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
       描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
       描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
       描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"<span class="sb">


</span></pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">countAndSay</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//从数字 1 开始，序列中的每一项都是对前一项的描述。</span>
        <span class="cm">/*
        递归公式：
            countAndSay(1) = "1"
            countAndSay(n)是对countAndSay(n-1)的描述
            1
            11          1个1
            21          2个1
            1211        1个1+1个1
            111221      1个1+1个2+2个1
        */</span>
        <span class="c1">//应该用递归完成</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="s">"1"</span><span class="o">;</span>
        <span class="c1">//对n这个数进行描述</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"1"</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">){</span>
            <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">){</span>
                <span class="kt">char</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">)){</span>
                    <span class="n">idx</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="c1">//几个数？</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
                <span class="c1">//什么数？</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">str</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
            <span class="n">k</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump39"></span></p><h2 id="39组合总和">39.组合总和</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><ul><li><p>所有数字（包括 target）都是正整数。</p></li><li><p>解集不能包含重复的组合。</p></li></ul><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">candidates</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span>
<span class="n">所求解集为</span><span class="err">：</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">7</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">candidates</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">8</span><span class="o">,</span>
<span class="n">所求解集为</span><span class="err">：</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><h3 id="回溯">回溯</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">target</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(),</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">,</span><span class="kt">int</span> <span class="n">cur</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">res</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">ans</span><span class="o">))</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ans</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span><span class="n">list</span><span class="o">,</span><span class="n">sum</span> <span class="o">+</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump40"></span></p><h2 id="40组合总和-ii">40.组合总和 II</h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">candidates</span> <span class="o">=</span> <span class="o">[</span><span class="mi">10</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">8</span><span class="o">,</span>
<span class="nl">所求解集为:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">candidates</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span>
<span class="nl">所求解集为:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">5</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><h3 id="回溯法-1">回溯法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">target</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
        <span class="c1">//先对数组排序，方便剪枝，遇到第一个大于target的元素，后面的元素就都不用判断了</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">candidates</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(),</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="o">||</span> <span class="n">cur</span> <span class="o">&gt;</span> <span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">res</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">list</span><span class="o">))</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//剪枝</span>
            <span class="k">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
          	<span class="c1">//重复的起点无需再次判断</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="c1">//遍历回溯</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">list</span><span class="o">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
      
      	<span class="c1">//也可以不用set,速度快了一些</span>
      	<span class="c1">//if (i &gt; cur &amp;&amp; candidates[i] == candidates[i - 1]) continue;</span>
        <span class="c1">////遍历回溯</span>
        <span class="c1">//list.add(candidates[i]);</span>
        <span class="c1">//dfs(candidates, list, sum + candidates[i], i+1);</span>
        <span class="c1">//list.remove(list.size()-1);</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="41-缺失的第一个正数">41. 缺失的第一个正数</h2><p>给你一个未排序的整数数组 <code class="language-plaintext highlighter-rouge">nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code class="language-plaintext highlighter-rouge">O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstMissingPositive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//暴力：放到哈希表里，从1开始找，时间复杂度为O(n)，但是空间复杂度为O(n)</span>
        <span class="c1">//需要优化空间复杂度</span>
        <span class="c1">//下标标记法，遍历一遍数组，若数组元素在区间[0, nums.length-1]之间，就将其交换到对应的位置</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">^</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">^</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">^</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump42"></span></p><h2 id="42-接雨水">42. 接雨水</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例 1：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/rainwatertrap-20201215205906366.png" alt="img" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">height</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="n">上面是由数组</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">表示的高度图</span><span class="err">，</span><span class="n">在这种情况下</span><span class="err">，</span><span class="n">可以接</span> <span class="mi">6</span> <span class="n">个单位的雨水</span><span class="err">（</span><span class="n">蓝色部分表示雨水</span><span class="err">）。</span> 
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">height</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">9</span>
</pre></table></code></div></div><p>提示：</p><ul><li>n == height.length</li><li>0 &lt;= n &lt;= 3 * 104</li><li>0 &lt;= height[i] &lt;= 105</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">trap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//最终的结果肯定是一组先非严格递增后非严格递减的序列</span>
        <span class="c1">//找到最高点</span>
        <span class="c1">//从左往右遍历，如果还没到最高点，出现了下降的趋势，就开始填山谷，直到填平</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">){</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">max</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">maxCount</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">//开始填谷</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//遇到一个最高点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">max</span><span class="o">){</span>
                <span class="n">maxCount</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="c1">//后面还有最高点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">maxCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="c1">//遇到谷就填</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//这时左半边序列已经完全非严格递增</span>
        <span class="c1">//接下来要反向填谷，从序列尾端开始填，直到遇到最高点就停止</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">max</span><span class="o">)</span>    <span class="k">break</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>动态规划：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">long</span> <span class="nf">maxWater</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write code here</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0L</span><span class="o">;</span>
        <span class="c1">//遍历每个数字arr[i]，这个位置能装的水取决于左右边界的高度。</span>
        <span class="c1">//dp，将位置i左边的最高边界保存，将位置i右边的最高边界保存。</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">right</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><p>单调栈模拟：将求雨水容量的过程看作是一个个长方体向左拼接的过程，遇到一个凹槽，就计算其容量。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">long</span> <span class="nf">maxWater</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// write code here</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0L</span><span class="o">;</span>
  <span class="c1">//单调栈模拟，将索引放入单调栈，</span>
  <span class="c1">//当当前数组元素比栈顶元素小时，说明这个元素可以作为底，栈顶元素可以作为左边界</span>
  <span class="c1">//当当前数组元素比栈顶元素大时，说明这个元素可以作为右边界，将栈顶元素弹出</span>
  <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
  <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]){</span>
      <span class="kt">int</span> <span class="n">bolt</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
      <span class="k">if</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span><span class="c1">//如果栈中只有一个元素，那说明没有左边界</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="kt">long</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">-</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
      <span class="kt">long</span> <span class="n">height</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()],</span> <span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">])</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">bolt</span><span class="o">];</span>
      <span class="n">res</span> <span class="o">+=</span> <span class="o">(</span><span class="n">dis</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">height</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur</span><span class="o">++);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump43"></span></p><h2 id="43字符串相乘">43.字符串相乘</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">num1</span> <span class="o">=</span> <span class="s">"2"</span><span class="o">,</span> <span class="n">num2</span> <span class="o">=</span> <span class="s">"3"</span>
<span class="nl">输出:</span> <span class="s">"6"</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">num1</span> <span class="o">=</span> <span class="s">"123"</span><span class="o">,</span> <span class="n">num2</span> <span class="o">=</span> <span class="s">"456"</span>
<span class="nl">输出:</span> <span class="s">"56088"</span>
</pre></table></code></div></div><p>说明：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">num1</span> <span class="n">和</span> <span class="n">num2</span> <span class="n">的长度小于110</span><span class="err">。</span>
<span class="n">num1</span> <span class="n">和</span> <span class="n">num2</span> <span class="n">只包含数字</span> <span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="err">。</span>
<span class="n">num1</span> <span class="n">和</span> <span class="n">num2</span> <span class="n">均不以零开头</span><span class="err">，</span><span class="n">除非是数字</span> <span class="mi">0</span> <span class="n">本身</span><span class="err">。</span>
<span class="n">不能使用任何标准库的大数类型</span><span class="err">（</span><span class="n">比如</span> <span class="nc">BigInteger</span><span class="err">）</span><span class="n">或直接将输入转换为整数来处理</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_字符串相乘.png" alt="leetcode_字符串相乘" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">multiply</span><span class="o">(</span><span class="nc">String</span> <span class="n">num1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">num2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"0"</span><span class="o">)</span> <span class="o">||</span> <span class="n">num2</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"0"</span><span class="o">))</span> <span class="k">return</span> <span class="s">"0"</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">num1</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span><span class="n">m</span> <span class="o">=</span> <span class="n">num2</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>

        <span class="c1">//存放结果</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
            <span class="c1">//进位标志</span>
            <span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="c1">//十位补1个0，百位补2个0，以此类推，便于累加计算每位的乘积</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">num2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
            <span class="c1">//遍历num1的每一位</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">num1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">add</span><span class="o">;</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">product</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
                <span class="c1">//乘积大于9，进位</span>
                <span class="n">add</span> <span class="o">=</span> <span class="n">product</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//最后一次计算是否有进位未处理</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">add</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">add</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">addString</span><span class="o">(</span><span class="n">res</span><span class="o">,</span><span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
            
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">String</span> <span class="nf">addString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">add</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">StringBuffer</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">add</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">add</span><span class="o">;</span>
            <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
            <span class="n">add</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
            <span class="o">--</span><span class="n">n</span><span class="o">;</span>
            <span class="o">--</span><span class="n">m</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param s string字符串 第一个整数
     * @param t string字符串 第二个整数
     * @return string字符串
     */</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">solve</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">len2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len1</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len2</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len2</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span><span class="o">];</span>
        
        <span class="c1">// 1. 逐位相乘</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len2</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 2. 从后往前进位</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">--){</span>
            <span class="n">result</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">result</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
            <span class="n">result</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 输出字符串</span>
        <span class="nc">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><h2 id="44-通配符匹配">44. 通配符匹配</h2><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>’?’ 可以匹配任何单个字符。 ‘*’ 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p><p><strong>示例 1:</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">//dp[i][j]表示s[i]和p[j]是否匹配</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">//初始化边界，空串配p子串</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="c1">//因为*字符是不能消除前面的字符的，只能匹配0个或多个字符</span>
            <span class="c1">//所以只要p中出现了其他字符，那必不可能配空串了</span>
            <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'*'</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'*'</span><span class="o">){</span>
                    <span class="c1">//可以选择配0个，可以选择配1个，可以选择配多个</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'?'</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)){</span>
                        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="45-跳跃游戏-ii">45. 跳跃游戏 II</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
<span class="nl">解释:</span> <span class="n">跳到最后一个位置的最小跳跃数是</span> <span class="mi">2</span><span class="err">。</span>
     <span class="n">从下标为</span> <span class="mi">0</span> <span class="n">跳到下标为</span> <span class="mi">1</span> <span class="n">的位置</span><span class="err">，</span><span class="n">跳</span> <span class="mi">1</span> <span class="n">步</span><span class="err">，</span><span class="n">然后跳</span> <span class="mi">3</span> <span class="n">步到达数组的最后一个位置</span><span class="err">。</span>
</pre></table></code></div></div><p>提示:</p><ul><li>1 &lt;= nums.length &lt;= 1000</li><li>0 &lt;= nums[i] &lt;= 105</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">jump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="c1">//这一次跳跃能到达的最远的位置</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="c1">//当前跳跃的边界</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">r</span><span class="o">){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
                <span class="n">res</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump46"></span></p><h2 id="46-全排列">46. 全排列</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="nl">输出:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>回溯交换：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">permute</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">backTrack</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">backTrack</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span><span class="kt">int</span> <span class="n">cur</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>   
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">cur</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="n">backTrack</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">cur</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">cur</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump47"></span></p><h2 id="47全排列-ii">47.全排列 II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">输出:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>回溯法。往n个格子里填数字，每个数字只能填一次，且不能出现重复排列。</p><p>每个数字只能填一次。这个容易实现，用一个<code class="language-plaintext highlighter-rouge">visited[i]</code>数组标记数字<code class="language-plaintext highlighter-rouge">i</code>是否被访问过。</p><p>不能出现重复排列。例如在填第<code class="language-plaintext highlighter-rouge">i</code>个格子（从0开始计数）的时候，我们需要尝试填<code class="language-plaintext highlighter-rouge">n-i-1</code>个数字，这<code class="language-plaintext highlighter-rouge">n-i-1</code>个数字如果有重复的数字，那么我们就会重复地往第<code class="language-plaintext highlighter-rouge">i</code>个格子里填同一个数字，导致出现重复序列。所以，在填第<code class="language-plaintext highlighter-rouge">i</code>个格子的时候，用一个集合来存放已经填过的数字，保证下一次尝试不会填入重复的数字，即可去重。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">permuteUnique</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">backTrack</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">nums</span><span class="o">,</span><span class="n">tmp</span><span class="o">,</span><span class="n">visited</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
		<span class="c1">//往第cur个格子里填数字，从0开始</span>
    <span class="kt">void</span> <span class="nf">backTrack</span><span class="o">(</span><span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="o">,</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">){</span>
			<span class="c1">//当所有格子都填满的时候，记录结果</span>
      <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">tmp</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
      	<span class="c1">//存放已经填过的数字</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
      	<span class="c1">//尝试每一种填法</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
						<span class="c1">//只有当前数字没有被访问，且没在集合中</span>
            <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">||</span> <span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">backTrack</span><span class="o">(</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">nums</span><span class="o">,</span><span class="n">tmp</span><span class="o">,</span><span class="n">visited</span><span class="o">);</span>
          	<span class="c1">//回溯</span>
            <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump48"></span></p><h2 id="48旋转图像">48.旋转图像</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">给定</span> <span class="n">matrix</span> <span class="o">=</span> 
<span class="o">[</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span>
<span class="o">],</span>

<span class="n">原地旋转输入矩阵</span><span class="err">，</span><span class="nl">使其变为:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">给定</span> <span class="n">matrix</span> <span class="o">=</span>
<span class="o">[</span>
  <span class="o">[</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">],</span>
  <span class="o">[</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">13</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">15</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">16</span><span class="o">]</span>
<span class="o">],</span> 

<span class="n">原地旋转输入矩阵</span><span class="err">，</span><span class="nl">使其变为:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">15</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">14</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">12</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">16</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//先转置，再按列交换</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump49"></span></p><h2 id="49字母异位词分组">49.字母异位词分组</h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="s">"eat"</span><span class="o">,</span> <span class="s">"tea"</span><span class="o">,</span> <span class="s">"tan"</span><span class="o">,</span> <span class="s">"ate"</span><span class="o">,</span> <span class="s">"nat"</span><span class="o">,</span> <span class="s">"bat"</span><span class="o">]</span>
<span class="nl">输出:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="s">"ate"</span><span class="o">,</span><span class="s">"eat"</span><span class="o">,</span><span class="s">"tea"</span><span class="o">],</span>
  <span class="o">[</span><span class="s">"nat"</span><span class="o">,</span><span class="s">"tan"</span><span class="o">],</span>
  <span class="o">[</span><span class="s">"bat"</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>说明：</p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">groupAnagrams</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//用哈希法找异位词</span>
        <span class="c1">//两个互为异位词，则哈希数组肯定相同</span>
        <span class="c1">//我们可以把哈希数组存为一个key值，然后再遍历每个字符串</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toCharArray</span><span class="o">();</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">counts</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">arr</span><span class="o">){</span>
                <span class="n">counts</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
            <span class="o">}</span>

            <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="c1">//用分隔符隔开，这样可以防止11和1、1混在一起</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'*'</span><span class="o">);</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>   <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nf">ArrayList</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
        
    <span class="o">}</span>

    
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump50"></span></p><h2 id="50powx-n">50.Pow(x, n)</h2><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mf">2.00000</span><span class="o">,</span> <span class="mi">10</span>
<span class="nl">输出:</span> <span class="mf">1024.00000</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mf">2.10000</span><span class="o">,</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="mf">9.26100</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mf">2.00000</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span>
<span class="nl">输出:</span> <span class="mf">0.25000</span>
<span class="nl">解释:</span> <span class="mi">2</span><span class="o">-</span><span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">22</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="o">=</span> <span class="mf">0.25</span>
</pre></table></code></div></div><p>说明:</p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><p>快速幂解法：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>n = 1<span class="ge">*b1 + 2*</span>b2 + 4<span class="ge">*b3 + ... + 2^m-1 *</span> bm
x^n = x^(b1 + 2<span class="ge">*b2 + 4*</span>b3 + ... + 2^m-1 <span class="err">*</span> bm)
= x^b1 <span class="ge">* x^2b2 *</span> x^4b3 <span class="ge">* ... x^2^m-1*</span>bm
分两步：
求x^1, x^2, x^4...x^2^m-1	-&gt; x <span class="err">*</span>= x即可
求b1,b2,b3,...,bm					-&gt; b_i = n &amp; 1; n &gt;&gt;= 1;
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">myPow</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mf">0.0f</span><span class="o">)</span>   <span class="k">return</span> <span class="mf">0.0d</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="kt">double</span> <span class="n">res</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="o">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="n">res</span> <span class="o">*=</span> <span class="n">y</span><span class="o">;</span>
            <span class="n">b</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">y</span> <span class="o">*=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump51"></span></p><h2 id="51n-皇后">51.N 皇后</h2><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="mi">4</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span>
 <span class="o">[</span><span class="s">".Q.."</span><span class="o">,</span>  <span class="c1">// 解法 1</span>
  <span class="s">"...Q"</span><span class="o">,</span>
  <span class="s">"Q..."</span><span class="o">,</span>
  <span class="s">"..Q."</span><span class="o">],</span>

 <span class="o">[</span><span class="s">"..Q."</span><span class="o">,</span>  <span class="c1">// 解法 2</span>
  <span class="s">"Q..."</span><span class="o">,</span>
  <span class="s">"...Q"</span><span class="o">,</span>
  <span class="s">".Q.."</span><span class="o">]</span>
<span class="o">]</span>
<span class="nl">解释:</span> <span class="mi">4</span> <span class="n">皇后问题存在两个不同的解法</span><span class="err">。</span>

</pre></table></code></div></div><p>提示：</p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><p>n*n的棋盘，放置n个皇后，且每个皇后不能处于同一条横行、纵行或斜线上，说明每一行都有一个皇后。所以我们只要遍历每一行，在合适的位置放置一个皇后即可。合适的位置判断如下：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>不能在同一列。用一个集合存放已访问的列。
不能在同一正对角线。同一个正对角线上，i-j的值是相等的，因此用一个集合放置已访问过的i-j的值。
不能在同一负对角线。同一个负对角线上，i+j的值是相等的，因此用一个集合放置已访问过的i+j的值。
</pre></table></code></div></div><p>若每个皇后都顺利放置完毕，就记录此时棋盘的状态。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
  <span class="c1">//标识某一列已经有皇后了</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">col</span><span class="o">;</span>
  <span class="c1">//标识某一正对角线已经有皇后了，这条线上，i-j的值是唯一的</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">pos_dia</span><span class="o">;</span>
  <span class="c1">//标识某一负对角线已经有皇后了，这条线上，i+j的值是唯一的</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">neg_dia</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
      <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
      <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">col</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="n">pos_dia</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="n">neg_dia</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
        <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//按行填充皇后，n个皇后一定分布在不同行，而且每行都会有一个皇后</span>
    <span class="n">backTrack</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">void</span> <span class="nf">backTrack</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span><span class="kt">int</span> <span class="n">row</span><span class="o">){</span>
    <span class="c1">//找到了一种答案</span>
    <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
      <span class="c1">//将棋盘状态记录到列表中</span>
      <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
        <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
          <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
      <span class="o">}</span>
      <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//在列上填充</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
      <span class="k">if</span><span class="o">(!</span><span class="n">col</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
        <span class="c1">//若此位置所在的两条对角线没有被访问过</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">pos_dia</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="n">row</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">neg_dia</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">row</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="o">;</span>
          <span class="n">col</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
          <span class="n">pos_dia</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">row</span><span class="o">);</span>
          <span class="n">neg_dia</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">row</span><span class="o">);</span>
          <span class="n">cnt</span><span class="o">--;</span>
          <span class="n">backTrack</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
          <span class="c1">//回溯</span>
          <span class="n">cnt</span><span class="o">++;</span>
          <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="o">;</span>
          <span class="n">col</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
          <span class="n">pos_dia</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">row</span><span class="o">);</span>
          <span class="n">neg_dia</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">row</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><ul><li>时间复杂度为O(n!)，n为皇后的数量。</li><li>空间复杂度为O(n)，n为皇后的数量。空间复杂度主要取决于递归调用层数、记录每行放置的皇后的列下标的数组以及三个集合，递归调用层数不会超过 N，数组的长度为 N，每个集合的元素个数都不会超过 N。</li></ul><p>回顾这道题，拿到这道题的时候，其实我们很容易看出需要使用枚举的方法来求解这个问题，当我们不知道用什么办法来枚举是最优的时候，可以从下面三个方向考虑：</p><ul><li>子集枚举：可以把问题转化成「从n^2^个格子中选一个子集，使得子集中恰好有 n 个格子，且任意选出两个都不在同行、同列或者同对角线」，这里枚举的规模是 2^n^</li><li>组合枚举：可以把问题转化成「从 n^2^个格子中选择 n 个，且任意选出两个都不在同行、同列或者同对角线」，这里的枚举规模是 n~n~^2^;</li><li>排列枚举：因为这里每行只能放置一个皇后，而所有行中皇后的列号正好构成一个 1 到 n 的排列，所以我们可以把问题转化为一个排列枚举，规模是 n!。</li></ul><p>带入一些 nn 进这三种方法验证，就可以知道那种方法的枚举规模是最小的，这里我们发现第三种方法的枚举规模最小。这道题给出的两个方法其实和排列枚举的本质是类似的。</p><p><span id="jump52"></span></p><h2 id="52n皇后-iitag">52.N皇后 II[tag]</h2><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="mi">4</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span>
 <span class="o">[</span><span class="s">".Q.."</span><span class="o">,</span>  <span class="c1">// 解法 1</span>
  <span class="s">"...Q"</span><span class="o">,</span>
  <span class="s">"Q..."</span><span class="o">,</span>
  <span class="s">"..Q."</span><span class="o">],</span>

 <span class="o">[</span><span class="s">"..Q."</span><span class="o">,</span>  <span class="c1">// 解法 2</span>
  <span class="s">"Q..."</span><span class="o">,</span>
  <span class="s">"...Q"</span><span class="o">,</span>
  <span class="s">".Q.."</span><span class="o">]</span>
<span class="o">]</span>
<span class="nl">解释:</span> <span class="mi">4</span> <span class="n">皇后问题存在两个不同的解法</span><span class="err">。</span>

</pre></table></code></div></div><p>提示：</p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><p>n*n的棋盘，放置n个皇后，且每个皇后不能处于同一条横行、纵行或斜线上，说明每一行都有一个皇后。所以我们只要遍历每一行，在合适的位置放置一个皇后即可。合适的位置判断如下：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>不能在同一列。用一个集合存放已访问的列。
不能在同一正对角线。同一个正对角线上，i-j的值是相等的，因此用一个集合放置已访问过的i-j的值。
不能在同一负对角线。同一个负对角线上，i+j的值是相等的，因此用一个集合放置已访问过的i+j的值。
</pre></table></code></div></div><p>若每个皇后都顺利放置完毕，就计数+1。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">//不能在同一列</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">col</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//不能在同一正对角线</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">pos_dia</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//不能在同一负对角线</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">neg_dia</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">totalNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">backTrack</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">backTrack</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">){</span>
        <span class="c1">//填充完毕，找到了一种答案</span>
        <span class="k">if</span><span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">//遍历这一行的每一列</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">col</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pos_dia</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">neg_dia</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">j</span><span class="o">)){</span>
                <span class="n">col</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                <span class="n">pos_dia</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">j</span><span class="o">);</span>
                <span class="n">neg_dia</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">j</span><span class="o">);</span>

                <span class="n">backTrack</span><span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">//回溯</span>
                <span class="n">col</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                <span class="n">pos_dia</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">j</span><span class="o">);</span>
                <span class="n">neg_dia</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>位运算解法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">totalNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">columns</span><span class="o">,</span> <span class="kt">int</span> <span class="n">diagonals1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">diagonals2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">availablePositions</span> <span class="o">=</span> <span class="o">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(~(</span><span class="n">columns</span> <span class="o">|</span> <span class="n">diagonals1</span> <span class="o">|</span> <span class="n">diagonals2</span><span class="o">));</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">availablePositions</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">availablePositions</span> <span class="o">&amp;</span> <span class="o">(-</span><span class="n">availablePositions</span><span class="o">);</span>
                <span class="n">availablePositions</span> <span class="o">=</span> <span class="n">availablePositions</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">availablePositions</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">solve</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">columns</span> <span class="o">|</span> <span class="n">position</span><span class="o">,</span> <span class="o">(</span><span class="n">diagonals1</span> <span class="o">|</span> <span class="n">position</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">diagonals2</span> <span class="o">|</span> <span class="n">position</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump53"></span></p><h2 id="53最大子序和">53.最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,-</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,-</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">6</span>
<span class="nl">解释:</span> <span class="n">连续子数组</span> <span class="o">[</span><span class="mi">4</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">的和最大</span><span class="err">，</span><span class="n">为</span> <span class="mi">6</span><span class="err">。</span>
</pre></table></code></div></div><p>进阶:</p><ul><li>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  	<span class="c1">//dp[i]表示以第i个元素为结尾的最大子序列和</span>
  	<span class="c1">//dp[i] = dp[i-1] &gt; 0 ? dp[i-1] + nums[i] : nums[i];</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">dp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span> <span class="o">:</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">dp</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>分治：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//线段树解法：</span>
    <span class="cm">/*对于一个区间 [l, r][l,r]，我们可以维护四个量：
        lSum 表示 [l, r][l,r] 内以 ll 为左端点的最大子段和
        rSum 表示 [l, r][l,r] 内以 rr 为右端点的最大子段和
        mSum 表示 [l, r][l,r] 内的最大子段和
        iSum 表示 [l, r][l,r] 的区间和*/</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Status</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="n">lSum</span><span class="o">,</span> <span class="n">rSum</span><span class="o">,</span> <span class="n">mSum</span><span class="o">,</span> <span class="n">iSum</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Status</span><span class="o">(</span><span class="kt">int</span> <span class="n">_lSum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">_rSum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">_mSum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">_iSum</span><span class="o">){</span>
            <span class="n">lSum</span> <span class="o">=</span> <span class="n">_lSum</span><span class="o">;</span>
            <span class="n">rSum</span> <span class="o">=</span> <span class="n">_rSum</span><span class="o">;</span>
            <span class="n">mSum</span> <span class="o">=</span> <span class="n">_mSum</span><span class="o">;</span>
            <span class="n">iSum</span> <span class="o">=</span> <span class="n">_iSum</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getMSum</span><span class="o">(){</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">mSum</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getInfo</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">getMSum</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Status</span> <span class="nf">getInfo</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Status</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">],</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">],</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">],</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">l</span><span class="o">;</span>
        <span class="nc">Status</span> <span class="n">left</span> <span class="o">=</span> <span class="n">getInfo</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
        <span class="nc">Status</span> <span class="n">right</span> <span class="o">=</span> <span class="n">getInfo</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>

        <span class="k">return</span> <span class="nf">pushUp</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Status</span> <span class="nf">pushUp</span><span class="o">(</span><span class="nc">Status</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Status</span> <span class="n">s2</span><span class="o">){</span>
        
        <span class="kt">int</span> <span class="n">ls</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">lSum</span><span class="o">,</span> <span class="n">s1</span><span class="o">.</span><span class="na">iSum</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">lSum</span><span class="o">);</span>
        
        <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">rSum</span><span class="o">,</span> <span class="n">s1</span><span class="o">.</span><span class="na">rSum</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">iSum</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">is</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">iSum</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">iSum</span><span class="o">;</span>
        <span class="c1">//合并区间的最大子序和可能是左区间的最大子序和或者右区间的最大子序和，</span>
        <span class="c1">//也可能跨越分界点m：左区间以右端点为结尾的的最大子序和+右区间以左端点为起始的最大子序和</span>
        <span class="kt">int</span> <span class="n">ms</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">mSum</span><span class="o">,</span> <span class="n">s2</span><span class="o">.</span><span class="na">mSum</span><span class="o">),</span> <span class="n">s1</span><span class="o">.</span><span class="na">rSum</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">lSum</span><span class="o">);</span>


        <span class="k">return</span> <span class="k">new</span> <span class="nf">Status</span><span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">rs</span><span class="o">,</span> <span class="n">ms</span><span class="o">,</span> <span class="n">is</span><span class="o">);</span>
    <span class="o">}</span>



<span class="o">}</span>
</pre></table></code></div></div><p>不仅可以解决区间<code class="language-plaintext highlighter-rouge"> [0,n−1]</code>，还可以用于解决任意的子区间 <code class="language-plaintext highlighter-rouge">[l, r]</code> 的问题。如果我们把<code class="language-plaintext highlighter-rouge">[0,n−1] </code>分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后，我们就可以在O(logn) 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在O(logn) 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——线段树。</p><p><span id="jump54"></span></p><h2 id="54-螺旋矩阵">54. 螺旋矩阵</h2><p>给你一个 <code class="language-plaintext highlighter-rouge">m</code> 行 <code class="language-plaintext highlighter-rouge">n</code> 列的矩阵 <code class="language-plaintext highlighter-rouge">matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">matrix</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></table></code></div></div><p>边界缩小法：左边界：0，右边界n，上边界0，下边界m。</p><ul><li>当遍历到最右边后，上边界+1；</li><li>当遍历到最下边后，右边界-1；</li><li>当遍历到最左边后，下边界-1；</li><li>当遍历到最上边后，左边界+1；</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">spiralOrder</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">i</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(++</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(--</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">i</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(--</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">y</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(++</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump55"></span></p><h2 id="55-跳跃游戏">55. 跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="kc">true</span>
<span class="nl">解释:</span> <span class="n">我们可以先跳</span> <span class="mi">1</span> <span class="n">步</span><span class="err">，</span><span class="n">从位置</span> <span class="mi">0</span> <span class="n">到达</span> <span class="n">位置</span> <span class="mi">1</span><span class="o">,</span> <span class="n">然后再从位置</span> <span class="mi">1</span> <span class="n">跳</span> <span class="mi">3</span> <span class="n">步到达最后一个位置</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="kc">false</span>
<span class="nl">解释:</span> <span class="n">无论怎样</span><span class="err">，</span><span class="n">你总会到达索引为</span> <span class="mi">3</span> <span class="n">的位置</span><span class="err">。</span><span class="n">但该位置的最大跳跃长度是</span> <span class="mi">0</span> <span class="err">，</span> <span class="n">所以你永远不可能到达最后一个位置</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//维护一个maxStep，表示当前能够跳过的最大长度</span>
        <span class="c1">//只要这个小于等于连续0序列的长度，就没办法越过</span>
        <span class="kt">int</span> <span class="n">maxStep</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">maxStep</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">maxStep</span><span class="o">);</span>

            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">maxStep</span><span class="o">--;</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//统计连续0序列的长度</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">cur</span><span class="o">++;</span>
          	<span class="c1">//到达了最后一个序列，那么最大长度可以只需大于等于连续0序列长度-1即可，最后一个0无所谓</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">maxStep</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">cur</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">maxStep</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">cur</span> <span class="o">-</span> <span class="n">i</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">maxStep</span> <span class="o">-=</span> <span class="o">(</span><span class="n">cur</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">rightmost</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">rightmost</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">rightmost</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">rightmost</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="56合并区间">56.合并区间</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">intervals</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">15</span><span class="o">,</span><span class="mi">18</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">15</span><span class="o">,</span><span class="mi">18</span><span class="o">]]</span>
<span class="nl">解释:</span> <span class="n">区间</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="n">和</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span> <span class="n">重叠</span><span class="o">,</span> <span class="n">将它们合并为</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">].</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">intervals</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">]]</span>
<span class="nl">解释:</span> <span class="n">区间</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="n">和</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="n">可被视为重叠区间</span><span class="err">。</span>
<span class="n">注意</span><span class="err">：</span><span class="n">输入类型已于2019年4月15日更改</span><span class="err">。</span> <span class="n">请重置默认代码定义以获取新方法签名</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li><code class="language-plaintext highlighter-rouge">intervals[i][0] &lt;= intervals[i][1]</code></li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//先按左端点排序，若左端点相同，再按右端点排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">//依次读取区间，判断当前区间的结束是否大于等于下一个区间的开始，如果是，就将两个区间合并</span>
        <span class="c1">//合并规则：两者取最小左端点，取最大右端点</span>

        <span class="c1">//指向当前区间</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//当前区间的结束大于等于下一个区间的开始</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]});</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]});</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()][</span><span class="mi">2</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump57"></span></p><h2 id="57插入区间">57.插入区间</h2><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">intervals</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]],</span> <span class="n">newInterval</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">intervals</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">12</span><span class="o">,</span><span class="mi">16</span><span class="o">]],</span> <span class="n">newInterval</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">12</span><span class="o">,</span><span class="mi">16</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">这是因为新的区间</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span> <span class="n">与</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span> <span class="n">重叠</span><span class="err">。</span>
</pre></table></code></div></div><p>无非是边界判断和区间合并，繁琐了点而已，没啥难度。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">newInterval</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//让newInterval的起点和每个intervals的终点比较，搜索插入的起点。</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//所有终点小于newInterval起点的区间都加入结果集</span>
            <span class="k">if</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">//出现了终点大于等于newInterval起点的区间</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//如果newInterval的终点小于intervals的起点，就没有往后搜索的意义了</span>
                <span class="c1">//newInterval直接插入在最前面</span>

                <span class="c1">//否则就继续搜索</span>
                <span class="k">if</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                    <span class="c1">//如果newInterval的起点要大于搜索到的位置的起点，就更新newInterval的起点</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                        <span class="n">newInterval</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                    <span class="o">}</span>
                    <span class="c1">//如果newInterval的终点要小于搜索到的位置的终点，就更新newInterval的终点</span>
                    <span class="c1">//将这个位置区间包裹在内</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]){</span>
                        <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//让newInterval的终点和每个intevals的起点比较，搜索插入的终点。</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//如果newInterval的终点某个区间的起点重合</span>
            <span class="k">if</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="c1">//直接将这个区间包裹进来</span>
                <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//如果newInterval的终点大于某个区间的起点，并且终点小于这个区间的终点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]){</span>
                <span class="c1">//包裹这个区间</span>
                <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//如果newInterval的终点小于某个区间的起点，那么就和前一个区间比较</span>
            <span class="k">if</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="c1">//前一个区间的起点肯定是大于newInterval的终点的，如果newInterval的终点小于这个区间，就更新</span>
                <span class="c1">//把这个区间包裹进来</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]){</span>
                    <span class="n">newInterval</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newInterval</span><span class="o">);</span>
        <span class="c1">//将剩余的区间加入结果集</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()][</span><span class="mi">2</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="58-最后一个单词的长度">58. 最后一个单词的长度</h2><p>给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLastWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">trim</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">' '</span><span class="o">)</span>    <span class="k">break</span><span class="o">;</span>
            <span class="n">res</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump60"></span></p><h2 id="60-第k个排列tag">60. 第k个排列[tag]</h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="s">"123"</span>
<span class="s">"132"</span>
<span class="s">"213"</span>
<span class="s">"231"</span>
<span class="s">"312"</span>
<span class="s">"321"</span>
</pre></table></code></div></div><p>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><ul><li>给定 n 的范围是 [1, 9]。</li><li>给定 k 的范围是[1, n!]。</li></ul><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="s">"213"</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">9</span>
<span class="nl">输出:</span> <span class="s">"2314"</span>
</pre></table></code></div></div><p>容易得知<code class="language-plaintext highlighter-rouge">[1,n]</code>中的每个元素为开头的序列有<code class="language-plaintext highlighter-rouge">n-1!</code>个。</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>假设n = 4, k = 9，先排列第一个元素。
1开头的排列有3! = 6种，
2开头的排列有3! = 6种
6&lt; 9 &lt; 12，所以第一个元素为2。
所以可以得到映射关系为 x = 向下取整[(k-1) / (n-1)!] + 1。则所求元素为[1,n]中第x小的未使用元素
接下来需要更新k
因为第k个排列落在以元素2为开头的序列集合中，所以需要找到第k个排列在这个序列集合中的位置。
故 k = ((k-1) % (n-1)!) + 1;

至此,问题已经转换为 n = 3, k = 3，可排列集合为{1,3,4}的情况下，找到第k个排列。
以此类推，当n == 0时，代表排列完成。

现在没搞懂的是，为什么要用k-1，然后向下取整+1呢？直接向上取整反而不能通过，改天好好研究一下。打个tag吧

知道啦！
不妨设分子为 k，那么得到的公式可能是这样的：
    ai =  ⌊k / (n-1)!⌋ + 1

尝试使用以上公式计算 a1:
    （1）当 k &lt; (n-1)! 时，a1 = ⌊k / (n-1)!⌋ + 1 = 1，正确
    （2）当 k = (n-1)! 时，a1 = ⌊k / (n-1)!⌋ + 1 = 2，错误

而使用 ai =  ⌊(k-1) / (n-1)!⌋ + 1 却能正确处理这种情况
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPermutation</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
      <span class="c1">//第k次排列的开头元素为第x小的未使用元素</span>
      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">floor</span><span class="o">((</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)*</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">levelMul</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

      <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="c1">//找到第x小的未使用元素index</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
          <span class="n">x</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">){</span>
          <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
          <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>

      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
      <span class="c1">//缩小规模</span>
      <span class="n">k</span> <span class="o">=</span> <span class="o">((</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">levelMul</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
      <span class="n">n</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="nc">StringBuffer</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">i</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
      <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kt">int</span> <span class="nf">levelMul</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
      <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">levelMul</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>拓展：</p><p><a href="https://blog.csdn.net/wbin233/article/details/72998375">康托展开和逆康托展开</a></p><p><span id="jump61"></span></p><h2 id="61-旋转链表">61. 旋转链表</h2><p>给你一个链表的头节点 <code class="language-plaintext highlighter-rouge">head</code> ，旋转链表，将链表每个节点向右移动 <code class="language-plaintext highlighter-rouge">k</code> 个位置。</p><p><strong>示例 1：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
</pre></table></code></div></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code class="language-plaintext highlighter-rouge">[0, 500]</code> 内</li><li><code class="language-plaintext highlighter-rouge">-100 &lt;= Node.val &lt;= 100</code></li><li><code class="language-plaintext highlighter-rouge">0 &lt;= k &lt;= 2 * 109</code></li></ul><p>可以直接将链表闭合，然后移动指针找到需要断开的位置。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//对K取模，然后找到链表第 n - k个节点，接到链表的尾部即可</span>
        <span class="c1">//先统计链表长度</span>
        <span class="nc">ListNode</span> <span class="n">fakeHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
        <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">fakeHead</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">n</span><span class="o">++;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//保存链表尾部引用</span>
        <span class="nc">ListNode</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">fakeHead</span><span class="o">;</span>
        
        
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span>
        <span class="c1">//定位到需要断开的节点</span>
        <span class="k">while</span><span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">c</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump62"></span></p><h2 id="62不同路径">62.不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="mi">3</span>
<span class="nl">解释:</span>
<span class="n">从左上角开始</span><span class="err">，</span><span class="n">总共有</span> <span class="mi">3</span> <span class="n">条路径可以到达右下角</span><span class="err">。</span>

<span class="mi">1</span><span class="o">.</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向下</span>
<span class="mi">2</span><span class="o">.</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向下</span> <span class="o">-&gt;</span> <span class="n">向右</span>
<span class="mi">3</span><span class="o">.</span> <span class="n">向下</span> <span class="o">-&gt;</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向右</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="mi">28</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10 ^ 9</li></ul><p>简单的动态规划</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//dp[i][j]表示，走到第(i,j)个网格有几种方法</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
      
        <span class="c1">//初始条件</span>
        <span class="c1">//当j = 1时，只能由dp[i-1][j]向下走一步而来</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//当i = 1时，只能由dp[i][j-1]向右走一步而来</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//dp[i][j]的值可能由dp[i-1][j]向下走一步，或者dp[i][j-1]向右走一步而来</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump63"></span></p><h2 id="63含障碍物网格中的不同路径">63.含障碍物网格中的不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code class="language-plaintext highlighter-rouge">1</code> 和 <code class="language-plaintext highlighter-rouge">0</code> 来表示。</p><p><strong>说明：</strong> <em>m</em>和 <em>n</em> 的值均不超过 100。</p><p>示例：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
<span class="p">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
<span class="p">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</pre></table></code></div></div><h3 id="动态规划">动态规划</h3><p>设<code class="language-plaintext highlighter-rouge">c[i][j]</code>代表从<code class="language-plaintext highlighter-rouge">(0,0)</code>网格走到<code class="language-plaintext highlighter-rouge">(i,j)</code>网格有几种走法，其状态方程为：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>c<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span> = 0 											if obstacleGrid<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span> == 1,
c<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span> = c<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span> + c<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">j-1</span><span class="p">]</span> 	if obstacleGrid<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">j</span><span class="p">]</span> == 0
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePathsWithObstacles</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">obstacleGrid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
      <span class="c1">//边界判断</span>
        <span class="n">c</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">c</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">c</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
			<span class="c1">//状态转移</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>

        <span class="k">return</span> <span class="n">c</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{</span>
                <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">().</span><span class="na">uniquePathsWithObstacles</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump64"></span></p><h2 id="64最小路径和">64.最小路径和</h2><p>给定一个包含非负整数的 <code class="language-plaintext highlighter-rouge">*m* x *n*</code> 网格 <code class="language-plaintext highlighter-rouge">grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">7</span>
<span class="n">解释</span><span class="err">：</span><span class="n">因为路径</span> <span class="mi">1</span><span class="err">→</span><span class="mi">3</span><span class="err">→</span><span class="mi">1</span><span class="err">→</span><span class="mi">1</span><span class="err">→</span><span class="mi">1</span> <span class="n">的总和最小</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">12</span>
</pre></table></code></div></div><p>提示：</p><ul><li><code class="language-plaintext highlighter-rouge">m == grid.length</code></li><li><code class="language-plaintext highlighter-rouge">n == grid[i].length</code></li><li><code class="language-plaintext highlighter-rouge">1 &lt;= m, n &lt;= 200</code></li><li><code class="language-plaintext highlighter-rouge">0 &lt;= grid[i][j] &lt;= 100</code></li></ul><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">minPathSum</span><span class="p">(</span><span class="n">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    
    <span class="k">var</span> <span class="n">m</span> <span class="kt">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">var</span> <span class="n">n</span> <span class="kt">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
  	<span class="c">//动态数组声明，太麻烦了吧</span>
    <span class="n">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">//边界初始化</span>
    <span class="n">dp</span><span class="p">[</span><span class="m">0</span><span class="p">][</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="m">0</span><span class="p">][</span><span class="m">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">][</span><span class="m">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="m">0</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="m">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="m">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="m">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span><span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mymin</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="m">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
<span class="p">}</span>
<span class="c">//还得自己写min，因为不支持函数重载，所以math包里只支持float64的min和max，美其名曰保持简洁干净？</span>
<span class="k">func</span> <span class="n">mymin</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//dp[i][j]表示从grid[0][0]走到grid[i][j]的最小路径和</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">//边界初始化</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="65-有效数字">65. 有效数字</h2><p>有效数字（按顺序）可以分成以下几个部分：</p><p>一个 小数 或者 整数 （可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分：</p><p>（可选）一个符号字符（’+’ 或 ‘-‘） 下述格式之一： 至少一位数字，后面跟着一个点 ‘.’ 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 一个点 ‘.’ ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分：</p><p>（可选）一个符号字符（’+’ 或 ‘-‘） 至少一位数字 部分有效数字列举如下：</p><p>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”] 部分无效数字列举如下：</p><p>[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”] 给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。</p><p>符合条件的整数格式为 <code class="language-plaintext highlighter-rouge">A[.[B][e|EC]]</code>或<code class="language-plaintext highlighter-rouge">.[B][e|EC]</code>。</p><p>先扫描整数部分，然后越过小数点，扫描小数部分，然后越过e，扫描指数部分。</p><p>其中，整数部分和指数部分可为有符号数，小数部分为无符号数。</p><p>扫描时，无符号数的扫描必须至少扫描到一个数字。</p><p>如果存在小数点，整数部分A可以为空。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//数字的格式：A[.B][E|eC]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">trim</span><span class="o">();</span>
        <span class="c1">//扫描整数部分</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">scanInteger</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="c1">//扫描小数部分</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'.'</span><span class="o">){</span>
                <span class="n">cur</span><span class="o">++;</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">scanUnsignedInteger</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">||</span> <span class="n">flag</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>   <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
            <span class="c1">//扫描指数部分</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'E'</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'e'</span><span class="o">){</span>
                <span class="n">cur</span><span class="o">++;</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">scanInteger</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">scanInteger</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">|</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'-'</span><span class="o">){</span>
            <span class="n">cur</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">scanUnsignedInteger</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">scanUnsignedInteger</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span> <span class="o">++</span><span class="n">i</span><span class="o">);</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="c1">//至少要扫描到一个数字</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">start</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="66-加一">66. 加一</h2><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">plusOne</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">digits</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
            <span class="n">digits</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">digits</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">digits</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">digits</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">digits</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">digits</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">digits</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">digits</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump67"></span></p><h2 id="67二进制求和">67.二进制求和</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code class="language-plaintext highlighter-rouge">1</code> 和 <code class="language-plaintext highlighter-rouge">0</code></p><p>示例 1:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: a = "11", b = "1"
输出: "100"
</pre></table></code></div></div><p>示例 2:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: a = "1010", b = "1011"
输出: "10101"
</pre></table></code></div></div><p>提示：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>每个字符串仅由字符 '0' 或 '1' 组成。
1 &lt;= a.length, b.length &lt;= 10^4
字符串如果不是 "0" ，就都不含前导零。
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">addBinary</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//如果a的长度小于b，则交换a和b，保证a的长度总是最长的</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//填充b</span>
        <span class="nc">String</span> <span class="n">pz</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pz</span> <span class="o">+=</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">pz</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
        <span class="c1">//进位标志</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">ca</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">a</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="mi">48</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">cb</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">b</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="mi">48</span><span class="o">;</span>

            <span class="k">switch</span> <span class="o">(</span><span class="n">ca</span> <span class="o">+</span> <span class="n">cb</span> <span class="o">+</span> <span class="n">c</span><span class="o">){</span>
                <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="s">"0"</span> <span class="o">+</span> <span class="n">res</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="s">"1"</span> <span class="o">+</span> <span class="n">res</span><span class="o">;</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="s">"0"</span> <span class="o">+</span> <span class="n">res</span><span class="o">;</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="s">"1"</span> <span class="o">+</span> <span class="n">res</span><span class="o">;</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="s">"1"</span><span class="o">+</span><span class="n">res</span><span class="o">;</span>
        <span class="c1">//System.out.println(b);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"1010"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"1011"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">().</span><span class="na">addBinary</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">addBinary</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuffer</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()),</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">carry</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">?</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">carry</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">?</span> <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">carry</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">+</span> <span class="sc">'0'</span><span class="o">));</span>
            <span class="n">carry</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'1'</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">ans</span><span class="o">.</span><span class="na">reverse</span><span class="o">();</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="69-x-的平方根">69. x 的平方根</h2><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">mySqrt</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="c1">//二分法求平方根</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="o">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">mid</span> <span class="o">==</span> <span class="n">mid</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">mid</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump70"></span></p><h2 id="70-爬楼梯">70. 爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span> <span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span> <span class="n">有两种方法可以爬到楼顶</span><span class="err">。</span>

<span class="mi">1</span><span class="o">.</span>  <span class="mi">1</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">阶</span>
<span class="mi">2</span><span class="o">.</span>  <span class="mi">2</span> <span class="n">阶</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span> <span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span> <span class="n">有三种方法可以爬到楼顶</span><span class="err">。</span>

<span class="mi">1</span><span class="o">.</span>  <span class="mi">1</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">阶</span>
<span class="mi">2</span><span class="o">.</span>  <span class="mi">1</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">阶</span>
<span class="mi">3</span><span class="o">.</span>  <span class="mi">2</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">阶</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">climbStairs</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//斐波那契数列</span>

        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>进阶：不能连续爬两步，即有一次跳了2步，下一次就不能跳2步了</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">维护dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span><span class="n">和dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span><span class="err">，</span><span class="n">表示</span>
<span class="n">第i次爬楼跳1步可以从上一次爬楼跳1步而来</span><span class="err">，</span><span class="n">也可以从上一次爬楼跳2步而来</span>
<span class="n">而第i次爬楼跳2步只能从上一次爬楼跳1步而来</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><h2 id="71-简化路径">71. 简化路径</h2><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/’ 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’//’）都被视为单个斜杠 ‘/’ 。 对于此问题，任何其他格式的点（例如，’…‘）均被视为文件/目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><p>始终以斜杠 ‘/’ 开头。 两个目录名之间必须只有一个斜杠 ‘/’ 。 最后一个目录名（如果存在）不能 以 ‘/’ 结尾。 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。 返回简化后得到的 规范路径 。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">simplifyPath</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//是一个绝对路径</span>
        <span class="c1">//多个连续斜杠只保留一个</span>
        <span class="c1">//遇到.就忽略</span>
        <span class="c1">//遇到..就返回上一级</span>
        <span class="c1">//遇到...代表目录或者文件的名称，可以保留</span>
        <span class="k">if</span><span class="o">(</span><span class="n">path</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span><span class="o">){</span><span class="c1">//遇到了斜杠</span>
                <span class="c1">//跳过所有连续的斜杠</span>
                <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'/'</span><span class="o">){</span>
                    <span class="n">idx</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//遇到字母或者点连在一起的，那就认为是目录名</span>
                <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
                <span class="c1">//遍历直到遇到斜杠</span>
                <span class="k">while</span><span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'/'</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'.'</span><span class="o">)</span>   <span class="n">cnt</span><span class="o">++;</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span><span class="o">));</span>
                    <span class="n">start</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="c1">//如果只遍历了一个点就遇到斜杠了，那就不操作</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">-</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>

                <span class="o">}</span>
                <span class="c1">//如果遍历了两个点遇到了斜杠，那就回退一级</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">-</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>    <span class="n">names</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//如果遇到了三个点，或者遇到了点和字符的组合，就作为目录名记录</span>
                    <span class="n">names</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'/'</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">names</span><span class="o">){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'/'</span><span class="o">);</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump72"></span></p><h2 id="72-编辑距离">72. 编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符 删除一个字符 替换一个字符</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">word1</span> <span class="o">=</span> <span class="s">"horse"</span><span class="o">,</span> <span class="n">word2</span> <span class="o">=</span> <span class="s">"ros"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">horse</span> <span class="o">-&gt;</span> <span class="n">rorse</span> <span class="o">(</span><span class="n">将</span> <span class="sc">'h'</span> <span class="n">替换为</span> <span class="sc">'r'</span><span class="o">)</span>
<span class="n">rorse</span> <span class="o">-&gt;</span> <span class="n">rose</span> <span class="o">(</span><span class="n">删除</span> <span class="sc">'r'</span><span class="o">)</span>
<span class="n">rose</span> <span class="o">-&gt;</span> <span class="n">ros</span> <span class="o">(</span><span class="n">删除</span> <span class="sc">'e'</span><span class="o">)</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">word1</span> <span class="o">=</span> <span class="s">"intention"</span><span class="o">,</span> <span class="n">word2</span> <span class="o">=</span> <span class="s">"execution"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">intention</span> <span class="o">-&gt;</span> <span class="n">inention</span> <span class="o">(</span><span class="n">删除</span> <span class="sc">'t'</span><span class="o">)</span>
<span class="n">inention</span> <span class="o">-&gt;</span> <span class="n">enention</span> <span class="o">(</span><span class="n">将</span> <span class="sc">'i'</span> <span class="n">替换为</span> <span class="sc">'e'</span><span class="o">)</span>
<span class="n">enention</span> <span class="o">-&gt;</span> <span class="n">exention</span> <span class="o">(</span><span class="n">将</span> <span class="sc">'n'</span> <span class="n">替换为</span> <span class="sc">'x'</span><span class="o">)</span>
<span class="n">exention</span> <span class="o">-&gt;</span> <span class="n">exection</span> <span class="o">(</span><span class="n">将</span> <span class="sc">'n'</span> <span class="n">替换为</span> <span class="sc">'c'</span><span class="o">)</span>
<span class="n">exection</span> <span class="o">-&gt;</span> <span class="n">execution</span> <span class="o">(</span><span class="n">插入</span> <span class="sc">'u'</span><span class="o">)</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= word1.length, word2.length &lt;= 500</li><li><p>word1 和 word2 由小写英文字母组成</p><p>1.对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。 例如当单词 A 为 doge，单词 B 为 dog 时， 1.我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog， 2.也可以在单词 B 末尾添加一个字符 e，得到相同的 doge； 2.同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的； 3.对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。 例如当单词 A 为 bat，单词 B 为 cat 时， 1.我们修改单词 A 的第一个字母 b -&gt; c， 2.和修改单词 B 的第一个字母 c -&gt; b 是等价的。</p><p>这样一来，本质不同的操作实际上只有三种： 1.在单词 A 中插入一个字符； 2.在单词 B 中插入一个字符； 3.修改单词 A 的一个字符。</p></li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">//dp[i][j]表示A的前i个字符到B的前j个字符的最小编辑距离</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="c1">//边界初始化</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="c1">//如果A的第i个字符和B的第j个字符不相同</span>
                <span class="c1">//A前i个字符到B的前j个字符的最小编辑距离可以从</span>
                <span class="c1">//  B的前j-1个字符后添加一个与A的第i个字符相同的字符得到A的前i个字符dp[i][j-1] + 1</span>
                <span class="c1">//  A的前i-1个字符后添加一个与B的第j个字符相同的字符得到B的前j个字符dp[i-1][j] + 1</span>
                <span class="c1">//  修改A的第i个字符为B的第j个字符使二者相同，dp[i-1][j-1] + 1</span>
                <span class="c1">//如果A的第i个字符和B的第j个字符相同</span>
                <span class="c1">//  B的前j-1个字符后添加一个与A的第i个字符相同的字符得到A的前i个字符dp[i][j-1] + 1</span>
                <span class="c1">//  A的前i-1个字符后添加一个与B的第j个字符相同的字符得到B的前j个字符dp[i-1][j] + 1</span>
                <span class="c1">// 不用修改第i个字符为B的第j个字符，二者已经相同，dp[i-1][j-1]</span>
                <span class="k">if</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]));</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]-</span><span class="mi">1</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump73"></span></p><h2 id="73-矩阵置零">73. 矩阵置零</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
<span class="o">[</span>
  <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="o">]</span>
<span class="nl">输出:</span> 
<span class="o">[</span>
  <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>进阶:</p><ul><li>一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个常数空间的解决方案吗？</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setZeroes</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">row0</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">col0</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//用两个变量额外保存第一行和第一列的状态</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">col0</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">row0</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//用矩阵的第一行和第一列来保存状态</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)){</span>
                    <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">row0</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">col0</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>


    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump74"></span></p><h2 id="74-搜索二维矩阵">74. 搜索二维矩阵</h2><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。</p><p><strong>示例 1：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">matrix</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">20</span><span class="o">],[</span><span class="mi">23</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="mi">34</span><span class="o">,</span><span class="mi">60</span><span class="o">]],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">searchMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">||</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">matrix</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//行首二分</span>
        <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="o">((</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">mid</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">mid</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">low</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">target</span> <span class="o">?</span> <span class="n">low</span> <span class="o">:</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//行内二分</span>
        <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="o">((</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump75"></span></p><h2 id="75颜色分类">75.颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意: 不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>进阶：</p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><p>计数排序</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sortColors</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="n">a</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="n">b</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>    <span class="n">c</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">a</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">b</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
                <span class="n">c</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>    
<span class="o">}</span>
</pre></table></code></div></div><p>一趟partition，把0都放到左边，1都放到右边，数字2放完之后，这个位置还需要被遍历一次，所以<code class="language-plaintext highlighter-rouge">i--</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sortColors</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">low</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">++]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
                  	<span class="c1">//交换过来的数字不确定，所以需要再判断一次这个位置</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">--]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">high</span><span class="o">--]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>   
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump76"></span></p><h2 id="76-最小覆盖子串">76. 最小覆盖子串</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"ADOBECODEBANC"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"ABC"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"BANC"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"a"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length, t.length &lt;= 105</li><li>s 和 t 由英文字母组成</li></ul><p>进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？</p><p>滑动窗口</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">minWindow</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">st</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">st</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">map1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">map1</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//从左往右遍历字符串，先找到一个符合条件的子串</span>
        <span class="c1">//再滑动窗口寻找下一个子串，如果长度更小就记录</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">sl</span><span class="o">){</span>
            <span class="c1">//刚开始遍历，需要找到一个左端点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">sl</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">map1</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">))){</span>
                    <span class="n">l</span><span class="o">++;</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//找到了第一个左端点</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">//s中找到的字符数还不够</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">check</span><span class="o">(</span><span class="n">map1</span><span class="o">,</span> <span class="n">map2</span><span class="o">)){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">sl</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
                <span class="c1">//当前字符不是有效字符</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">map1</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))){</span>
                    <span class="n">r</span><span class="o">++;</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span><span class="c1">//是有效字符，放入哈希表中，无论是不是新的字符，都要放入</span>
                    <span class="n">map2</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="n">map2</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="n">r</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//s中找到的字符种类已经覆盖了t字符串中的所有字符</span>
                <span class="c1">//当前结果是一个满足要求的子串</span>
                <span class="k">if</span><span class="o">(</span><span class="n">end</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span><span class="c1">//如果这是第一个子串</span>
                    <span class="c1">//直接记录</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//需要比较当前找到的是否为更小的子串</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">){</span>
                        <span class="c1">//更新</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">//移动左指针，直至map2无法cover map1</span>
                <span class="k">while</span><span class="o">(</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">map1</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">))){</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">map1</span><span class="o">,</span> <span class="n">map2</span><span class="o">)){</span>
                            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">){</span>
                                <span class="c1">//更新</span>
                                <span class="n">start</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                                <span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="n">map2</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">map2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">))</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                            <span class="n">l</span><span class="o">++;</span>
                        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">l</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">sl</span><span class="o">)</span>  <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">end</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map2</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map1</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">map2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">map2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">map1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">))){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">minWindow</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">st</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">st</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">map1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">map1</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//从左往右遍历字符串，先找到一个符合条件的子串</span>
        <span class="c1">//再滑动窗口寻找下一个子串，如果长度更小就记录</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">sl</span><span class="o">){</span>
          	<span class="c1">//窗口不断往右移动</span>
            <span class="o">++</span><span class="n">r</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">sl</span> <span class="o">&amp;&amp;</span> <span class="n">map1</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">)))</span>
                <span class="n">map2</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="n">map2</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
          	<span class="c1">//如果已经实现了覆盖，就从左边缩小窗口</span>
          	<span class="c1">//每缩小一步，都需要判断是否仍能覆盖</span>
            <span class="k">while</span><span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">map1</span><span class="o">,</span> <span class="n">map2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">){</span>
                    <span class="n">len</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map1</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)))</span>
                    <span class="n">map2</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">map2</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">++</span><span class="n">l</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>


        <span class="k">return</span> <span class="n">end</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span> 
        <span class="k">while</span> <span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span> 
            <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="n">iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> 
            <span class="nc">Character</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Character</span><span class="o">)</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span> 
            <span class="nc">Integer</span> <span class="n">val</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">map2</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> 
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump77"></span></p><h2 id="77组合tag字典序">77.组合[tag:字典序]</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span>
<span class="o">[</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span>
<span class="o">]</span>
</pre></table></code></div></div><h3 id="回溯法-2">回溯法</h3><p>先固定第i位，然后将i+1~n位的数都与其交换位置，这里不是数组，所以直接+1。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">k</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combine</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span>  <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">backTrack</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//先固定第i位，然后将i+1~n位的数都与其交换位置，这里不是数组，所以直接+1</span>
    <span class="kt">void</span> <span class="nf">backTrack</span><span class="o">(</span><span class="kt">int</span> <span class="n">cur</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">tmp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">x</span><span class="o">[</span><span class="n">cnt</span><span class="o">++]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">backTrack</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">x</span><span class="o">[--</span><span class="n">cnt</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在记录结果的时候，以下代码为什么会更慢呢？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">tmp</span><span class="o">,</span><span class="n">x</span><span class="o">);</span>
<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
</pre></table></code></div></div><p>按理来说，库函数的执行效率会比我自己实现的逐个添加会高一些的。但是这里却慢了许多。</p><p><a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/">字典序解法</a></p><p>字典序出现好多次了，还是没搞懂，下回得好好弄弄。</p><p><span id="jump78"></span></p><h2 id="78子集">78.子集</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: nums = [1,2,3] 输出:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="o">[</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
  <span class="o">[]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>回溯的典型题。只需要遍历所有长度的子集，然后回溯长度为<code class="language-plaintext highlighter-rouge">len</code>的子集的所有可能性即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//控制子集的长度</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">len</span><span class="o">){</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">len</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="o">,</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">len</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//回溯添加长度为len的子集</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">len</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump79"></span></p><h2 id="79单词搜索">79.单词搜索</h2><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">board</span> <span class="o">=</span>
<span class="o">[</span>
  <span class="o">[</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'B'</span><span class="o">,</span><span class="sc">'C'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">],</span>
  <span class="o">[</span><span class="sc">'S'</span><span class="o">,</span><span class="sc">'F'</span><span class="o">,</span><span class="sc">'C'</span><span class="o">,</span><span class="sc">'S'</span><span class="o">],</span>
  <span class="o">[</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'D'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">]</span>
<span class="o">]</span>

<span class="n">给定</span> <span class="n">word</span> <span class="o">=</span> <span class="s">"ABCCED"</span><span class="o">,</span> <span class="n">返回</span> <span class="kc">true</span>
<span class="n">给定</span> <span class="n">word</span> <span class="o">=</span> <span class="s">"SEE"</span><span class="o">,</span> <span class="n">返回</span> <span class="kc">true</span>
<span class="n">给定</span> <span class="n">word</span> <span class="o">=</span> <span class="s">"ABCB"</span><span class="o">,</span> <span class="n">返回</span> <span class="kc">false</span>
</pre></table></code></div></div><p>提示：</p><ul><li>board 和 word 中只包含大写和小写英文字母。</li><li>1 &lt;= board.length &lt;= 200</li><li>1 &lt;= board[i].length &lt;= 200</li><li>1 &lt;= word.length &lt;= 10^3</li></ul><p>深搜</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//boolean flag;</span>
    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">exist</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">word</span><span class="o">)){</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                  <span class="c1">//if(flag)	return true;</span>
                <span class="o">}</span>
                    
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span> <span class="o">,</span><span class="nc">String</span> <span class="n">word</span><span class="o">){</span>
        <span class="c1">//</span>
        <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">!=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          	<span class="c1">//flag = true;</span>
        <span class="o">}</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">direction</span> <span class="o">=</span> <span class="o">{</span><span class="err">\</span><span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},{</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">},{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},{-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span><span class="err">\</span><span class="o">};</span>

        <span class="c1">//向四个方向搜索，若找到答案就返回true</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            
            <span class="c1">//新位置的合法性判别</span>
            <span class="k">if</span><span class="o">(</span><span class="n">new_x</span> <span class="o">&lt;</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">new_y</span> <span class="o">&lt;</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">new_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_y</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="o">[</span><span class="n">new_x</span><span class="o">][</span><span class="n">new_y</span><span class="o">]){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">new_x</span><span class="o">,</span><span class="n">new_y</span><span class="o">,</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">word</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
              	<span class="c1">//dfs(board,new_x,new_y,cur+1,word);</span>
              	<span class="c1">//if(flag) break;</span>
            <span class="o">}</span>
                
        <span class="o">}</span>
        <span class="c1">//回溯</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="80-删除有序数组中的重复项-ii">80. 删除有序数组中的重复项 II</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//每个数字最多出现2次，返回删除后的数组长度</span>
        <span class="c1">//原地修改</span>
        <span class="c1">//双指针，右指针遍历找数字，左指针记录填充的位置</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">==</span> <span class="n">cur</span><span class="o">){</span>
                <span class="n">cnt</span><span class="o">++;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">){</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="n">r</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">l</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="81-搜索旋转排序数组-ii">81. 搜索旋转排序数组 II</h2><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">//做这类题目，只要抓住两个重点</span>
        <span class="c1">//1. 左边是一个上升区间，右边是一个上升区间</span>
        <span class="c1">//2. 右边界一定是小于等于左边的最小元素，大于等于右边的最大元素</span>
        <span class="c1">//只需要根据上述条件，决定区间该往哪边缩小即可。</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="o">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="cm">/*
            如果出现nums[l] == nums[r] == nums[mid]的情况
            我们无法判断[l,mid]和[mid,r]区间哪个是有序的
            所以只能缩减边界，然后重新二分
            */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                <span class="o">++</span><span class="n">l</span><span class="o">;</span>
                <span class="o">--</span><span class="n">r</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span><span class="c1">//如果mid小于等于右边界，说明mid在右边那个上升区间内</span>
                <span class="c1">//如果target &gt; nums[mid]并且target小于等于nums[r]，说明target是在右边那个上升区间内</span>
                <span class="c1">//否则有可能在右边那个上升区间内，也可能在左边那个上升区间内</span>
                <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]){</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump82"></span></p><h2 id="82-删除排序链表中的重复元素-ii">82. 删除排序链表中的重复元素 II</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span>
<span class="nl">输出:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">5</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">deleteDuplicates</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">//是一个排序链表，那就从头节点开始，依次删除与当前节点重复的下一个节点即可</span>
        <span class="nc">ListNode</span> <span class="n">fakeHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
        <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">fakeHead</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">){</span><span class="c1">//执行删除</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">flag</span><span class="o">){</span>
                <span class="c1">//keep pre</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//move pre</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump83"></span></p><h2 id="83-删除排序链表中的重复元素">83. 删除排序链表中的重复元素</h2><p>存在一个按升序排列的链表，给你这个链表的头节点 <code class="language-plaintext highlighter-rouge">head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p><p>返回同样按升序排列的结果链表。</p><p><strong>示例 2：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">deleteDuplicates</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">pre</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump84"></span></p><h2 id="84-柱状图中最大的矩形">84. 柱状图中最大的矩形</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20201219141243827.png" alt="image-20201219141243827" style="zoom:67%;" /></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20201219141334854.png" alt="image-20201219141334854" style="zoom:67%;" /></p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">10</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//枚举矩形的高度，然后向两边扩展找到第一个小于该高度的元素，就能求出此高度对应的最大面积了</span>
    <span class="c1">//使用单调栈查找</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">largestRectangleArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">heights</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">heights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//记录当前高度左边 第一个小于此高度的索引</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">//记录当前高度右边 第一个小于此高度的索引</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//栈中比当前高度大的都出栈</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&gt;=</span> <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">//记录左边第一个比当前高度小的位置索引，如果没有，就记-1</span>
            <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="c1">//当前高度入栈</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">stack</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&gt;=</span> <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">//记录右边第一个比当前高度小的位置索引，如果没有，就记n</span>
            <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
				<span class="c1">//算面积</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="o">(</span><span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>优化：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
<span class="kd">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="nf">largestRectangleArea</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">heights</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">heights</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">left</span><span class="o">(</span><span class="n">n</span><span class="o">),</span> <span class="n">right</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        
        <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mono_stack</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">mono_stack</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="o">[</span><span class="n">mono_stack</span><span class="o">.</span><span class="na">top</span><span class="o">()]</span> <span class="o">&gt;=</span> <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">mono_stack</span><span class="o">.</span><span class="na">top</span><span class="o">()]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="n">mono_stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">mono_stack</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">mono_stack</span><span class="o">.</span><span class="na">top</span><span class="o">());</span>
            <span class="n">mono_stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="o">(</span><span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">};</span>

</pre></table></code></div></div><p><span id="jump85"></span></p><h2 id="85-最大矩形">85. 最大矩形</h2><p>给定一个仅包含 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 、大小为 <code class="language-plaintext highlighter-rouge">rows x cols</code> 的二维二进制矩阵，找出只包含 <code class="language-plaintext highlighter-rouge">1</code> 的最大矩形，并返回其面积。</p><p>示例1:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20201221142217366.png" alt="image-20201221142217366" style="zoom:50%;" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">matrix</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">],[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">],[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">],[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="n">最大矩形如上图所示</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>rows == matrix.length</li><li>cols == matrix[0].length</li><li>0 &lt;= row, cols &lt;= 200</li><li><code class="language-plaintext highlighter-rouge">matrix[i][j]</code> 为 ‘0’ 或 ‘1’</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximalRectangle</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">maxarea</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">//动态规划：dp[i][j]表示第i行中，第j个元素为结尾的矩阵最大宽度</span>
        <span class="c1">//我们枚举每一行的每个点的最大宽度，然后向上探索</span>
        <span class="c1">//实际上就是求以当前点开始，到上边界的最大矩形宽度序列组成的矩形能够得到的最大面积</span>
        <span class="c1">//例如：</span>
        <span class="c1">//  ***[***]...</span>
        <span class="c1">//  ---[***]...</span>
        <span class="c1">//  --*[***]...</span>
        <span class="c1">//  --*[***]...</span>
        <span class="c1">//  ... ...</span>
        <span class="c1">//括号扩起来的就是最大的面积了</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span><span class="o">){</span>
                    <span class="c1">//计算以当前点为右下角的矩阵的最大宽度</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                    <span class="c1">//找到最大的面积，遍历每个宽度，计算面积</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">k</span><span class="o">){</span>
                        <span class="n">width</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">width</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                        <span class="n">maxarea</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxarea</span><span class="o">,</span> <span class="n">width</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxarea</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>以84题的思路，可以用栈来优化，以行为底边建立柱状图，上面那个方法是以列为底边建立柱状图。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximalRectangle</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">maxarea</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">//利用84题的思路，用单调栈求柱形图的最大面积</span>
        <span class="c1">//按照行建立柱状图</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">maxarea</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxarea</span><span class="o">,</span> <span class="n">leetcode84</span><span class="o">(</span><span class="n">dp</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxarea</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kt">int</span> <span class="nf">leetcode84</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="c1">//遇到了一个更小的高度，就将栈顶的高度h弹出，并计算h对应的矩阵的面积 = h * (i - stack.peek() - 1)</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()]</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()]</span> <span class="o">*</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span>  <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>

        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump86"></span></p><h2 id="86分隔链表">86.分隔链表</h2><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">head</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">5</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">partition</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">fakeHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//pre用于指向小于x节点的子链表的尾部，cur用于指向当前节点的前一个节点</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">fakeHead</span><span class="o">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">fakeHead</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//越过所有大于等于x的节点</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">){</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//到达结尾了，结束遍历</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">//越过一开始就在正确位置的小于x的节点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">pre</span><span class="o">){</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//将小于x的节点插到前面去</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>

            <span class="c1">//向后移动指针</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="k">return</span> <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="88-合并两个有序数组">88. 合并两个有序数组</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sorted</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">];</span>


        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">p2</span><span class="o">]){</span>
                <span class="n">sorted</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">p1</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">sorted</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">p2</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">while</span><span class="o">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">){</span>
            <span class="n">sorted</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">p1</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p2</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">sorted</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">p2</span><span class="o">++];</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
            <span class="n">nums1</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">sorted</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="89-格雷编码">89. 格雷编码</h2><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p><p>格雷编码序列必须以 0 开头。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">grayCode</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="c1">//将n阶的格雷码推广到n+1阶，只需要将原来的序列逆序，然后再高位添1即可</span>
        <span class="cm">/*
        00          000
        01  ------&gt; 001
        11          011
        10          010
                    110
                    111
                    101
                    100
         */</span>
        <span class="kt">int</span> <span class="n">head</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="n">head</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump90"></span></p><h2 id="90-子集-ii">90. 子集 II</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
</pre></table></code></div></div><p><strong>提示：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">1 &lt;= nums.length &lt;= 10</code></li><li><code class="language-plaintext highlighter-rouge">-10 &lt;= nums[i] &lt;= 10</code></li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsetsWithDup</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//如何去重？</span>
    <span class="c1">//先排序，方便去重</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
    <span class="n">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//每个位置，同一个数字只允许出现一次</span>
  <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>

    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">));</span>

    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
      <span class="n">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
      <span class="c1">//回溯</span>
      <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="91-解码方法">91. 解码方法</h2><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; 1 ‘B’ -&gt; 2 … ‘Z’ -&gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6) “KJF” ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numDecodings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">//动态规划，dp[i]表示以第i个元素为结尾的字符串有多少种解码方案</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
      <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
      <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">'0'</span><span class="o">){</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
      <span class="o">}</span>
      <span class="c1">//只有当上一个字符不为0，而且两个字符组合的大小小于等于26，才能多一种编码方式</span>
      <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">))</span> <span class="o">&lt;=</span> <span class="mi">26</span><span class="o">){</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump92"></span></p><h2 id="92-反转链表-ii">92. 反转链表 II</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明: 1 ≤ m ≤ n ≤ 链表长度。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="no">NULL</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nl">输出:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="no">NULL</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseBetween</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">==</span> <span class="n">left</span><span class="o">)</span>   <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">fakeNead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
        <span class="n">fakeNead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">fakeNead</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span><span class="c1">//此时ptr已经指向了需要翻转部分的前一个节点</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">//开始翻转</span>
        <span class="k">while</span><span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">len</span><span class="o">--;</span>
        <span class="o">}</span>
				<span class="c1">//修改翻转部分的头尾指向</span>
        <span class="k">if</span><span class="o">(</span><span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">fakeNead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump93"></span></p><h2 id="93-恢复ip地址">93. 恢复IP地址</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 ‘.’ 分隔。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"25525511135"</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="s">"255.255.11.135"</span><span class="o">,</span> <span class="s">"255.255.111.35"</span><span class="o">]</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_恢复Ip地址.png" alt="leetcode_恢复Ip地址" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">leetcode</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"all"</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">RestoreIpAddresses</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="no">SEG_COUNT</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">segment</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">SEG_COUNT</span><span class="o">];</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">segId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">segStart</span><span class="o">){</span>
        <span class="c1">//找到了第四段地址</span>
        <span class="k">if</span><span class="o">(</span><span class="n">segId</span> <span class="o">==</span> <span class="no">SEG_COUNT</span><span class="o">){</span>
            <span class="c1">//已经遍历完字符串</span>
            <span class="k">if</span><span class="o">(</span><span class="n">segStart</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
                <span class="c1">//确定一种答案</span>
                <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SEG_COUNT</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">segment</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="no">SEG_COUNT</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
                        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"."</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//如果未找到第四段地址，字符串就已经遍历完，则回溯</span>
        <span class="k">if</span><span class="o">(</span><span class="n">segStart</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
            <span class="k">return</span><span class="o">;</span>

        <span class="c1">//如果有前导0，那么这个位置的segment只能为0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">segStart</span><span class="o">)==</span><span class="sc">'0'</span><span class="o">){</span>
            <span class="n">segment</span><span class="o">[</span><span class="n">segId</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">segId</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">segStart</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//一般情况</span>
        <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">segEnd</span> <span class="o">=</span> <span class="n">segStart</span><span class="o">;</span> <span class="n">segEnd</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">segEnd</span><span class="o">){</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">segEnd</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">addr</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;=</span> <span class="mh">0xFF</span><span class="o">){</span>
                <span class="n">segment</span><span class="o">[</span><span class="n">segId</span><span class="o">]</span> <span class="o">=</span> <span class="n">addr</span><span class="o">;</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">segId</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">segEnd</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"25525511135"</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestoreIpAddresses</span><span class="o">().</span><span class="na">solution</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>如果需要字符串拼接，定义StringBuffer会好很多。</li><li>但需要递归函数返回值时，最好不要直接用函数返回，定义一个全局变量来直接记录会好很多。</li><li>思考递归时，不要把问题划分的太细，要一次递归能够处理一个子问题。递归树的每条路径对应一种解法。像这题，我一开始想着从最后一个地址段开始，遍历所有情况，然后用返回值把字符串拼接起来，这种思维非常混乱。</li><li>写递归函数，先写满足要求的情况，即递归结束条件；再写特殊情况，最后写一般情况。</li></ul><p><span id="jump94"></span></p><h2 id="94二叉树的中序遍历">94.二叉树的中序遍历</h2><p>给定一个二叉树，返回它的中序 遍历。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
   <span class="mi">1</span>
    <span class="err">\</span>
     <span class="mi">2</span>
    <span class="o">/</span>
   <span class="mi">3</span>

<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">inorderTraversal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
  	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  	<span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>	<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  	<span class="c1">//Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();	用Deque比Stack快多了</span>
  	<span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
  	<span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
  	<span class="k">while</span><span class="o">(</span> <span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
      	<span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
          	<span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
          	<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
      	<span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
      	<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
      	<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>
  	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">Morris中序遍历</a></p><h2 id="95-不同的二叉搜索树-ii">95. 不同的二叉搜索树 II</h2><p>给你一个整数 <code class="language-plaintext highlighter-rouge">n</code> ，请你生成并返回所有由 <code class="language-plaintext highlighter-rouge">n</code> 个节点组成且节点值从 <code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>提示：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">1 &lt;= n &lt;= 8</code></li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="nf">generateTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">trees</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="n">trees</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">trees</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="cm">/**
            分治法，遍历每个数字作为根节点，然后左区间生成多个搜索树，右区间生成多个搜索树
            再组合链接在根节点上，不断地归并到l = 1, r = n，此时trees中就是所有的搜索树
             */</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">lefts</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">rights</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>

            <span class="k">for</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">:</span> <span class="n">lefts</span><span class="o">){</span>
                <span class="k">for</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">:</span> <span class="n">rights</span><span class="o">){</span>
                    <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
                    <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
                    <span class="n">trees</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">trees</span><span class="o">;</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump96"></span></p><h2 id="96-不同的二叉搜索树">96. 不同的二叉搜索树</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:</p><p>输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>   1         3     3      2      1
    <span class="se">\ </span>      /     /      / <span class="se">\ </span>     <span class="err">\</span>
     3     2     1      1   3      2
    /     /       <span class="se">\ </span>                <span class="err">\</span>
   2     1         2                 3
</pre></table></code></div></div><h3 id="分治递归">分治递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="n">numTrees</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">numTrees</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="不用递归的解法">不用递归的解法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="no">G</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="no">G</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="no">G</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">G</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="no">G</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="no">G</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">G</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="卡特兰数">卡特兰数</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 提示：我们在这里需要用 long 类型防止计算过程中的溢出</span>
        <span class="kt">long</span> <span class="no">C</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">C</span> <span class="o">=</span> <span class="no">C</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="no">C</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="97-交错字符串">97. 交错字符串</h2><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p><p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><ul><li>s = s1 + s2 + … + sn</li><li>t = t1 + t2 + … + tm</li><li><div class="table-wrapper"><table><tbody><tr><td>n - m<td>&lt;= 1</table></div></li><li>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …</li></ul><p>提示：a + b 意味着字符串 a 和 b 连接。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isInterleave</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s3</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//动态规划，dp[i][j]表示s1的前i个字符和s2的前j个字符能够交错组成s3的前i+j个字符</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span> <span class="o">!=</span> <span class="n">s3</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="c1">//初始化边界, j == 0</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s3</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span>    <span class="k">break</span><span class="o">;</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//初始化边界，i == 0</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s3</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span>    <span class="k">break</span><span class="o">;</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="cm">/**
                如果s1的第i个字符和s3的第i+j-1个字符相同，
                那么问题就转化为s1的前i-1个字符和s2的前j个字符能否交错成s3的前i+j-2个字符
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">s3</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">k</span><span class="o">)){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="cm">/**
                如果s2的第j个字符和s3的第i+j-1个字符相同，
                那么问题就转化为s2的前j-1个字符和s1的前i个字符能否交错成s3的前i+j-2个字符
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">s3</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">k</span><span class="o">)){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump98"></span></p><h2 id="98验证二叉搜索树">98.验证二叉搜索树</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:</p><p>输入:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="mi">2</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">1</span>   <span class="mi">3</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
    <span class="mi">5</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">1</span>   <span class="mi">4</span>
     <span class="o">/</span> <span class="err">\</span>
    <span class="mi">3</span>   <span class="mi">6</span>
<span class="nl">输出:</span> <span class="kc">false</span>
<span class="nl">解释:</span> <span class="nl">输入为:</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span><span class="err">。</span>
     <span class="n">根节点的值为</span> <span class="mi">5</span> <span class="err">，</span><span class="n">但是其右子节点值为</span> <span class="mi">4</span> <span class="err">。</span>
</pre></table></code></div></div><p>中序遍历，序列有序则符合要求。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">TreeNode</span> <span class="n">pre</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">inOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span> <span class="o">==</span> <span class="kc">true</span><span class="o">){</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span> <span class="o">==</span> <span class="kc">true</span><span class="o">){</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">flag</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span>
                    <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump100"></span></p><h2 id="100-相同的树">100. 相同的树</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>输入:       1         1
          / \       / \
         2   3     2   3
				[1,2,3],   [1,2,3]
输出: true
</pre></table></code></div></div><p>示例 2:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>输入:      1          1
          /           \
         2             2
    [1,2],     [1,null,2]
输出: false
</pre></table></code></div></div><p>示例 3:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>输入:       1         1
          / \       / \
          2   1     1   2
   		 [1,2,1],   [1,1,2]
输出: false
</pre></table></code></div></div><h3 id="深度优先">深度优先</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">q</span><span class="o">.</span><span class="na">left</span><span class="o">)&amp;&amp;</span><span class="n">isSameTree</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">q</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="广度优先">广度优先</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;();</span>
        <span class="n">queue1</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="n">queue2</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">queue2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">TreeNode</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">queue1</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="nc">TreeNode</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">queue2</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">node2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">TreeNode</span> <span class="n">left1</span> <span class="o">=</span> <span class="n">node1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">right1</span> <span class="o">=</span> <span class="n">node1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">left2</span> <span class="o">=</span> <span class="n">node2</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">right2</span> <span class="o">=</span> <span class="n">node2</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">^</span> <span class="n">left2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">right1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">^</span> <span class="n">right2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue1</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">left1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">right1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue1</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">right1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue2</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">left2</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">right2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue2</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">right2</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">queue1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">queue2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump101"></span></p><h2 id="101对称二叉树">101.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		1
   / \
  2   2
 / \ / \
3  4 4  3
</pre></table></code></div></div><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		1
   / \
  2   2
   \   \
   3    3
</pre></table></code></div></div><p>进阶：</p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><p>递归：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">compare</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root2</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">root2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">root1</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">root2</span><span class="o">.</span><span class="na">val</span>
        <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="o">(</span><span class="n">root1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">root2</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
        <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="o">(</span><span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">root2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>迭代：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//初始化队列</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
      	<span class="c1">//每次取两个节点出来比较</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">TreeNode</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="nc">TreeNode</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
          	<span class="c1">//如果这两个节点都为空，那么就继续比较</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">continue</span><span class="o">;</span>
          	<span class="c1">//如果有一者为空，或者两个节点值不等，就返回false</span>
            <span class="k">if</span><span class="o">((</span><span class="n">node1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">node2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="n">node1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">node2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
						<span class="c1">//按比较顺序入队</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node1</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
          
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node1</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump103"></span></p><h2 id="103-二叉树的锯齿形层序遍历">103. 二叉树的锯齿形层序遍历</h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如： 给定二叉树 [3,9,20,null,null,15,7],</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		3
   / \
  9  20
    /  \
   15   7
</pre></table></code></div></div><p>返回锯齿形层序遍历如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="o">[</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">20</span><span class="o">,</span><span class="mi">9</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">15</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">zigzagLevelOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="c1">//程序遍历，增加一个布尔变量用于判断当前遍历的是奇数层还是偶数层</span>
        <span class="c1">//如果是奇数层，那么正序遍历，如果是偶数层，则逆序遍历</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">even</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">even</span><span class="o">){</span>
                    <span class="c1">//正序添加</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//逆序添加</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">tmp</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
            <span class="c1">//奇偶替换</span>
            <span class="n">even</span> <span class="o">=</span> <span class="o">!</span><span class="n">even</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump105"></span></p><h2 id="105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		3
   / \
  9  20
    /  \
   15   7
</pre></table></code></div></div><p>可以解决有重复元素的树：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">build</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">inorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">TreeNode</span> <span class="nf">build</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pS</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pE</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">iS</span><span class="o">,</span> <span class="kt">int</span> <span class="n">iE</span><span class="o">){</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">pE</span> <span class="o">&lt;</span> <span class="n">pS</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">pS</span> <span class="o">==</span> <span class="n">pE</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">pS</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">pS</span><span class="o">]);</span>
        
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">iS</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">inorder</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
            <span class="o">++</span><span class="n">idx</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">pS</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">pS</span> <span class="o">+</span> <span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">iS</span><span class="o">),</span> <span class="n">inorder</span><span class="o">,</span> <span class="n">iS</span><span class="o">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">pS</span> <span class="o">+</span> <span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">iS</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">pE</span><span class="o">,</span> <span class="n">inorder</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">iE</span><span class="o">);</span>

        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">inMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//由于树中无重复元素，所以可以为每个元素建立哈希索引，后面可以直接在中序遍历序列中定位根节点</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">inMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">inorder</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="nf">build</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">inorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">TreeNode</span> <span class="nf">build</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pS</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pE</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">iS</span><span class="o">,</span> <span class="kt">int</span> <span class="n">iE</span><span class="o">){</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">pE</span> <span class="o">&lt;</span> <span class="n">pS</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">pS</span> <span class="o">==</span> <span class="n">pE</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">pS</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">pS</span><span class="o">]);</span>
        
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">inMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        
        <span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">pS</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">pS</span> <span class="o">+</span> <span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">iS</span><span class="o">),</span> <span class="n">inorder</span><span class="o">,</span> <span class="n">iS</span><span class="o">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">pS</span> <span class="o">+</span> <span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">iS</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">pE</span><span class="o">,</span> <span class="n">inorder</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">iE</span><span class="o">);</span>

        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump106"></span></p><h2 id="106从中序与后序遍历序列构造二叉树">106.从中序与后序遍历序列构造二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">中序遍历</span> <span class="n">inorder</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="n">后序遍历</span> <span class="n">postorder</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
</pre></table></code></div></div><p>返回如下的二叉树：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		3
   / \
  9  20
    /  \
   15   7
</pre></table></code></div></div><p>与剑指offer.07题类似，那个是前序加中序，这个是中序加后序。</p><p>几个注意点：</p><ul><li>要对中序序列的每个元素建立哈希索引，使得能够直接找到根节点位置。</li><li>然后计算左右子树的规模。</li><li>后序序列中，根节点的左子树应从序列的最左端开始统计，即<code class="language-plaintext highlighter-rouge">[po_low,po_low+leftNum-1]</code>，右子树应为根节点往左统计的<code class="language-plaintext highlighter-rouge">rightNum</code>个元素，即<code class="language-plaintext highlighter-rouge">[po_high-rightNum,po_high-1]</code>。</li></ul><p>重点就是在递归过程中，将对应的左右子树区间对应好。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">postorder</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">inMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//为中序遍历的每个元素建立哈希索引</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">inMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">inorder</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">inorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span><span class="n">inorder</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">postorder</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">postorder</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">inMap</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="nc">TreeNode</span> <span class="nf">build</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">in_low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">in_high</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">postorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">po_low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">po_high</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">inMap</span><span class="o">){</span>

        <span class="k">if</span><span class="o">(</span> <span class="n">po_low</span> <span class="o">&gt;</span> <span class="n">po_high</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//此时，后序遍历区间的最后一个元素是根节点</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">postorder</span><span class="o">[</span><span class="n">po_high</span><span class="o">]);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">po_low</span> <span class="o">==</span> <span class="n">po_high</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//需要在中序遍历区间内找到它的左右子树</span>
        
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">inMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">postorder</span><span class="o">[</span><span class="n">po_high</span><span class="o">]);</span>
        <span class="c1">//计算左右子树的规模</span>
        <span class="kt">int</span> <span class="n">leftNum</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">in_low</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">rightNum</span> <span class="o">=</span>  <span class="n">in_high</span> <span class="o">-</span> <span class="n">index</span><span class="o">;</span>

        <span class="c1">//递归重建左右子树</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">inorder</span><span class="o">,</span><span class="n">in_low</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">postorder</span><span class="o">,</span> <span class="n">po_low</span><span class="o">,</span> <span class="n">po_low</span> <span class="o">+</span> <span class="n">leftNum</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">inMap</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">inorder</span><span class="o">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">in_high</span><span class="o">,</span> <span class="n">postorder</span><span class="o">,</span> <span class="n">po_high</span> <span class="o">-</span> <span class="n">rightNum</span><span class="o">,</span> <span class="n">po_high</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">inMap</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump107"></span></p><h2 id="107-二叉树的层次遍历-ii">107. 二叉树的层次遍历 II</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如： 给定二叉树 [3,9,20,null,null,15,7],</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		3
   / \
  9  20
    /  \
   15   7
</pre></table></code></div></div><p>返回其自底向上的层次遍历为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="o">[</span>
  <span class="o">[</span><span class="mi">15</span><span class="o">,</span><span class="mi">7</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">20</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>还是利用队列，只是在遍历完一层后，将这一层的遍历结果添加在结果列表的最前面。</p><p>想使用LinkedList的offer和poll方法，就要实现相应的Queue接口。同理，想使用push和pop方法就要实现Stack接口。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrderBottom</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//res.add(new ArrayList&lt;&gt;());</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>    
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
      	<span class="c1">//根节点入队</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
      	<span class="c1">//层序遍历</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
              	<span class="c1">//子节点入队</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump108"></span></p><h2 id="108-将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 		
      0
		 / \
    -3  9
   /   /
 -10  5
</pre></table></code></div></div><p>BST的中序遍历是升序，所以本题等同于根据中序遍历的序列恢复二叉搜索树。若是普通的二叉搜索树，只需要选择序列中的任意一元素作为根节点，以该元素左边的升序序列构建左子树，右边的升序序列构建右子树，这样得到的就是一颗二叉搜索树了。</p><p>本题要求建立平衡二叉搜索树，因此每次需要选择升序序列的中间元素作为根节点。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">sortedArrayToBST</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="o">(</span><span class="n">h</span><span class="o">-</span><span class="n">l</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">h</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump109"></span></p><h2 id="109--有序链表转换二叉搜索树">109. 有序链表转换二叉搜索树</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
			 0
      / \
    -3   9
   /   /
 -10  5
</pre></table></code></div></div><p>具体地，设当前链表的左端点为left，右端点 right，包含关系为「左闭右开」，即left 包含在链表中而 right 不包含在链表中。我们希望快速地找出链表的中位数节点 mid。</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>为什么要设定「左闭右开」的关系？由于题目中给定的链表为单向链表，访问后继元素十分容易，但无法直接访问前驱元素。因此在找出链表的中位数节点mid 之后，如果设定「左闭右开」的关系，我们就可以直接用 (left,mid) 以及 (mid.next,right) 来表示左右子树对应的列表了。并且，初始的列表也可以用(head,null) 方便地进行表示，其中null 表示空节点。
</pre></table></code></div></div><p>找出链表中位数节点的方法多种多样，其中较为简单的一种是「快慢指针法」。初始时，快指针 fast 和慢指针slow 均指向链表的左端点 left。我们将快指针fast 向右移动两次的同时，将慢指针slow 向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。此时，慢指针对应的元素就是中位数。</p><p>在找出了中位数节点之后，我们将其作为当前根节点的元素，并递归地构造其左侧部分的链表对应的左子树，以及右侧部分的链表对应的右子树。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">sortedListToBST</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">buildTree</span><span class="o">(</span><span class="n">head</span><span class="o">,</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">left</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">right</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">getMidian</span><span class="o">(</span><span class="n">left</span><span class="o">,</span><span class="n">right</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">mid</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">buildTree</span><span class="o">(</span><span class="n">left</span><span class="o">,</span><span class="n">mid</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">buildTree</span><span class="o">(</span><span class="n">mid</span><span class="o">.</span><span class="na">next</span><span class="o">,</span><span class="n">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">ListNode</span> <span class="nf">getMidian</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">left</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">right</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="n">right</span><span class="o">){</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump110"></span></p><h2 id="110平衡二叉树">110.平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		3
   / \
  9  20
    /  \
   15   7
</pre></table></code></div></div><p>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</pre></table></code></div></div><p>返回 false 。</p><h3 id="自顶向下的递归">自顶向下的递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
      	<span class="c1">//当左右子树深度差大于1时，返回false</span>
        <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">getDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">-</span> <span class="n">getDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
      	<span class="c1">//继续判断左右子树</span>
        <span class="k">return</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBalanced</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
		<span class="c1">//获取二叉树深度</span>
    <span class="kt">int</span> <span class="nf">getDepth</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">getDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">),</span><span class="n">getDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">))+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="自底向上的递归">自底向上的递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">height</span><span class="o">(</span><span class="n">root</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">leftHeight</span> <span class="o">=</span> <span class="n">height</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rightHeight</span> <span class="o">=</span> <span class="n">height</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">leftHeight</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">rightHeight</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">leftHeight</span> <span class="o">-</span> <span class="n">rightHeight</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftHeight</span><span class="o">,</span> <span class="n">rightHeight</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump111"></span></p><h2 id="111-二叉树的最小深度">111. 二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 <code class="language-plaintext highlighter-rouge">[3,9,20,null,null,15,7]</code>,</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		3
   / \
  9  20
    /  \
   15   7
</pre></table></code></div></div><p>返回它的最小深度 2.</p><h3 id="深度优先-1">深度优先</h3><p>递归判断，当前节点为空时返回0；当前节点不为空，遍历到叶节点时返回1，遍历到非叶节点时，返回左右子树的最小深度。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDepth</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span><span class="n">right</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">left</span> <span class="o">=</span> <span class="n">minDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>  <span class="n">right</span> <span class="o">=</span> <span class="n">minDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">,</span><span class="n">right</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>

<span class="o">}</span>
</pre></table></code></div></div><h3 id="广度优先-1">广度优先</h3><p>当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">class</span> <span class="nc">QueueNode</span> <span class="o">{</span>
        <span class="nc">TreeNode</span> <span class="n">node</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">depth</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">QueueNode</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">depth</span> <span class="o">=</span> <span class="n">depth</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDepth</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">QueueNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">QueueNode</span><span class="o">&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">QueueNode</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">QueueNode</span> <span class="n">nodeDepth</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nodeDepth</span><span class="o">.</span><span class="na">node</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">nodeDepth</span><span class="o">.</span><span class="na">depth</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">depth</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">QueueNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">QueueNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump112"></span></p><h2 id="112-路径总和">112. 路径总和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和 sum = 22，</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</pre></table></code></div></div><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><h3 id="先序遍历">先序遍历</h3><p>用二叉树的前序遍历，每遍历到一个节点，<code class="language-plaintext highlighter-rouge">sum-=node.val</code>，当遍历到叶节点时，判断sum是否为0，若为0则存在路径，否则继续遍历。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathSum</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">preOrderTraversal</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">sum</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="c1">//树的先序遍历</span>
    <span class="kd">public</span> <span class="nc">Boolean</span> <span class="nf">preOrderTraversal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">){</span>

        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//是叶节点</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">sum</span><span class="o">-</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">preOrderTraversal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">tmp</span><span class="o">)</span> <span class="o">||</span> <span class="n">preOrderTraversal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">tmp</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump113"></span></p><h2 id="113路径总和-ii">113.路径总和 II</h2><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和 sum = 22，</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>          <span class="mi">5</span>
         <span class="o">/</span> <span class="err">\</span>
        <span class="mi">4</span>   <span class="mi">8</span>
       <span class="o">/</span>   <span class="o">/</span> <span class="err">\</span>
      <span class="mi">11</span>  <span class="mi">13</span>  <span class="mi">4</span>
     <span class="o">/</span>  <span class="err">\</span>    <span class="o">/</span> <span class="err">\</span>
    <span class="mi">7</span>    <span class="mi">2</span>  <span class="mi">5</span>   <span class="mi">1</span>
</pre></table></code></div></div><p>返回:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">[</span>
   <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
   <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><p>回溯法，先序遍历二叉树，当遇到了叶节点时，判断是否该路径和是否等于目标值。在一轮递归结束，需要返回到父节点时进行回溯，删除路径列表中本节点。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">pathSum</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//先序遍历</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="c1">//找到了叶节点</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">sum</span><span class="o">){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="n">list</span><span class="o">));</span>
                <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//当前不是叶节点，就把他加到路径中</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="c1">//不能像这样剪枝，节点值可能为负</span>
        <span class="cm">/*if(cnt &gt;= sum){
            return;
        }*/</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">cnt</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">cnt</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump114"></span></p><h2 id="114二叉树展开为链表">114.二叉树展开为链表</h2><p>给定一个二叉树，原地将它展开为一个单链表。</p><p>例如，给定二叉树</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		1
   / \
  2   5
 / \   \
3   4   6
</pre></table></code></div></div><p>将其展开为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="mi">1</span>
 <span class="err">\</span>
  <span class="mi">2</span>
   <span class="err">\</span>
    <span class="mi">3</span>
     <span class="err">\</span>
      <span class="mi">4</span>
       <span class="err">\</span>
        <span class="mi">5</span>
         <span class="err">\</span>
          <span class="mi">6</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">TreeNode</span> <span class="n">post</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatten</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">post</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">postOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//逆后序遍历，一个一个接上即可</span>
    <span class="kt">void</span> <span class="nf">postOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">postOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">postOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">post</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">post</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">post</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump116"></span></p><h2 id="116填充每个节点的下一个右侧节点指针">116.填充每个节点的下一个右侧节点指针</h2><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png" alt="" /></p><p><strong>提示：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p>不能用层序遍历，假设我们即将为第i+1行建立next关系，那么由于我们已经对第i行成功建立了next关系，所以我们可以用第i行的next指针遍历第i行，而第i+1行所有的节点都是第i行的子节点，所以也能直接被遍历到。具体地：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>使用一个nextStart指针指向下一行的起点。例如图中的1、2、4节点。
在建立第i+1行关系时，迭代第i行的节点cur，如2，
					令2.left.next = 2.right;
					令2.right.next = null or 2.next.left;	//当2.next为空时，2.right.next就为空。
然后移动指针cur，指向3。
在每行的开始，更新nextStart指针，使其指向第一个节点的left。每行结束时，更新迭代指针cur为nextStart，开始遍历下一行。
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">connect</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">//下一行的开头指针</span>
        <span class="nc">Node</span> <span class="n">nextStart</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">nextStart</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//开始遍历这一行</span>
            <span class="nc">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">nextStart</span><span class="o">;</span>
            <span class="c1">//更新nextStart指针，为下一次迭代作准备</span>
            <span class="n">nextStart</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump117"></span></p><h2 id="117填充每个节点的下一个右侧节点指针-ii">117.填充每个节点的下一个右侧节点指针 II</h2><p>给定一个二叉树</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><ul><li><p>你只能使用常量级额外空间。</p></li><li><p>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p></li></ul><p>层序遍历，在遍历到每层最后一个节点之前，让每个节点的next都指向队首元素。最后一个节点的next指向null。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">connect</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                
                <span class="nc">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="c1">//是否遍历到每一层的最后一个节点</span>
                <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="o">-</span><span class="mi">2</span> <span class="o">?</span> <span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
                
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>进阶：</p><p>假设某一层已经建立好了next指针关系，那么我们就可以通过遍历这一层来建立下一层的next指针。具体的：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>使用一个指针nextStart指向下一次遍历需要访问的节点，在这次遍历访问第一个节点时进行赋值。
再使用一个指针pre指向遍历这一层的某个节点时，它的前一个节点。
遍历这一层时，通过next指针，遍历该层所有节点，为这些节点的子节点建立next指针关系。
每遍历完一层，用nextStart指针跳向下一层的开头继续遍历。
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">nextStart</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">connect</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">start</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">start</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">nextStart</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
          	<span class="c1">//遍历每一层</span>
            <span class="k">for</span><span class="o">(</span><span class="nc">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">doConnect</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">doConnect</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
          	<span class="c1">//移向下一层</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">nextStart</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">doConnect</span><span class="o">(</span><span class="nc">Node</span> <span class="n">p</span><span class="o">){</span>
        <span class="c1">//如果不是每层的第一个节点，就直接把p给pre.next</span>
        <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//如果是每层的开头，就记录这个节点，为下次遍历作准备</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nextStart</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">nextStart</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//让pre移向下一个节点</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="119"></span></p><h2 id="119-杨辉三角-ii">119. 杨辉三角 II</h2><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: 3
输出: [1,3,3,1]
</pre></table></code></div></div><p><strong>进阶：</strong></p><p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210212092415726.png" alt="image-20210212092415726" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">getRow</span><span class="o">(</span><span class="kt">int</span> <span class="n">rowIndex</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">//滚动数组递推</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rowIndex</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="o">){</span>
                    <span class="n">cur</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">cur</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">getRow</span><span class="o">(</span><span class="kt">int</span> <span class="n">rowIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rowIndex</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210212092913013.png" alt="image-20210212092913013" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">getRow</span><span class="o">(</span><span class="kt">int</span> <span class="n">rowIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rowIndex</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="n">row</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">rowIndex</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">row</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump120"></span></p><h2 id="120-三角形最小路径和">120. 三角形最小路径和</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p><p>例如，给定三角形：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
</pre></table></code></div></div><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p>说明：</p><p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p><h3 id="动态规划-1">动态规划</h3><p>从倒数第二层开始，将每个节点的值加上子节点的最小值，最终根节点的值即为最小路径和。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minimumTotal</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">triangle</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">l</span><span class="o">][</span><span class="n">l</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span><span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minimumTotal</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">triangle</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">f</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">f</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">minTotal</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">minTotal</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minTotal</span><span class="o">,</span> <span class="n">f</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">minTotal</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">//空间优化</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minimumTotal</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">triangle</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">f</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">f</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">f</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">f</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">f</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">minTotal</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">minTotal</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minTotal</span><span class="o">,</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">minTotal</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump121"></span></p><h2 id="121买卖股票的最佳时机">121.买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">5</span>
<span class="nl">解释:</span> <span class="n">在第</span> <span class="mi">2</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">1</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">5</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">6</span><span class="err">）</span><span class="n">的时候卖出</span><span class="err">，</span><span class="n">最大利润</span> <span class="o">=</span> <span class="mi">6</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">5</span> <span class="err">。</span>
     <span class="n">注意利润不能是</span> <span class="mi">7</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">因为卖出价格需要大于买入价格</span><span class="err">；</span><span class="n">同时</span><span class="err">，</span><span class="n">你不能在买入前卖出股票</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">0</span>
<span class="nl">解释:</span> <span class="n">在这种情况下</span><span class="o">,</span> <span class="n">没有交易完成</span><span class="o">,</span> <span class="n">所以最大利润为</span> <span class="mi">0</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//一次遍历，不断更新最低价格，这样后面的price[i]可以不用管前面比minPrice更高的价格</span>
    <span class="c1">//直接跟minPrice相减，收益肯定是当前最大的。</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">minPrice</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">minPrice</span><span class="o">){</span>
                <span class="n">minPrice</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">minPrice</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump122"></span></p><h2 id="122买卖股票的最佳时机-ii">122.买卖股票的最佳时机 II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">7</span>
<span class="nl">解释:</span> <span class="n">在第</span> <span class="mi">2</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">1</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">3</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">5</span><span class="err">）</span><span class="n">的时候卖出</span><span class="o">,</span> <span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">5</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">4</span> <span class="err">。</span>
     <span class="n">随后</span><span class="err">，</span><span class="n">在第</span> <span class="mi">4</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">3</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">5</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">6</span><span class="err">）</span><span class="n">的时候卖出</span><span class="o">,</span> <span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">6</span><span class="o">-</span><span class="mi">3</span> <span class="o">=</span> <span class="mi">3</span> <span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">4</span>
<span class="nl">解释:</span> <span class="n">在第</span> <span class="mi">1</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">1</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">5</span> <span class="n">天</span> <span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">5</span><span class="err">）</span><span class="n">的时候卖出</span><span class="o">,</span> <span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">5</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">4</span> <span class="err">。</span>
     <span class="n">注意你不能在第</span> <span class="mi">1</span> <span class="n">天和第</span> <span class="mi">2</span> <span class="n">天接连购买股票</span><span class="err">，</span><span class="n">之后再将它们卖出</span><span class="err">。</span>
     <span class="n">因为这样属于同时参与了多笔交易</span><span class="err">，</span><span class="n">你必须在再次购买前出售掉之前的股票</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">0</span>
<span class="nl">解释:</span> <span class="n">在这种情况下</span><span class="o">,</span> <span class="n">没有交易完成</span><span class="o">,</span> <span class="n">所以最大利润为</span> <span class="mi">0</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</li><li>0 &lt;= prices[i] &lt;= 10 ^ 4</li></ul><p>动态规划：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//dp[i]表示第i天结束后，最大的累积收益</span>
        <span class="c1">//dp[i][0]持有一支股票-&gt;hs</span>
        <span class="c1">//dp[i][1]不持有任何股票-&gt;nhs</span>
        <span class="c1">//边界</span>
        <span class="kt">int</span> <span class="n">hs</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">nhs</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">hs</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">hs</span><span class="o">,</span> <span class="n">nhs</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">nhs</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nhs</span><span class="o">,</span> <span class="n">hs</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">nhs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>贪心：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//涨了就卖，跌了就不卖</span>
        <span class="c1">//不管到底有没有买入，只要涨了，我就认为我买入了，直接卖即可，贪心</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="123-买卖股票的最佳时机-iii">123. 买卖股票的最佳时机 III</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">prices</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="n">在第</span> <span class="mi">4</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">0</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">6</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">3</span><span class="err">）</span><span class="n">的时候卖出</span><span class="err">，</span><span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">3</span><span class="o">-</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">3</span> <span class="err">。</span>
     <span class="n">随后</span><span class="err">，</span><span class="n">在第</span> <span class="mi">7</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">1</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">8</span> <span class="n">天</span> <span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">4</span><span class="err">）</span><span class="n">的时候卖出</span><span class="err">，</span><span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">4</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span> <span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">prices</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">在第</span> <span class="mi">1</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">1</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">5</span> <span class="n">天</span> <span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">5</span><span class="err">）</span><span class="n">的时候卖出</span><span class="o">,</span> <span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">5</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">4</span> <span class="err">。</span>   
     <span class="n">注意你不能在第</span> <span class="mi">1</span> <span class="n">天和第</span> <span class="mi">2</span> <span class="n">天接连购买股票</span><span class="err">，</span><span class="n">之后再将它们卖出</span><span class="err">。</span>   
     <span class="n">因为这样属于同时参与了多笔交易</span><span class="err">，</span><span class="n">你必须在再次购买前出售掉之前的股票</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">prices</span> <span class="o">=</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> 
<span class="n">输出</span><span class="err">：</span><span class="mi">0</span> 
<span class="n">解释</span><span class="err">：</span><span class="n">在这个情况下</span><span class="o">,</span> <span class="n">没有交易完成</span><span class="o">,</span> <span class="n">所以最大利润为</span> <span class="mi">0</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= prices.length &lt;= 105</li><li>0 &lt;= prices[i] &lt;= 105</li></ul><p>https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">sell1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">buy2</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">sell2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">buy1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">buy1</span><span class="o">,</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">sell1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sell1</span><span class="o">,</span> <span class="n">buy1</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">buy2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">buy2</span><span class="o">,</span> <span class="n">sell1</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">sell2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sell2</span><span class="o">,</span> <span class="n">buy2</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sell2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump124"></span></p><h2 id="124-二叉树中的最大路径和">124. 二叉树中的最大路径和</h2><p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p>示例 1：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>输入：[1,2,3]
		 1
    / \
   2   3
输出：6
</pre></table></code></div></div><p>示例2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[-</span><span class="mi">10</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>

   <span class="o">-</span><span class="mi">10</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">9</span>  <span class="mi">20</span>
    <span class="o">/</span>  <span class="err">\</span>
   <span class="mi">15</span>   <span class="mi">7</span>

<span class="n">输出</span><span class="err">：</span><span class="mi">42</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
    <span class="c1">//考虑每个节点作为父节点时，能获得的最大路径和</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxPathSum</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">postOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//后序遍历</span>
    <span class="kt">int</span> <span class="nf">postOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//左子节点的贡献</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">postOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
        <span class="c1">//右子节点的贡献</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">postOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
        <span class="c1">//左子节点的贡献+右子节点的贡献+当前节点值 = 以当前节点为父节点的最大路径</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="c1">//更新结果</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="c1">//返回此节点的最大贡献 = max(左子树的贡献，右子树的贡献) + 当前节点值</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="125-验证回文串">125. 验证回文串</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)))){</span>
                <span class="n">l</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">)))){</span>
                <span class="n">r</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">l</span><span class="o">++;</span>
            <span class="n">r</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump127"></span></p><h2 id="127单词接龙">127.单词接龙</h2><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明:</p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">beginWord</span> <span class="o">=</span> <span class="s">"hit"</span><span class="o">,</span>
<span class="n">endWord</span> <span class="o">=</span> <span class="s">"cog"</span><span class="o">,</span>
<span class="n">wordList</span> <span class="o">=</span> <span class="o">[</span><span class="s">"hot"</span><span class="o">,</span><span class="s">"dot"</span><span class="o">,</span><span class="s">"dog"</span><span class="o">,</span><span class="s">"lot"</span><span class="o">,</span><span class="s">"log"</span><span class="o">,</span><span class="s">"cog"</span><span class="o">]</span>

<span class="nl">输出:</span> <span class="mi">5</span>

<span class="nl">解释:</span> <span class="n">一个最短转换序列是</span> <span class="s">"hit"</span> <span class="o">-&gt;</span> <span class="s">"hot"</span> <span class="o">-&gt;</span> <span class="s">"dot"</span> <span class="o">-&gt;</span> <span class="s">"dog"</span> <span class="o">-&gt;</span> <span class="s">"cog"</span><span class="o">,</span>
     <span class="n">返回它的长度</span> <span class="mi">5</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">beginWord</span> <span class="o">=</span> <span class="s">"hit"</span>
<span class="n">endWord</span> <span class="o">=</span> <span class="s">"cog"</span>
<span class="n">wordList</span> <span class="o">=</span> <span class="o">[</span><span class="s">"hot"</span><span class="o">,</span><span class="s">"dot"</span><span class="o">,</span><span class="s">"dog"</span><span class="o">,</span><span class="s">"lot"</span><span class="o">,</span><span class="s">"log"</span><span class="o">]</span>

<span class="nl">输出:</span> <span class="mi">0</span>

<span class="nl">解释:</span> <span class="n">endWord</span> <span class="s">"cog"</span> <span class="n">不在字典中</span><span class="err">，</span><span class="n">所以无法进行转换</span><span class="err">。</span>
</pre></table></code></div></div><p>深度优先遍历超时了。</p><p>广度优先遍历：</p><ol><li>用一个集合存放字典元素，便于判断某个单词是否在字典内。</li><li>广度优先：startWord开始，尝试修改每一位字符，将修改后，存在于字典中的新单词全部放入队列。</li><li>每一次广度优先尝试step+1。</li><li>若在一次广度优先尝试中，有一个单词修改一个字母后，变成了endWord，就返回step+1。</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ladderLength</span><span class="o">(</span><span class="nc">String</span> <span class="n">beginWord</span><span class="o">,</span> <span class="nc">String</span> <span class="n">endWord</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordList</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">wordList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">wordList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">endWord</span><span class="o">))</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">//将wordList放入集合中，便于查询某个单词是否在字典中</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">wordList</span><span class="o">){</span>
            <span class="n">wordSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">wordSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">beginWord</span><span class="o">);</span>

        <span class="c1">//队列，用于广度优先遍历</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">beginWord</span><span class="o">);</span>
        <span class="c1">//标记某个单词是否被访问过</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beginWord</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">String</span> <span class="n">w</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(</span><span class="n">modifyEachLetter</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">endWord</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="n">wordSet</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">step</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">modifyEachLetter</span><span class="o">(</span><span class="nc">String</span> <span class="n">w</span><span class="o">,</span> <span class="nc">String</span> <span class="n">endWord</span><span class="o">,</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordSet</span><span class="o">){</span>

        <span class="kt">char</span><span class="o">[]</span> <span class="n">wordChar</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="c1">//修改每个位置的字符</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">orignChar</span> <span class="o">=</span> <span class="n">wordChar</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">//每个位置遍历26种情况</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="o">;</span> <span class="o">++</span><span class="n">c</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">orignChar</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span>    <span class="k">continue</span><span class="o">;</span>
                <span class="n">wordChar</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
                <span class="nc">String</span> <span class="n">new_w</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">wordChar</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">wordSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">new_w</span><span class="o">))</span>    <span class="k">continue</span><span class="o">;</span>
                <span class="c1">//字典内存在这个新单词</span>
                <span class="k">if</span><span class="o">(</span><span class="n">new_w</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">endWord</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">new_w</span><span class="o">)){</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">new_w</span><span class="o">);</span>
                        <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">new_w</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">wordChar</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">orignChar</span><span class="o">;</span>
            
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        

    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump129"></span></p><h2 id="129求根到叶子节点数字之和">129.求根到叶子节点数字之和</h2><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
    <span class="mi">1</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">2</span>   <span class="mi">3</span>
<span class="nl">输出:</span> <span class="mi">25</span>
<span class="nl">解释:</span>
<span class="n">从根到叶子节点路径</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span> <span class="n">代表数字</span> <span class="mi">12</span><span class="o">.</span>
<span class="n">从根到叶子节点路径</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span> <span class="n">代表数字</span> <span class="mi">13</span><span class="o">.</span>
<span class="n">因此</span><span class="err">，</span><span class="n">数字总和</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">13</span> <span class="o">=</span> <span class="mi">25</span><span class="o">.</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
    <span class="mi">4</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">9</span>   <span class="mi">0</span>
 <span class="o">/</span> <span class="err">\</span>
<span class="mi">5</span>   <span class="mi">1</span>
<span class="nl">输出:</span> <span class="mi">1026</span>
<span class="nl">解释:</span>
<span class="n">从根到叶子节点路径</span> <span class="mi">4</span><span class="o">-&gt;</span><span class="mi">9</span><span class="o">-&gt;</span><span class="mi">5</span> <span class="n">代表数字</span> <span class="mi">495</span><span class="o">.</span>
<span class="n">从根到叶子节点路径</span> <span class="mi">4</span><span class="o">-&gt;</span><span class="mi">9</span><span class="o">-&gt;</span><span class="mi">1</span> <span class="n">代表数字</span> <span class="mi">491</span><span class="o">.</span>
<span class="n">从根到叶子节点路径</span> <span class="mi">4</span><span class="o">-&gt;</span><span class="mi">0</span> <span class="n">代表数字</span> <span class="mi">40</span><span class="o">.</span>
<span class="n">因此</span><span class="err">，</span><span class="n">数字总和</span> <span class="o">=</span> <span class="mi">495</span> <span class="o">+</span> <span class="mi">491</span> <span class="o">+</span> <span class="mi">40</span> <span class="o">=</span> <span class="mi">1026</span><span class="o">.</span>
</pre></table></code></div></div><p>前序遍历+回溯</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumNumbers</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//前序遍历加回溯</span>
        <span class="n">preOderBackTrack</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">preOderBackTrack</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">base</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="n">preOderBackTrack</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">base</span><span class="o">);</span>
            <span class="n">preOderBackTrack</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">base</span><span class="o">);</span>
            <span class="c1">//如果到了叶节点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">base</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump130"></span></p><h2 id="130-被围绕的区域">130. 被围绕的区域</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="no">X</span> <span class="no">X</span> <span class="no">X</span> <span class="no">X</span>
<span class="no">X</span> <span class="no">O</span> <span class="no">O</span> <span class="no">X</span>
<span class="no">X</span> <span class="no">X</span> <span class="no">O</span> <span class="no">X</span>
<span class="no">X</span> <span class="no">O</span> <span class="no">X</span> <span class="no">X</span>
</pre></table></code></div></div><p>运行你的函数后，矩阵变为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="no">X</span> <span class="no">X</span> <span class="no">X</span> <span class="no">X</span>
<span class="no">X</span> <span class="no">X</span> <span class="no">X</span> <span class="no">X</span>
<span class="no">X</span> <span class="no">X</span> <span class="no">X</span> <span class="no">X</span>
<span class="no">X</span> <span class="no">O</span> <span class="no">X</span> <span class="no">X</span>
</pre></table></code></div></div><p>解释:</p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><p>任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。</p><p>遍历所有边界上的’O’，将与他相连的’O’染色。</p><p>最后遍历所有元素，被染色的恢复为’O’，未被染色的’O’修改为‘X’</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">row</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="c1">//标记</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="c1">//在边界上</span>
                <span class="k">if</span><span class="o">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="n">row</span><span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">){</span>
                    <span class="c1">//染色</span>
                  	<span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">);</span>

                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'O'</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'M'</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">row</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">col</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
  
  <span class="cm">/*void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) {
        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != 'O') {
            return;
        }
        board[x][y] = 'A';
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    }*/</span>


<span class="o">}</span>
</pre></table></code></div></div><p><strong>参考</strong></p><p>https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/</p><p><span id="jump131"></span></p><h2 id="131-分割回文串">131. 分割回文串</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"aab"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"b"</span><span class="o">],[</span><span class="s">"aa"</span><span class="o">,</span><span class="s">"b"</span><span class="o">]]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 16</li><li>s 仅由小写英文字母组成</li></ul><p>回溯+动态规划：遍历每个起始字符s[i]，判断子串<code class="language-plaintext highlighter-rouge">s[i,j]</code>是否为回文串，如果是，就回溯遍历s[j+1]。判断是否为回文串时，可是使用双指针判断，但是造成了重复计算，因此用动态规划代替。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">partition</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">//初始化边界：单字符均为true</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//将所有回文子串标记，dp[i][j]==true表示子串[i,j]为回文串</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//回溯</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//回溯遍历所有拆分情况</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">cur</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">idx</span><span class="o">][</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump132"></span></p><h2 id="132-分割回文串-ii">132. 分割回文串 II</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 最少分割次数 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"aab"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
<span class="n">解释</span><span class="err">：</span><span class="n">只需一次分割就可将</span> <span class="n">s</span> <span class="n">分割成</span> <span class="o">[</span><span class="s">"aa"</span><span class="o">,</span><span class="s">"b"</span><span class="o">]</span> <span class="n">这样两个回文子串</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 2000</li><li>s 仅由小写英文字母组成</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minCut</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//仍旧是动态规划，将所有回文子串找出</span>
        <span class="c1">//遍历每个位置s[j]，找到以s[j]为结尾的最长回文子串s[i,j]，同时s[0,i]也是由回文子串构成的</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span><span class="c1">//无限次拆分表示无法拆分为回文子串</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]){</span>
                <span class="n">c</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]){</span><span class="c1">//找到一个子串</span>
                        <span class="n">c</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">c</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump133"></span></p><h2 id="133-克隆图">133. 克隆图</h2><p>给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">neighbors</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>测试用例格式：</p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code class="language-plaintext highlighter-rouge">val = 1</code>），第二个节点值为 2（<code class="language-plaintext highlighter-rouge">val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">adjList</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">图中有</span> <span class="mi">4</span> <span class="n">个节点</span><span class="err">。</span>
<span class="n">节点</span> <span class="mi">1</span> <span class="n">的值是</span> <span class="mi">1</span><span class="err">，</span><span class="n">它有两个邻居</span><span class="err">：</span><span class="n">节点</span> <span class="mi">2</span> <span class="n">和</span> <span class="mi">4</span> <span class="err">。</span>
<span class="n">节点</span> <span class="mi">2</span> <span class="n">的值是</span> <span class="mi">2</span><span class="err">，</span><span class="n">它有两个邻居</span><span class="err">：</span><span class="n">节点</span> <span class="mi">1</span> <span class="n">和</span> <span class="mi">3</span> <span class="err">。</span>
<span class="n">节点</span> <span class="mi">3</span> <span class="n">的值是</span> <span class="mi">3</span><span class="err">，</span><span class="n">它有两个邻居</span><span class="err">：</span><span class="n">节点</span> <span class="mi">2</span> <span class="n">和</span> <span class="mi">4</span> <span class="err">。</span>
<span class="n">节点</span> <span class="mi">4</span> <span class="n">的值是</span> <span class="mi">4</span><span class="err">，</span><span class="n">它有两个邻居</span><span class="err">：</span><span class="n">节点</span> <span class="mi">1</span> <span class="n">和</span> <span class="mi">3</span> <span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">adjList</span> <span class="o">=</span> <span class="o">[[]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[]]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">输入包含一个空列表</span><span class="err">。</span><span class="n">该图仅仅只有一个值为</span> <span class="mi">1</span> <span class="n">的节点</span><span class="err">，</span><span class="n">它没有任何邻居</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">adjList</span> <span class="o">=</span> <span class="o">[]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">这个图是空的</span><span class="err">，</span><span class="n">它不含任何节点</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">adjList</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">2</span><span class="o">],[</span><span class="mi">1</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">2</span><span class="o">],[</span><span class="mi">1</span><span class="o">]]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>节点数不超过 100 。</li><li>每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。</li><li>无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ul><h3 id="深搜">深搜</h3><p>用一个哈希表来存储已访问顶点，键是原图中的顶点，值是拷贝图中对应的顶点。</p><p>从原图的某个顶点开始遍历，判断是否以拷贝，若是，则返回哈希表中的值；否则，拷贝该顶点，并放入哈希表中，随即遍历该顶点的邻居，执行深度优先搜索，并将返回值赋给拷贝顶点的邻接表。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="cm">/*
// Definition for a Node.
class Node {
    public int val;
    public List&lt;Node&gt; neighbors;
    
    public Node() {
        val = 0;
        neighbors = new ArrayList&lt;Node&gt;();
    }
    
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList&lt;Node&gt;();
    }
    
    public Node(int _val, ArrayList&lt;Node&gt; _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">,</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">cloneGraph</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">Node</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">node</span><span class="o">))</span>
            <span class="k">return</span> <span class="n">visited</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">myNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">visited</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span><span class="n">myNode</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Node</span> <span class="n">n</span> <span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">neighbors</span><span class="o">){</span>
            <span class="n">myNode</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">myNode</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="广搜">广搜</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">cloneGraph</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>

        <span class="c1">// 将题目给定的节点添加到队列</span>
        <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="o">();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="c1">// 克隆第一个节点并存储到哈希表中</span>
        <span class="n">visited</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">()));</span>

        <span class="c1">// 广度优先搜索</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 取出队列的头节点</span>
            <span class="nc">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
            <span class="c1">// 遍历该节点的邻居</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="nl">neighbor:</span> <span class="n">n</span><span class="o">.</span><span class="na">neighbors</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">neighbor</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">// 如果没有被访问过，就克隆并存储在哈希表中</span>
                    <span class="n">visited</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">()));</span>
                    <span class="c1">// 将邻居节点加入队列中</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">neighbor</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">// 更新当前节点的邻居列表</span>
                <span class="n">visited</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">visited</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">neighbor</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">visited</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump135"></span></p><h2 id="135-分发糖果">135. 分发糖果</h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">5</span>
<span class="nl">解释:</span> <span class="n">你可以分别给这三个孩子分发</span> <span class="mi">2</span><span class="err">、</span><span class="mi">1</span><span class="err">、</span><span class="mi">2</span> <span class="n">颗糖果</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">4</span>
<span class="nl">解释:</span> <span class="n">你可以分别给这三个孩子分发</span> <span class="mi">1</span><span class="err">、</span><span class="mi">2</span><span class="err">、</span><span class="mi">1</span> <span class="n">颗糖果</span><span class="err">。</span>
     <span class="n">第三个孩子只得到</span> <span class="mi">1</span> <span class="n">颗糖果</span><span class="err">，</span><span class="n">这已满足上述两个条件</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">candy</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ratings</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//统计连续下降的子序列长度，按照这个长度分配糖果</span>
        <span class="c1">//假设有这么一个序列「44，13，3，2，3」，连续下降长度为4，所以分配糖果数为4+3+2+1+...</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ratings</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">ratings</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="o">++</span><span class="n">r</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ratings</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">ratings</span><span class="o">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
                <span class="o">++</span><span class="n">r</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//说明找到了一个长度大于等于2的下降子序列</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ratings</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">==</span> <span class="n">ratings</span><span class="o">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])){</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                        <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">--;</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span><span class="c1">//需要保证这个子序列的首元素分配的糖果数不小于上一个</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">ratings</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">ratings</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                        <span class="n">counts</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                            <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">--;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>

            <span class="o">}</span><span class="k">else</span><span class="o">{</span><span class="c1">//r == l</span>
                <span class="c1">//与上一个元素相等，且下一个元素等于自己</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ratings</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">==</span> <span class="n">ratings</span><span class="o">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                    <span class="c1">//给1个糖果就行了</span>
                    <span class="n">counts</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">counts</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">ratings</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">ratings</span><span class="o">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span><span class="c1">//比上一个元素大，那就必须给多一个糖果</span>
                    <span class="n">counts</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">counts</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>


<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20201224094150566.png" alt="image-20201224094150566" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">candy</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ratings</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">ratings</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">ratings</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ratings</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ratings</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">ratings</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="n">ratings</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ratings</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ratings</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">ratings</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump136"></span></p><h2 id="136只出现一次的数字">136.只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">1</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">4</span>
</pre></table></code></div></div><p>利用异或的性质，当一个数被另一个数异或两次时，会变回自身。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">singleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">targe</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">targe</span> <span class="o">^=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">targe</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump139"></span></p><h2 id="139单词拆分">139.单词拆分</h2><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。</p><p>示例 1：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
</pre></table></code></div></div><p>示例 2：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
</pre></table></code></div></div><p>示例 3：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
</pre></table></code></div></div><h3 id="动态规划-2">动态规划</h3><p>设<code class="language-plaintext highlighter-rouge">dp[i]</code>为字符串前i个字符组成的单词拆分后，能否被字典表示。令<code class="language-plaintext highlighter-rouge">dp[0]=true</code>，表示空字符串能够被表示。</p><p>对于字符串前<code class="language-plaintext highlighter-rouge">i</code>个字符，判断子串<code class="language-plaintext highlighter-rouge">[j,i-1]</code>能否被字典表示。目前我们已经确定了<code class="language-plaintext highlighter-rouge">dp[i-1]</code>的值，接下来要确定<code class="language-plaintext highlighter-rouge">dp[i]</code>的值，从左向右移动指针<code class="language-plaintext highlighter-rouge">j</code>,判断是否有这么一种情况出现：即<code class="language-plaintext highlighter-rouge">d[j]=true</code>，并且子串<code class="language-plaintext highlighter-rouge">[j,i-1]</code>能够被字典表示。这样一来，字符串的前<code class="language-plaintext highlighter-rouge">i</code>个字符组成的单词拆分后也能够字典表示，令<code class="language-plaintext highlighter-rouge">dp[i]=true</code>。</p><p>状态方程：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>						dp[i] = dp[j] &amp;&amp; isMatch(s.substring(j,i-1));
</pre></table></code></div></div><h3 id="答案">答案</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">wordBreak</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//dp[i]表示字符串s的前i个字符串是否能被字典表示</span>
        <span class="c1">//初始化dp[0]为true </span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">wordDict</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">j</span><span class="o">,</span><span class="n">i</span><span class="o">))){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump141"></span></p><h2 id="141环形链表">141.环形链表</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">4</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中有一个环</span><span class="err">，</span><span class="n">其尾部连接到第二个节点</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中有一个环</span><span class="err">，</span><span class="n">其尾部连接到第一个节点</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中没有环</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cnt</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>快慢指针：</p><p>一个指针移动地慢，一个指针移动地快，如果有环路存在，那么快的指针肯定会追上慢的指针（套圈）。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">slow</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump142"></span></p><h2 id="142环形链表ii">142.环形链表II</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">4</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中有一个环</span><span class="err">，</span><span class="n">其尾部连接到第二个节点</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中有一个环</span><span class="err">，</span><span class="n">其尾部连接到第一个节点</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="n">链表中没有环</span><span class="err">。</span>
</pre></table></code></div></div><p>快慢指针：</p><p>初始时，slow和fast都位于链表的头部，随后slow每次向后移动一个位置，fast向后移动两个位置。二者会在环中的某点相遇。如下图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" alt="" /></p><p>b是相遇时slow指针在环内走过的距离，所以此时fast指针走过的距离为：<code class="language-plaintext highlighter-rouge">a+n(b+c)+b = a+(n+1)b+nc</code>。任意时刻，fast指针走过的距离都为slow指针的两倍，所以有：<code class="language-plaintext highlighter-rouge">b = a+(n+1)b+nc</code>，即：<code class="language-plaintext highlighter-rouge">a = c+(n-1)(b+c)</code>，所以从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">detectCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">ptr</span><span class="o">){</span>
                    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump143"></span></p><h2 id="143重排链表">143.重排链表</h2><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">给定链表</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">,</span> <span class="n">重新排列为</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">.</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">给定链表</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">,</span> <span class="n">重新排列为</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">.</span>
</pre></table></code></div></div><p>先统计结点个数，将后一半节点入栈，再遍历前一半节点，将栈中节点依次错位插入到其中。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reorderList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">new_head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//一次遍历统计节点个数</span>
        <span class="kt">int</span> <span class="n">nums</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">nums</span><span class="o">++;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//将后一半的节点入栈</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">nums</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="n">nums</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">nums</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//定位到链表的中间节点</span>
        <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">index</span><span class="o">--;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//将栈中节点依次插入到链表中</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
           <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump114"></span></p><h2 id="144二叉树的前序遍历">144.二叉树的前序遍历</h2><p>给定一个二叉树，返回它的 前序 遍历。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>  
   <span class="mi">1</span>
    <span class="err">\</span>
     <span class="mi">2</span>
    <span class="o">/</span>
   <span class="mi">3</span> 

<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
</pre></table></code></div></div><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">preorderTraversal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//访问当前节点以及左子树节点，并入栈</span>
            <span class="k">while</span><span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//到叶节点了，出栈，转向右子树</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump145"></span></p><h2 id="145二叉树的后序遍历">145.二叉树的后序遍历</h2><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>  
   <span class="mi">1</span>
    <span class="err">\</span>
     <span class="mi">2</span>
    <span class="o">/</span>
   <span class="mi">3</span> 

<span class="nl">输出:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><ol><li><p>先将左子树依次入栈，直到叶节点。</p></li><li><p>判断右子树是否为空，或者右子树是否访问过</p><p>2.1 如果是，就可以访问根节点了。</p><p>2.2 如果不是，就需要把根节点再次入栈，将指针转向右子树，跳到1.1继续判断。</p></li></ol><p>可以用一个指针<code class="language-plaintext highlighter-rouge">pre</code>指向上一个已经访问过的节点。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">postorderTraversal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">TreeNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

            <span class="c1">//当右子树为空时，就访问此节点；若右子树已经被访问过了，就访问此节点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">pre</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//右子树不为空，就继续根节点入栈，转向右子树</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump146"></span></p><h2 id="146lru-缓存机制">146.LRU 缓存机制</h2><p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。 实现 LRUCache 类：</p><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">输入</span>
<span class="o">[</span><span class="s">"LRUCache"</span><span class="o">,</span> <span class="s">"put"</span><span class="o">,</span> <span class="s">"put"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"put"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"put"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">]</span>
<span class="o">[[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">]]</span>
<span class="n">输出</span>
<span class="o">[</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>

<span class="n">解释</span>
<span class="nc">LRUCache</span> <span class="n">lRUCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LRUCache</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// 缓存是 {1=1}</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="c1">// 缓存是 {1=1, 2=2}</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>    <span class="c1">// 返回 1</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>    <span class="c1">// 返回 -1 (未找到)</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span> <span class="c1">// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>    <span class="c1">// 返回 -1 (未找到)</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>    <span class="c1">// 返回 3</span>
<span class="n">lRUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>    <span class="c1">// 返回 4</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 3000</li><li>0 &lt;= value &lt;= 104</li><li>最多调用 3 * 104 次 get 和 put</li></ul><p>双链表的删除或者移动都是O(1)，只有查询不是，所以用一个哈希表来存放双链表节点即可实现全O(1)</p><p>自己实现一个双链表，再用一个哈希表存储链表节点和key的对应关系，方便直接取出节点。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
    <span class="nc">DLinkedNode</span> <span class="n">head</span><span class="o">;</span>
    <span class="nc">DLinkedNode</span> <span class="n">tail</span><span class="o">;</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">DLinkedNode</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DLinkedNode</span><span class="o">();</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DLinkedNode</span><span class="o">();</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DLinkedNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">moveToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DLinkedNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">//cache中不存在key</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//cache满了吗？</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">){</span>
                <span class="c1">//删除尾巴的一个元素</span>
                <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">pre</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
                <span class="n">removeNode</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">pre</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">DLinkedNode</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DLinkedNode</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="n">addHead</span><span class="o">(</span><span class="n">newNode</span><span class="o">);</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">node</span><span class="o">);</span>
            <span class="n">moveToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">moveToHead</span><span class="o">(</span><span class="nc">DLinkedNode</span> <span class="n">node</span><span class="o">){</span>
        <span class="n">removeNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>



    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addHead</span><span class="o">(</span><span class="nc">DLinkedNode</span> <span class="n">node</span><span class="o">){</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeNode</span><span class="o">(</span><span class="nc">DLinkedNode</span> <span class="n">node</span><span class="o">){</span>
        <span class="n">node</span><span class="o">.</span><span class="na">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">pre</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">DLinkedNode</span><span class="o">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
    <span class="nc">DLinkedNode</span> <span class="n">pre</span><span class="o">;</span>
    <span class="nc">DLinkedNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">DLinkedNode</span><span class="o">(){}</span>
    <span class="kd">public</span> <span class="nf">DLinkedNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">_key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">_value</span><span class="o">){</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">_key</span><span class="o">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">_value</span><span class="o">;</span>
    <span class="o">}</span>


<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump147"></span></p><h2 id="147对链表进行插入排序">147.对链表进行插入排序</h2><p>插入排序算法：</p><p>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">4</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span>
<span class="nl">输出:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">-</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">0</span>
<span class="nl">输出:</span> <span class="o">-</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">0</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">insertionSortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">//新链表</span>
        <span class="nc">ListNode</span> <span class="n">fakeHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">lastSort</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//剪枝，指向当前已排序链表的最后一个元素，若cur.next比这个元素都大，那就不用插入了</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;=</span> <span class="n">lastSort</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">lastSort</span> <span class="o">=</span> <span class="n">lastSort</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">fakeHead</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="k">return</span> <span class="n">fakeHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump148"></span></p><h2 id="148排序链表">148.排序链表</h2><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>进阶：</p><p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">head</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></table></code></div></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code class="language-plaintext highlighter-rouge">[0, 5 * 104]</code> 内</li><li><code class="language-plaintext highlighter-rouge">-105 &lt;= Node.val &lt;= 105</code></li></ul><p>暴力遍历插入：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//制造一个伪头节点，用于执行插入操作</span>
        <span class="nc">ListNode</span> <span class="n">fake_head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//遍历节点，出现逆序对，就把后一个节点插入到合适的位置</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ptr</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="c1">//将此节点从原链表中取出</span>
                <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">fake_head</span><span class="o">;</span>
                <span class="c1">//找合适的位置</span>
                <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//把该节点插入到合适的位置</span>
                <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">fake_head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>小顶堆：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//小顶堆</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">ptr</span><span class="o">);</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">newHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>递归归并排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//归并排序链表</span>
    <span class="c1">//1.先用快慢指针把链表分割为两部分</span>
    <span class="c1">//2.再递归分割直至只剩一个节点，即head.next = null</span>
    <span class="c1">//3.接着对两个有序链表进行归并</span>
    <span class="c1">//4.用一个指针来串</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//保留后半段的引用</span>
        <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">//分割链表</span>
        <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">//递归分割</span>
        <span class="nc">ListNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">sortList</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">sortList</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>

        <span class="nc">ListNode</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">res</span><span class="o">;</span>
        <span class="c1">//执行归并</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>迭代归并排序（不是我写的，待复习！）：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">getLength</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
       
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">step</span><span class="o">*=</span><span class="mi">2</span><span class="o">){</span> <span class="c1">//依次将链表分成1块，2块，4块...</span>
            <span class="c1">//每次变换步长，pre指针和cur指针都初始化在链表头</span>
            <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span> 
            <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
                <span class="nc">ListNode</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="c1">//第一部分头 （第二次循环之后，cur为剩余部分头，不断往后把链表按照步长step分成一块一块...）</span>
                <span class="nc">ListNode</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">split</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">step</span><span class="o">);</span>  <span class="c1">//第二部分头</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">split</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">step</span><span class="o">);</span> <span class="c1">//剩余部分的头</span>
                <span class="nc">ListNode</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">);</span> <span class="c1">//将一二部分排序合并</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> <span class="c1">//将前面的部分与排序好的部分连接</span>
                <span class="k">while</span><span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">//把pre指针移动到排序好的部分的末尾</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getLength</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">){</span>
    <span class="c1">//获取链表长度</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">head</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">count</span><span class="o">++;</span>
            <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">split</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span><span class="kt">int</span> <span class="n">step</span><span class="o">){</span>
        <span class="c1">//断链操作 返回第二部分链表头</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">step</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//切断连接</span>
        <span class="k">return</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">merge</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">h1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">h2</span><span class="o">){</span>
    <span class="c1">//合并两个有序链表</span>
        <span class="nc">ListNode</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">h1</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h2</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">h1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">h2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">h1</span><span class="o">;</span>
                <span class="n">h1</span> <span class="o">=</span> <span class="n">h1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">h2</span><span class="o">;</span>
                <span class="n">h2</span> <span class="o">=</span> <span class="n">h2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>           
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">h1</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">h1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">h2</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">h2</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>     
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="n">cherry</span><span class="o">-</span><span class="n">n1</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-di-gui-die-dai-xiang-jie-by-cherr/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump150"></span></p><h2 id="150-逆波兰表达式求值">150. 逆波兰表达式求值</h2><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">tokens</span> <span class="o">=</span> <span class="o">[</span><span class="s">"10"</span><span class="o">,</span><span class="s">"6"</span><span class="o">,</span><span class="s">"9"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"+"</span><span class="o">,</span><span class="s">"-11"</span><span class="o">,</span><span class="s">"*"</span><span class="o">,</span><span class="s">"/"</span><span class="o">,</span><span class="s">"*"</span><span class="o">,</span><span class="s">"17"</span><span class="o">,</span><span class="s">"+"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"+"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">22</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">该算式转化为常见的中缀算术表达式为</span><span class="err">：</span>
  <span class="o">((</span><span class="mi">10</span> <span class="o">*</span> <span class="o">(</span><span class="mi">6</span> <span class="o">/</span> <span class="o">((</span><span class="mi">9</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">11</span><span class="o">)))</span> <span class="o">+</span> <span class="mi">17</span><span class="o">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="o">=</span> <span class="o">((</span><span class="mi">10</span> <span class="o">*</span> <span class="o">(</span><span class="mi">6</span> <span class="o">/</span> <span class="o">(</span><span class="mi">12</span> <span class="o">*</span> <span class="o">-</span><span class="mi">11</span><span class="o">)))</span> <span class="o">+</span> <span class="mi">17</span><span class="o">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="o">=</span> <span class="o">((</span><span class="mi">10</span> <span class="o">*</span> <span class="o">(</span><span class="mi">6</span> <span class="o">/</span> <span class="o">-</span><span class="mi">132</span><span class="o">))</span> <span class="o">+</span> <span class="mi">17</span><span class="o">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="o">=</span> <span class="o">((</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">17</span><span class="o">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="o">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">17</span><span class="o">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="o">=</span> <span class="mi">17</span> <span class="o">+</span> <span class="mi">5</span>
<span class="o">=</span> <span class="mi">22</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= tokens.length &lt;= 104</li><li>tokens[i] 要么是一个算符（”+”、”-“、”*” 或 “/”），要么是一个在范围 [-200, 200] 内的整数</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">evalRPN</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">tokens</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">tokens</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"+"</span><span class="o">)</span> 
            <span class="o">||</span> <span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"-"</span><span class="o">)</span> 
            <span class="o">||</span> <span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"*"</span><span class="o">)</span> 
            <span class="o">||</span> <span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"/"</span><span class="o">)){</span>
                <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"+"</span><span class="o">)){</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"-"</span><span class="o">)){</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"*"</span><span class="o">)){</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">v2</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"/"</span><span class="o">)){</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="151-翻转字符串里的单词">151. 翻转字符串里的单词</h2><p>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。</p><p>说明：</p><p>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。 翻转后单词间应当仅用一个空格分隔。 翻转后的字符串中不应包含额外的空格。</p><p>提示：</p><p>1 &lt;= s.length &lt;= 104 s 包含英文大小写字母、数字和空格 ‘ ‘ s 中 至少存在一个 单词</p><p>进阶：</p><p>请尝试使用 O(1) 额外空间复杂度的原地解法。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseWords</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">//越过空格</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">==</span> <span class="sc">' '</span><span class="o">)</span> <span class="n">cur</span><span class="o">--;</span>
            <span class="c1">//计数子串</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">' '</span><span class="o">){</span>
                <span class="n">cnt</span><span class="o">++;</span>
                <span class="n">cur</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">cnt</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">trim</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump152"></span></p><h2 id="152乘积最大子数组">152.乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,-</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">6</span>
<span class="nl">解释:</span> <span class="n">子数组</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="n">有最大乘积</span> <span class="mi">6</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">0</span>
<span class="nl">解释:</span> <span class="n">结果不能为</span> <span class="mi">2</span><span class="o">,</span> <span class="n">因为</span> <span class="o">[-</span><span class="mi">2</span><span class="o">,-</span><span class="mi">1</span><span class="o">]</span> <span class="n">不是子数组</span><span class="err">。</span>
</pre></table></code></div></div><p>动态规划：</p><p>考虑<code class="language-plaintext highlighter-rouge">max[i]</code>为以第i个元素为结尾的最大子数组乘积，转移方程：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>max[i] = Math.max(max[i-1] <span class="err">*</span> nums[i], nums[i]);
</pre></table></code></div></div><p>这样考虑有一个问题，就是如果数字为：3,-4,5,-2，我们计算max[3]的时候，会得出5这样的结果，实际上应该是前面所有数字的乘积，这是因为我们没有考虑负数的情况。</p><p>所以为了将负数纳入考虑范围，我们再维护一个<code class="language-plaintext highlighter-rouge">min[i]</code>,表示以第i个元素为结尾的最小子数组乘积，这个<code class="language-plaintext highlighter-rouge">min[i]</code>，我们期望获得最小的乘积子数组，因此负数会被考虑在内。</p><p>所以当<code class="language-plaintext highlighter-rouge">nums[i]</code>为正数时，转移方程为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</pre></table></code></div></div><p>当<code class="language-plaintext highlighter-rouge">nums[i]</code>为负数时，转移方程为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">min</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</pre></table></code></div></div><p>合起来就是：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">{</span><span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">min</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]*</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]}</span>
</pre></table></code></div></div><p>同时<code class="language-plaintext highlighter-rouge">min[i]</code>也需要更新：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">min</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">min</span><span class="o">{</span><span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">min</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]*</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProduct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">max</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">min</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">max</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">min</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">min</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
            <span class="n">min</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">max</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">max</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>空间优化：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProduct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
      
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
      
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
      
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">max</span><span class="o">,</span> <span class="n">mn</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mx</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">mn</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">mn</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">mx</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>    
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="153-寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
<span class="n">解释</span><span class="err">：</span><span class="n">原数组为</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="err">，</span><span class="n">旋转</span> <span class="mi">3</span> <span class="n">次得到输入数组</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMin</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="c1">// if(nums[l] &lt; nums[r])   break;</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">//在右边，不能随便让r = mid-1，因为会跳过最小值</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="154-寻找旋转排序数组中的最小值-ii">154. 寻找旋转排序数组中的最小值 II</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><ul><li>当nums[mid] &lt; nums[r]时，可以忽略右半边；</li><li>当nums[mid] &gt; nums[r]时，可以忽略左半边；</li><li>当nums[mid] == nums[r]时，由于重复元素的存在，我们并不能确定 nums[mid] 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 nums[r]是不是最小值，都有一个它的「替代品」nums[mid]，因此我们可以忽略二分查找区间的右端点。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMin</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">])</span>   <span class="k">break</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">//可能存在重复值</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">r</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump160"></span></p><h2 id="160-相交链表">160. 相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><p>在节点 c1 开始相交。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/160_statement.png" alt="img" /></p><p>示例 1：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/160_example_1.png" alt="img" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">intersectVal</span> <span class="o">=</span> <span class="mi">8</span><span class="o">,</span> <span class="n">listA</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">listB</span> <span class="o">=</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">skipA</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">skipB</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="nc">Reference</span> <span class="n">of</span> <span class="n">the</span> <span class="n">node</span> <span class="n">with</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">输入解释</span><span class="err">：</span><span class="n">相交节点的值为</span> <span class="mi">8</span> <span class="err">（</span><span class="n">注意</span><span class="err">，</span><span class="n">如果两个链表相交则不能为</span> <span class="mi">0</span><span class="err">）。</span><span class="n">从各自的表头开始算起</span><span class="err">，</span><span class="n">链表</span> <span class="no">A</span> <span class="n">为</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span><span class="err">，</span><span class="n">链表</span> <span class="no">B</span> <span class="n">为</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span><span class="err">。</span><span class="n">在</span> <span class="no">A</span> <span class="n">中</span><span class="err">，</span><span class="n">相交节点前有</span> <span class="mi">2</span> <span class="n">个节点</span><span class="err">；</span><span class="n">在</span> <span class="no">B</span> <span class="n">中</span><span class="err">，</span><span class="n">相交节点前有</span> <span class="mi">3</span> <span class="n">个节点</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">intersectVal</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">listA</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="n">listB</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="n">skipA</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">skipB</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="nc">Reference</span> <span class="n">of</span> <span class="n">the</span> <span class="n">node</span> <span class="n">with</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输入解释</span><span class="err">：</span><span class="n">相交节点的值为</span> <span class="mi">2</span> <span class="err">（</span><span class="n">注意</span><span class="err">，</span><span class="n">如果两个链表相交则不能为</span> <span class="mi">0</span><span class="err">）。</span><span class="n">从各自的表头开始算起</span><span class="err">，</span><span class="n">链表</span> <span class="no">A</span> <span class="n">为</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span><span class="err">，</span><span class="n">链表</span> <span class="no">B</span> <span class="n">为</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span><span class="err">。</span><span class="n">在</span> <span class="no">A</span> <span class="n">中</span><span class="err">，</span><span class="n">相交节点前有</span> <span class="mi">3</span> <span class="n">个节点</span><span class="err">；</span><span class="n">在</span> <span class="no">B</span> <span class="n">中</span><span class="err">，</span><span class="n">相交节点前有</span> <span class="mi">1</span> <span class="n">个节点</span><span class="err">。</span>
</pre></table></code></div></div><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">getIntersectionNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">headA</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">headB</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">headA</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">headB</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">ptr1</span><span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">ptr2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//ptr1和ptr2分别从A和B链表头移动，到尾部后，移动到另外一个链表，直到相遇或遍历完毕</span>
        <span class="c1">//二者都为空时，也视为相遇，可以退出循环，但是空代表不相交</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">!=</span> <span class="n">ptr2</span><span class="o">){</span>
            <span class="n">ptr1</span> <span class="o">=</span> <span class="n">ptr1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">headB</span> <span class="o">:</span> <span class="n">ptr1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr2</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">headA</span> <span class="o">:</span> <span class="n">ptr2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>


        <span class="k">return</span> <span class="n">ptr1</span><span class="o">;</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="162-寻找峰值">162. 寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞ 。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 1000</li><li>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</li><li>对于所有有效的 i 都有 nums[i] != nums[i + 1]</li></ul><p>进阶：你可以实现时间复杂度为 O(logN) 的解决方案吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findPeakElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//分治查找峰值</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//肯定存在峰值，如果遇到了递减序列，那么有峰值在左侧；反之在右侧</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="c1">//向下取整，mid+1肯定不会溢出</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">l</span><span class="o">;</span>
    <span class="o">}</span>
    
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump164"></span></p><h2 id="164最大间距">164.最大间距</h2><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p><p>如果数组元素个数小于 2，则返回 0。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">3</span>
<span class="nl">解释:</span> <span class="n">排序后的数组是</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">],</span> <span class="n">其中相邻元素</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span> <span class="n">和</span> <span class="o">(</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">)</span> <span class="n">之间都存在最大差值</span> <span class="mi">3</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">10</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">0</span>
<span class="nl">解释:</span> <span class="n">数组元素个数小于</span> <span class="mi">2</span><span class="err">，</span><span class="n">因此返回</span> <span class="mi">0</span><span class="err">。</span>
</pre></table></code></div></div><p>说明:</p><ul><li>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。</li><li>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximumGap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//基数排序</span>
        <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nums</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">exp</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="k">while</span><span class="o">(</span><span class="n">maxVal</span> <span class="o">&gt;=</span> <span class="n">exp</span><span class="o">){</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
            <span class="c1">//统计这一位上各个数字出现的次数</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">exp</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">digit</span><span class="o">]++;</span>
            <span class="o">}</span>
            <span class="c1">//让cnt内的值有序</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="c1">//倒着填回去</span>
            <span class="c1">//如果不是倒着填</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">exp</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
                <span class="n">buf</span><span class="o">[</span><span class="n">cnt</span><span class="o">[</span><span class="n">digit</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">digit</span><span class="o">]--;</span>
            <span class="o">}</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">buf</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            <span class="n">exp</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>因此，我们可以选取整数 \(d = \lfloor (\textit{max}-\textit{min}) / (N-1) \rfloor &lt; \lceil (\textit{max}-\textit{min}) / (N-1)\) 。随后，我们将整个区间划分为若干个大小为 dd 的桶，并找出每个整数所在的桶。根据前面的结论，能够知道，元素之间的最大间距一定不会出现在某个桶的内部，而一定会出现在不同桶当中。</p><p>因此，在找出每个元素所在的桶之后，我们可以维护每个桶内元素的最大值与最小值。随后，只需从前到后不断比较相邻的桶，用后一个桶的最小值与前一个桶的最大值之差作为两个桶的间距，最终就能得到所求的答案。</p><h2 id="165-比较版本号">165. 比较版本号</h2><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><ul><li>如果 version1 &gt; version2 返回 1，</li><li>如果 version1 &lt; version2 返回 -1，</li><li>除此之外返回 0。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareVersion</span><span class="o">(</span><span class="nc">String</span> <span class="n">version1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">version2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//忽略任何前导零后的整数值</span>
        <span class="c1">//如果版本号没有指定某个下标处的修订号，则该修订号视为 0</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="n">version1</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\."</span><span class="o">);</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">version2</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\."</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//修订号</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&lt;</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">ptr2</span> <span class="o">&lt;</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">ptr1</span> <span class="o">&gt;=</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">arr1</span><span class="o">[</span><span class="n">ptr1</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">ptr2</span> <span class="o">&gt;=</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">arr2</span><span class="o">[</span><span class="n">ptr2</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">m1</span> <span class="o">&gt;</span> <span class="n">m2</span><span class="o">){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">m1</span> <span class="o">&lt;</span> <span class="n">m2</span><span class="o">){</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">ptr1</span><span class="o">++;</span>
            <span class="n">ptr2</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="166-分数到小数">166. 分数到小数</h2><p>给定两个整数，分别表示分数的分子 <code class="language-plaintext highlighter-rouge">numerator</code> 和分母 <code class="language-plaintext highlighter-rouge">denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p><p>对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 <code class="language-plaintext highlighter-rouge">10^4</code> 。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入：numerator = 1, denominator = 2
输出："0.5"
</pre></table></code></div></div><p>解题的关键点在于，如果余数重复出现了，说明小数开始循环了</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">fractionToDecimal</span><span class="o">(</span><span class="kt">int</span> <span class="n">numerator</span><span class="o">,</span> <span class="kt">int</span> <span class="n">denominator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">numerator</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="c1">//有一者为负数，一者为正数，那么结果必定为负数</span>
        <span class="k">if</span><span class="o">(</span><span class="n">numerator</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">denominator</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"-"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//为了处理 -214783648/-1溢出的情况，将int转为long处理</span>
        <span class="c1">//被除数</span>
        <span class="kt">long</span> <span class="n">dividend</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">numerator</span><span class="o">));</span>
        <span class="c1">//除数</span>
        <span class="kt">long</span> <span class="n">divisor</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">denominator</span><span class="o">));</span>
        <span class="c1">//先取整数部分</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">dividend</span> <span class="o">/</span> <span class="n">divisor</span><span class="o">));</span>
        <span class="kt">long</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">dividend</span> <span class="o">%</span> <span class="n">divisor</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//处理小数部分</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"."</span><span class="o">);</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//除余不为0</span>
        <span class="k">while</span><span class="o">(</span><span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">//当余数发生循环时，结果必定发生循环</span>
            <span class="c1">//所以在发生循环前插入一个(，在最后追加一个)就能把循环的部分括起来</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">remainder</span><span class="o">)){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">remainder</span><span class="o">),</span> <span class="s">"("</span><span class="o">);</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">")"</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//将余数作为key，余数出现的开头索引为值，记录一下</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">remainder</span><span class="o">,</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="c1">//余数扩大10倍，然后求商，和草稿本上运算方法是一样的，就是后面加个0嘛</span>
            <span class="n">remainder</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">;</span>
            <span class="c1">//记录除后的结果</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">remainder</span> <span class="o">/</span> <span class="n">divisor</span><span class="o">));</span>
            <span class="c1">//继续取余</span>
            <span class="n">remainder</span> <span class="o">%=</span> <span class="n">divisor</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="167-两数之和-ii---输入有序数组">167. 两数之和 II - 输入有序数组</h2><p>给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p><p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p><p>示例 1：</p><p>输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><p>双指针的正确性：</p><ul><li>如果numbers[l] + numbers[r] &lt; target，无论再缩小r同时增大l都不会让和更大，只能保持r，增大l。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">l</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">r</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="168-excel表列名称">168. Excel表列名称</h2><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p><p>例如，</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">convertToTitle</span><span class="o">(</span><span class="kt">int</span> <span class="n">columnNumber</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//26进制</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="c1">//在计算前需要将columnNumber-1，让余数0对应A，余数1对应B。</span>
        <span class="k">while</span><span class="o">(</span><span class="n">columnNumber</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">((</span><span class="kt">char</span><span class="o">)(</span><span class="n">columnNumber</span> <span class="o">%</span> <span class="mi">26</span> <span class="o">+</span> <span class="sc">'A'</span><span class="o">));</span>
            <span class="n">columnNumber</span> <span class="o">/=</span> <span class="mi">26</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump169"></span></p><h2 id="169-多数元素">169. 多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">3</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
</pre></table></code></div></div><ol><li><p>最简单的是排序，排完之后，索引n/2位置的就是众数。</p></li><li><p>我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p></li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">countInRange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">majorityElementRec</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// base case; the only element in an array of size 1 is the majority</span>
        <span class="c1">// element.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// recurse on left and right halves of this slice.</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lo</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">majorityElementRec</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">majorityElementRec</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>

        <span class="c1">// if the two halves agree on the majority element, return it.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// otherwise, count each element and return the "winner".</span>
        <span class="kt">int</span> <span class="n">leftCount</span> <span class="o">=</span> <span class="n">countInRange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="n">countInRange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">leftCount</span> <span class="o">&gt;</span> <span class="n">rightCount</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">majorityElementRec</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li><p>摩尔投票法：如果我们把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 <code class="language-plaintext highlighter-rouge">0</code>，从结果本身我们可以看出众数比其他数多。</p><ol><li>如果候选人不是众数，则众数会和其他非候选人一起反对候选人，所以候选人一定会下台(count==0时发生换届选举)</li><li>如果候选人是众数，则众数会支持自己，其他候选人会反对，同样因为众数票数超过一半，所以众数一定会成功当选。</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">Integer</span> <span class="n">candidate</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">candidate</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
   
        <span class="k">return</span> <span class="n">candidate</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></li></ol><h2 id="171-excel表列序号">171. Excel表列序号</h2><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p><p>例如，</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
...
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">titleToNumber</span><span class="o">(</span><span class="nc">String</span> <span class="n">columnTitle</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//进制转换</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">columnTitle</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">*=</span> <span class="mi">26</span><span class="o">;</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">columnTitle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="172-阶乘后的零">172. 阶乘后的零</h2><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="mi">0</span>
<span class="nl">解释:</span> <span class="mi">3</span><span class="o">!</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">尾数中没有零</span><span class="err">。</span>
</pre></table></code></div></div><ul><li>说明: 你算法的时间复杂度应为 O(log n) 。</li></ul><p>什么数会导致0增多？<code class="language-plaintext highlighter-rouge">2*5</code>对 会加个0，那么10可以看做<code class="language-plaintext highlighter-rouge">2*5</code>，所以只要关注数字2和数字5就可以了</p><p>所以对<code class="language-plaintext highlighter-rouge">1*2*3*...*10</code>拆分，为<code class="language-plaintext highlighter-rouge">1*2*3*(2*2)*5*(2*3)*7*(2*2*2)*9*(2*5)</code></p><p>观察得知，在10区间内，2的数量比5的数量多，那么2、5对的数量取决于5的数量</p><p>那么只需要得知每个数字能贡献出多少个5因子即可。</p><p>但是进一步观察，我们发现每隔5个数字，数字5出现一个，每隔25个数字，数字5出现2个，每隔125个数字，数字5出现3个</p><p>那么容易得知，间隔5个数字，能贡献的数字5数量为n/5，间隔25个数字，能贡献的数字5数量为n/25</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">trailingZeroes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">//累加5的个数</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="o">(</span><span class="n">n</span><span class="o">/</span><span class="mi">5</span><span class="o">);</span>
            <span class="c1">//让底数增加 5 -&gt; 25 -&gt; 125 -&gt; ...</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump189"></span></p><h2 id="189-旋转数组">189. 旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span> <span class="n">和</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">解释:</span>
<span class="n">向右旋转</span> <span class="mi">1</span> <span class="nl">步:</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span>
<span class="n">向右旋转</span> <span class="mi">2</span> <span class="nl">步:</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="n">向右旋转</span> <span class="mi">3</span> <span class="nl">步:</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">100</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">99</span><span class="o">]</span> <span class="n">和</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">99</span><span class="o">,-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">100</span><span class="o">]</span>
<span class="nl">解释:</span> 
<span class="n">向右旋转</span> <span class="mi">1</span> <span class="nl">步:</span> <span class="o">[</span><span class="mi">99</span><span class="o">,-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">100</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">向右旋转</span> <span class="mi">2</span> <span class="nl">步:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">99</span><span class="o">,-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">100</span><span class="o">]</span>
</pre></table></code></div></div><p>说明:</p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 原地 算法。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">k</span> <span class="o">%=</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">//1,2,3,4,5,6,7</span>
        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span><span class="c1">//7,6,5,4,3,2,1</span>
        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span><span class="c1">//5,6,7,4,3,2,1</span>
        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span><span class="c1">//5,6,7,1,2,3,4</span>

    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="o">)</span>  <span class="k">return</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">h</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">l</span><span class="o">++;</span>
            <span class="n">h</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump198"></span></p><h2 id="198-打家劫舍">198. 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">偷窃</span> <span class="mi">1</span> <span class="n">号房屋</span> <span class="o">(</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span> <span class="err">，</span><span class="n">然后偷窃</span> <span class="mi">3</span> <span class="n">号房屋</span> <span class="o">(</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">3</span><span class="o">)</span><span class="err">。</span>
     <span class="n">偷窃到的最高金额</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">4</span> <span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">12</span>
<span class="n">解释</span><span class="err">：</span><span class="n">偷窃</span> <span class="mi">1</span> <span class="n">号房屋</span> <span class="o">(</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">2</span><span class="o">),</span> <span class="n">偷窃</span> <span class="mi">3</span> <span class="n">号房屋</span> <span class="o">(</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">9</span><span class="o">)</span><span class="err">，</span><span class="n">接着偷窃</span> <span class="mi">5</span> <span class="n">号房屋</span> <span class="o">(</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span><span class="err">。</span>
     <span class="n">偷窃到的最高金额</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">12</span> <span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 400</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//dp[i][1]表示要偷第i户人家，dp[i][0]表示不偷第i户人家</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>空间优化：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//d表示要偷第i户人家，nd表示不偷第i户人家</span>
        <span class="kt">int</span> <span class="n">nd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp_nd</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">nd</span><span class="o">);</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">nd</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">nd</span> <span class="o">=</span> <span class="n">tmp_nd</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">nd</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump200"></span></p><h2 id="200岛屿数量">200.岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">],</span>
  <span class="o">[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">],</span>
  <span class="o">[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">],</span>
  <span class="o">[</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">]</span>
<span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">],</span>
  <span class="o">[</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">],</span>
  <span class="o">[</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">],</span>
  <span class="o">[</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"1"</span><span class="o">]</span>
<span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
</pre></table></code></div></div><p>提示：</p><ul><li>m == grid.length</li><li>n == grid[i].length</li><li>1 &lt;= m, n &lt;= 300</li><li>grid[i][j] 的值为 ‘0’ 或 ‘1’</li></ul><p>非常简单的深搜题：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numIslands</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">grid</span><span class="o">);</span>
                    <span class="n">cnt</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span> <span class="o">||</span> <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="kc">true</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">grid</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">grid</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">grid</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">grid</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump201"></span></p><h2 id="201数字范围按位与">201.数字范围按位与</h2><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">4</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">0</span>
</pre></table></code></div></div><h3 id="分析法-最长公共前缀">分析法-最长公共前缀</h3><p>通过分析，若m和n转为二进制字符串后，长度不一致，则在这个范围内按位与后，结果必为0。例如：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>m = 11110011
n = 101101111
在范围[m,n]中，肯定会出现100000000的情况，所以有：
100000000 &amp; 101101111 = 100000000,且100000000 &amp; 11111111 = 000000000
所以结果为0
</pre></table></code></div></div><p>长度一致的情况下，结果就是m和n的最长公共前缀。</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>m = 101101101
n = 101101111
最长前缀为1011011，最后两位需要归0，因为在范围[m,n]中，会出现数字101101100使得最终结果的两位归0。
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rangeBitwiseAnd</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span>  <span class="k">return</span> <span class="n">m</span><span class="o">;</span>

        <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">//找到两个字符串第一个不同的位置</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//取出其公共前缀，剩余位都替换为0</span>
        <span class="nc">String</span> <span class="n">sub1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">index</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">sub2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">index</span><span class="o">,</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
        <span class="n">sub2</span> <span class="o">=</span> <span class="n">sub2</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="n">sub1</span> <span class="o">+</span> <span class="n">sub2</span><span class="o">;</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseUnsignedInt</span><span class="o">(</span><span class="n">res</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="202-快乐数">202. 快乐数</h2><p>编写一个算法来判断一个数 <code class="language-plaintext highlighter-rouge">n</code> 是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果 <strong>可以变为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code class="language-plaintext highlighter-rouge">n</code> 是快乐数就返回 <code class="language-plaintext highlighter-rouge">true</code> ；不是，则返回 <code class="language-plaintext highlighter-rouge">false</code> 。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHappy</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</span>
        <span class="c1">//然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</span>
        <span class="c1">//如果 可以变为  1，那么这个数就是快乐数。</span>
        <span class="c1">//如果 n 是快乐数就返回 true ；不是，则返回 false 。</span>
        <span class="c1">//肯定使用哈希表存状态，当状态重复出现时，就返回false</span>
        <span class="c1">//存数字n还是拆分序列呢？</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
                <span class="n">n</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">sum</span><span class="o">))</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="203-移除链表元素">203. 移除链表元素</h2><p>给你一个链表的头节点 <code class="language-plaintext highlighter-rouge">head</code> 和一个整数 <code class="language-plaintext highlighter-rouge">val</code> ，请你删除链表中所有满足 <code class="language-plaintext highlighter-rouge">Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeElements</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">val</span><span class="o">){</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump204"></span></p><h2 id="204计数质数">204.计数质数</h2><p>统计所有小于非负整数 n 的质数的数量。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">小于</span> <span class="mi">10</span> <span class="n">的质数一共有</span> <span class="mi">4</span> <span class="n">个</span><span class="o">,</span> <span class="n">它们是</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span> <span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">0</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">0</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= n &lt;= 5 * 106</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//要判断数字x是不是质数，需要判断[2,x-1]中的每个数是否都不是x的因数</span>
    <span class="c1">//考虑到如果y是x的因数，那么x/y肯定也是x的因数是，所以只需要判断y或者x/y是不是x的因数即可</span>
    <span class="c1">//而y和x/y的较小值肯定落在[2,√x]中，所以只要枚举[2,√x]的值即可</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countPrimes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">isPrime</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//埃式筛：由希腊数学家厄拉多塞（Eratosthenes）提出</span>
    <span class="c1">//如果x是质数，那么2x,3x,...等肯定不是质数</span>
    <span class="c1">//所以只要用一个数组，记录下标对应的数字是不是质数即可</span>
    <span class="c1">//遇到一个质数，就将其所有的倍数下标标记为合数</span>
    <span class="c1">//优化：应该从x*x开始标记，因为2x,3x,...这些数一定在x之前就被其他质数的倍数标记了，例如2的所有倍数</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countPrimes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">isPrime</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">isPrime</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isPrime</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>

                <span class="k">if</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="o">){</span>
                        <span class="n">isPrime</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump206"></span></p><h2 id="206反转链表">206.反转链表</h2><p>反转一个单链表。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="no">NULL</span>
<span class="nl">输出:</span> <span class="mi">5</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="no">NULL</span>
</pre></table></code></div></div><p>进阶:</p><ul><li>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</li></ul><p>迭代：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>递归:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">return</span> <span class="nf">reverse</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">ListNode</span> <span class="nf">reverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">pre</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">p</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump207"></span></p><h2 id="207-课程表">207. 课程表</h2><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">2</span><span class="o">,</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span> 
<span class="nl">输出:</span> <span class="kc">true</span>
<span class="nl">解释:</span> <span class="n">总共有</span> <span class="mi">2</span> <span class="n">门课程</span><span class="err">。</span><span class="n">学习课程</span> <span class="mi">1</span> <span class="n">之前</span><span class="err">，</span><span class="n">你需要完成课程</span> <span class="mi">0</span><span class="err">。</span><span class="n">所以这是可能的</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">2</span><span class="o">,</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="kc">false</span>
<span class="nl">解释:</span> <span class="n">总共有</span> <span class="mi">2</span> <span class="n">门课程</span><span class="err">。</span><span class="n">学习课程</span> <span class="mi">1</span> <span class="n">之前</span><span class="err">，</span><span class="n">你需要先完成课程</span> <span class="mi">0</span><span class="err">；</span><span class="n">并且学习课程</span> <span class="mi">0</span> <span class="n">之前</span><span class="err">，</span><span class="n">你还应先完成课程</span> <span class="mi">1</span><span class="err">。</span><span class="n">这是不可能的</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</li><li>你可以假定输入的先决条件中没有重复的边。</li><li>1 &lt;= numCourses &lt;= 10^5</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//深度优先遍历：判断图是否有环</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canFinish</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//建立邻接表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">adj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">adj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">prerequisites</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">adj</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prerequisites</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">prerequisites</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">flag</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">adj</span><span class="o">,</span> <span class="n">flag</span><span class="o">)){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">flag</span><span class="o">){</span>
        <span class="c1">//flag -1表示从当前节点出发没有环路， 1表示从当前节点被访问过了， 0表示还没访问</span>
        <span class="k">if</span><span class="o">(</span><span class="n">flag</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">flag</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>     <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
        <span class="n">flag</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">v</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">dfs</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">adj</span><span class="o">,</span> <span class="n">flag</span><span class="o">)){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">flag</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">canFinish</span><span class="p">(</span><span class="n">numCourses</span> <span class="kt">int</span><span class="p">,</span> <span class="n">prerequisites</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="n">in</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">)</span>
    <span class="n">frees</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span> <span class="kt">int</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">)</span>
    <span class="n">next</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">prerequisites</span> <span class="p">{</span>
        <span class="c">//v[0]的入度++</span>
        <span class="n">in</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="m">0</span><span class="p">]]</span><span class="o">++</span>
        <span class="c">//让pre[1]指向pre[0]</span>
        <span class="n">frees</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="m">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">frees</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="m">1</span><span class="p">]],</span> <span class="n">v</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="c">//将所有入度为0的顶点放入next中</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="n">next</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">next</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">:=</span> <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c">//取出此节点指向的节点数组，入度均减1</span>
        <span class="n">v</span> <span class="o">:=</span> <span class="n">frees</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">v</span> <span class="p">{</span>
            <span class="n">in</span><span class="p">[</span><span class="n">vv</span><span class="p">]</span><span class="o">--</span>
            <span class="k">if</span> <span class="n">in</span><span class="p">[</span><span class="n">vv</span><span class="p">]</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
                <span class="n">next</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">vv</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="n">numCourses</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//AOV 网的拓扑排序</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canFinish</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">frees</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">frees</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prerequisites</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">in</span><span class="o">[</span><span class="n">prerequisites</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]]++;</span>
            <span class="n">frees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prerequisites</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">prerequisites</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">in</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">next</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">frees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">v</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
                <span class="n">in</span><span class="o">[</span><span class="n">v</span><span class="o">]--;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">in</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">next</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">numCourses</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump208"></span></p><h2 id="208-实现-trie-前缀树">208. 实现 Trie (前缀树)</h2><p>请你实现 Trie 类：</p><ul><li>Trie() 初始化前缀树对象。</li><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li></ul><p>提示：</p><ul><li>1 &lt;= word.length, prefix.length &lt;= 2000</li><li>word 和 prefix 仅由小写英文字母组成</li><li>insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="n">isEnd</span><span class="o">;</span>
  <span class="nc">Trie</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
  <span class="cm">/** Initialize your data structure here. */</span>
  <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>

  <span class="o">}</span>

  <span class="cm">/** Inserts a word into the trie. */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Trie</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
      <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
      <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">trie</span><span class="o">.</span><span class="na">table</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="n">trie</span><span class="o">.</span><span class="na">table</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="o">.</span><span class="na">table</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="n">trie</span><span class="o">.</span><span class="na">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/** Returns if the word is in the trie. */</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="n">searchPrefix</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">isEnd</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/** Returns if there is any word in the trie that starts with the given prefix. */</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">startsWith</span><span class="o">(</span><span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">searchPrefix</span><span class="o">(</span><span class="n">prefix</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">Trie</span> <span class="nf">searchPrefix</span><span class="o">(</span><span class="nc">String</span> <span class="n">prefix</span><span class="o">){</span>
    <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
      <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
      <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">table</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">table</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump209"></span></p><h2 id="209寻找长度最小的子数组">209.寻找长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p><p>示例:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
</pre></table></code></div></div><p>进阶:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。
</pre></table></code></div></div><h3 id="动态规划-3">动态规划</h3><p>dp[i]表示数组nums前i个元素中，符合条件的最短数组长度，为0时表示不符合条件。</p><p>状态方程：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>	dp[i] = min(f(i-1), f(i))
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//dp[i]表示数组nums前i个元素中，符合条件的最短数组长度，为0时表示不符合条件</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">yes</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">)</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="o">++</span><span class="n">tmp</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">){</span>
                    <span class="n">yes</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span> <span class="o">?</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">tmp</span><span class="o">)</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">yes</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="暴力法">暴力法</h3><p>暴力法是最直观的方法。初始化子数组的最小长度为无穷大，枚举数组<code class="language-plaintext highlighter-rouge">nums</code> 中的每个下标作为子数组的开始下标，对于每个开始下标 <code class="language-plaintext highlighter-rouge">i</code>，需要找到大于或等于 <code class="language-plaintext highlighter-rouge">i</code>的最小下标 <code class="language-plaintext highlighter-rouge">j</code>，使得从<code class="language-plaintext highlighter-rouge">nums[i]</code> 到<code class="language-plaintext highlighter-rouge">nums[j] </code>的元素和大于或等于<code class="language-plaintext highlighter-rouge">s</code>，并更新子数组的最小长度（此时子数组的长度是 <code class="language-plaintext highlighter-rouge">j-i+1</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="前缀和二分查找">前缀和+二分查找</h3><p>为了使用二分查找，需要额外创建一个数组 <code class="language-plaintext highlighter-rouge">sums</code> 用于存储数组<code class="language-plaintext highlighter-rouge"> nums</code> 的前缀和，其中 <code class="language-plaintext highlighter-rouge">sums[i]</code> 表示从<code class="language-plaintext highlighter-rouge">nums[0]</code> 到<code class="language-plaintext highlighter-rouge">nums[i−1]</code> 的元素和。得到前缀和之后，对于每个开始下标<code class="language-plaintext highlighter-rouge">i</code>，可通过二分查找得到大于或等于<code class="language-plaintext highlighter-rouge">i</code>的最小下标 <code class="language-plaintext highlighter-rouge">bound</code>，使得<code class="language-plaintext highlighter-rouge">sums[bound]−sums[i−1]≥s</code>，并更新子数组的最小长度（此时子数组的长度是 <code class="language-plaintext highlighter-rouge">bound−(i−1)</code>）。</p><p>因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span> 
        <span class="c1">// 为了方便计算，令 size = n + 1 </span>
        <span class="c1">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span>
        <span class="c1">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span>
        <span class="c1">// 以此类推</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">sums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">bound</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="n">sums</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bound</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="o">-</span><span class="n">bound</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bound</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">bound</span> <span class="o">-</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="双指针">双指针</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_长度最小的子数组.png" alt="leetcode_长度最小的子数组" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
                <span class="n">start</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">end</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="210-课程表-ii">210. 课程表 II</h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">2</span><span class="o">,</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span> 
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="n">总共有</span> <span class="mi">2</span> <span class="n">门课程</span><span class="err">。</span><span class="n">要学习课程</span> <span class="mi">1</span><span class="err">，</span><span class="n">你需要先完成课程</span> <span class="mi">0</span><span class="err">。</span><span class="n">因此</span><span class="err">，</span><span class="n">正确的课程顺序为</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">d</span><span class="o">;</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findOrder</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//拓扑排序</span>
        <span class="c1">//先建立邻接关系，然后计算每个节点的入度</span>
        <span class="c1">//每次选取入度为0的节点作为访问的点</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numCourses</span><span class="o">;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prerequisites</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//先修课程</span>
            <span class="kt">int</span> <span class="n">src</span> <span class="o">=</span> <span class="n">prerequisites</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">prerequisites</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="c1">//src -&gt; dst，先修课程 -&gt; 当前课程</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">dst</span><span class="o">);</span>
            <span class="n">d</span><span class="o">[</span><span class="n">dst</span><span class="o">]++;</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">bfs</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">bfs</span><span class="o">(){</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//找出所有入度为0的节点，放入队列</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">path</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="c1">//将该节点指向的所有节点入度-1</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">nbr</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">v</span><span class="o">)){</span>
                    <span class="n">d</span><span class="o">[</span><span class="n">nbr</span><span class="o">]--;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">d</span><span class="o">[</span><span class="n">nbr</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nbr</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">//必须有n个节点被选择到，否则返回空数组</span>
        <span class="k">if</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump214"></span></p><h2 id="214-最短回文串">214. 最短回文串</h2><p>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"aacecaaa"</span>
<span class="nl">输出:</span> <span class="s">"aaacecaaa"</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"abcd"</span>
<span class="nl">输出:</span> <span class="s">"dcbabcd"</span>
</pre></table></code></div></div><p>不难分析，“在字符串前添加字符，将其转换为回文串”，并且要求的回文串最短，说明只需要找到以第一个字符为起始的最长回文子串s1，然后将s-s1剩余的子串翻转放到s的前面即可。</p><p>找最长回文子串的方法有很多，动态规划、KMP、中心扩展等。<a href="#jump5">参考第5题。</a></p><p>本题用暴力判断+中心扩展法超时了，所以需要考虑KMP或Manacher算法。</p><p>另外，还有一个条件就是最长回文子串必须是以0为起始位置。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">shortestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="c1">//找到以第一个元素为起始的最大回文子串的结尾位置</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>

        <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">index</span><span class="o">;--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="n">s</span><span class="o">;</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// 得到预处理字符串</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">addBoundaries</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="sc">'#'</span><span class="o">);</span>
        <span class="c1">// 新字符串的长度</span>
        <span class="kt">int</span> <span class="n">sLen</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// 数组 p 记录了扫描过的回文子串的信息</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">sLen</span><span class="o">];</span>

        <span class="c1">// 双指针，它们是一一对应的，须同时更新</span>
        <span class="kt">int</span> <span class="n">maxRight</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">center</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxRight</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mirror</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">center</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
                <span class="c1">// 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span>
                <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">maxRight</span> <span class="o">-</span> <span class="n">i</span><span class="o">,</span> <span class="n">p</span><span class="o">[</span><span class="n">mirror</span><span class="o">]);</span>
            <span class="o">}</span>

            <span class="c1">// 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span>
            <span class="c1">//就是为了处理p[mirror] == marRight - i的情况</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

            <span class="c1">// left &gt;= 0 &amp;&amp; right &lt; sLen 保证不越界</span>
            <span class="c1">// str.charAt(left) == str.charAt(right) 表示可以扩散 1 次</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">sLen</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
                <span class="n">left</span><span class="o">--;</span>
                <span class="n">right</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span>
            <span class="c1">// 如果 maxRight 的值越大，进入上面 i &lt; maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span>
            <span class="c1">//更新maxRight，如果当前遍历到的中心i所能达到的最右端大于maxRight，就更新它</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">maxRight</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// maxRight 和 center 需要同时更新</span>
                <span class="n">maxRight</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 记录最长回文子串的长度和相应它在原始字符串中的起点</span>
                <span class="k">if</span><span class="o">((</span><span class="n">i</span> <span class="o">-</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">maxLen</span> <span class="o">=</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">maxLen</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">+</span><span class="n">maxLen</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="cm">/**
     * 创建预处理字符串
     */</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">addBoundaries</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">divide</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">divide</span><span class="o">);</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">divide</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump215"></span></p><h2 id="215数组中的第k大元素">215.数组中的第k大元素</h2><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
</pre></table></code></div></div><p>示例 2:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
</pre></table></code></div></div><p>说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h3 id="基于快速排序的选择方法">基于快速排序的选择方法</h3><p>每完成一轮快速排序，就有一个元素被放在正确的位置上，所以要找到数组第k大的元素，只需在第k大的元素被放置在正确的位置上时，返回其值即可。为了提高快速排序的性能，pivot的选择采用随机数的方式，这样可以避免每次都将数组分为1和n-1的极端情况。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
        <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findKthLargest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">quickSelect</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span><span class="o">);</span>
        <span class="o">}</span>
				<span class="c1">//快速选择算法</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">quickSelect</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">randomPartition</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">==</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">q</span><span class="o">];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">index</span> <span class="o">?</span> <span class="n">quickSelect</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span> <span class="o">:</span> <span class="n">quickSelect</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
			<span class="c1">//随机选择pivot</span>
       <span class="kd">public</span> <span class="kt">int</span> <span class="nf">randomPartition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">l</span><span class="o">;</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">l</span><span class="o">);</span>
            <span class="k">return</span> <span class="nf">partition</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">);</span>
       <span class="o">}</span>

       <span class="kd">public</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
            <span class="c1">//取第l个元素作为基准，此时已经在randomPartition中随机选择了一个数放在了l位置</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
						
            <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">])</span> <span class="o">--</span><span class="n">r</span><span class="o">;</span>
                <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
                <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">])</span> <span class="o">++</span><span class="n">l</span><span class="o">;</span>
                <span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">l</span><span class="o">;</span>
       <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="基于堆排序的选择方法">基于堆排序的选择方法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findKthLargest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">heapSize</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">buildMaxHeap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">heapSize</span><span class="o">);</span>
        <span class="c1">//排序出数组的后k-1个元素</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">--</span><span class="n">heapSize</span><span class="o">;</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">heapSize</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//前k-1大的元素已经被排序到数组的后方，则最大堆的根节点就是第k大元素</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildMaxHeap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">heapSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">heapSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">heapSize</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">maxHeapify</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">heapSize</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">heapSize</span><span class="o">;</span> <span class="n">j</span> <span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span><span class="mi">1</span><span class="o">){</span>
<span class="c1">//            若右孩子大于左孩子</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">heapSize</span><span class="o">)</span>
                <span class="o">++</span><span class="n">j</span><span class="o">;</span>
            <span class="c1">//如果当前值已经是最大值，则不做操作</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="c1">//若父节点的值小于其子节点最大值，则将子节点的值赋给父节点</span>
            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="c1">//记录原来父节点值应该放置的位置</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//放置父节点</span>
        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump216"></span></p><h2 id="216组合总和-iii">216.组合总和 III</h2><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">7</span>
<span class="nl">输出:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span>
<span class="nl">输出:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]]</span>
</pre></table></code></div></div><p>这题比这个系列的前两题简单，几个条件：</p><ul><li>只含有1-9的整数</li><li>组合不存在重复数字。</li></ul><p>这两个条件简化了许多操作，可以创建一个数组存放待取数字，<code class="language-plaintext highlighter-rouge">{1,2,3,4,5,6,7,8,9}</code>，每次固定一位，一共取k位数字。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum3</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//待取数字</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
        <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(),</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">cnt</span><span class="o">,</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span><span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">||</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//剪枝</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
            <span class="n">cnt</span><span class="o">++;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">cnt</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">list</span><span class="o">,</span><span class="n">sum</span><span class="o">);</span>
            <span class="n">cnt</span><span class="o">--;</span>
            <span class="n">sum</span><span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="218-天际线问题">218. 天际线问题</h2><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p><p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p><p>lefti 是第 i 座建筑物左边缘的 x 坐标。 righti 是第 i 座建筑物右边缘的 x 坐标。 heighti 是第 i 座建筑物的高度。 天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p><p><strong>示例 1：</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/Users/huangyucai/Library/Application Support/typora-user-images/image-20210713090052904.png" alt="image-20210713090052904" style="zoom: 50%;" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">buildings</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">2</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">15</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">],[</span><span class="mi">15</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">19</span><span class="o">,</span><span class="mi">24</span><span class="o">,</span><span class="mi">8</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">2</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">15</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">12</span><span class="o">],[</span><span class="mi">12</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">15</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">20</span><span class="o">,</span><span class="mi">8</span><span class="o">],[</span><span class="mi">24</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">图</span> <span class="no">A</span> <span class="n">显示输入的所有建筑物的位置和高度</span><span class="err">，</span>
<span class="n">图</span> <span class="no">B</span> <span class="n">显示由这些建筑物形成的天际线</span><span class="err">。</span><span class="n">图</span> <span class="no">B</span> <span class="n">中的红点表示输出列表中的关键点</span><span class="err">。</span>
</pre></table></code></div></div><p>我们发现，所有关键点都是建筑的左右边缘，所以我们考虑每一座建筑的边缘作为横坐标，这样对应的纵坐标为包含该横坐标建筑的最大高度。当关键点是建筑的右边缘时，该建筑的高度无贡献，所以我们可以枚举建筑的每个边缘作为关键点的横坐标，过程中检查每一座建筑是否包含该横坐标，找到最大高度记为该关键点的纵坐标。</p><p>算法的时间复杂度是O(n^2)，用优先队列优化最大高度的查找。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">getSkyline</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">buildings</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">boundaries</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">building</span> <span class="o">:</span> <span class="n">buildings</span><span class="o">){</span>
            <span class="c1">//将关键点放入数组</span>
            <span class="n">boundaries</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">building</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            <span class="n">boundaries</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">building</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">//排序</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">boundaries</span><span class="o">);</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//遍历关键点</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">boundary</span> <span class="o">:</span> <span class="n">boundaries</span><span class="o">){</span>
            <span class="c1">//当前建筑的范围包含横坐标boundary，就入队</span>
            <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">buildings</span><span class="o">[</span><span class="n">idx</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">boundary</span> <span class="o">&amp;&amp;</span> <span class="n">buildings</span><span class="o">[</span><span class="n">idx</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">boundary</span><span class="o">){</span>
                <span class="c1">//将右边缘和高度入队</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">buildings</span><span class="o">[</span><span class="n">idx</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">buildings</span><span class="o">[</span><span class="n">idx</span><span class="o">][</span><span class="mi">2</span><span class="o">]});</span>
                <span class="n">idx</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">//如果右边缘小于等于boundary，那这个建筑不包含boundary</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">pq</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">boundary</span><span class="o">){</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">pq</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">1</span><span class="o">];</span>
            <span class="c1">//如果上一个关键点的高度和当前max相同的话，那这个点就不是关键点了</span>
            <span class="k">if</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">max</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">boundary</span><span class="o">,</span> <span class="n">max</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="219-存在重复元素-ii">219. 存在重复元素 II</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><p><strong>示例 1:</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: nums = [1,2,3,1], k = 3
输出: true
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">)</span>  <span class="n">k</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">//数组中是否存在两个元素，满足值相等，并且索引差为k</span>
        <span class="c1">//滑动窗口，在k的滑动窗口内，是否有两个数字是相等的</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//窗口增长期</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span>   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">//窗口滑动期</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span>   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="220-存在重复元素-iii">220. 存在重复元素 III</h2><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和两个整数 <code class="language-plaintext highlighter-rouge">k</code> 和 <code class="language-plaintext highlighter-rouge">t</code> 。请你判断是否存在 <strong>两个不同下标</strong> <code class="language-plaintext highlighter-rouge">i</code> 和 <code class="language-plaintext highlighter-rouge">j</code>，使得 <code class="language-plaintext highlighter-rouge">abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code class="language-plaintext highlighter-rouge">abs(i - j) &lt;= k</code> 。</p><p>如果存在则返回 <code class="language-plaintext highlighter-rouge">true</code>，不存在返回 <code class="language-plaintext highlighter-rouge">false</code>。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//滑动窗口</span>
        <span class="c1">//两个元素的差值在t以内，相距索引在k以内</span>
        <span class="c1">//首先是滑动窗口，保证索引都在k以内</span>
        <span class="c1">//其次，在窗口内如果出现两个元素的差值在t以内，就返回TRUE</span>
        <span class="c1">//新增加一个元素入窗口，如何判断这个元素和其他元素的差值？</span>
        <span class="c1">//遍历的话，复杂度有些高；不遍历的话，又可能漏掉case</span>
        <span class="c1">//我们的目的是在窗口内找到最接近nums[i]的数字</span>
        <span class="c1">//比nums[i]小的最大值，比nums[i]大的最小值</span>
        <span class="c1">//所以很容易想到用二分查找解决，这题更好的解法是红黑树</span>
        <span class="c1">//可以用TreeSet实现</span>
        <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="mi">1L</span><span class="o">;</span>
            <span class="nc">Long</span> <span class="n">floorVal</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">floor</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
            <span class="nc">Long</span> <span class="n">ceilVal</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">ceiling</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">floorVal</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">-</span> <span class="n">floorVal</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ceilVal</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ceilVal</span> <span class="o">-</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">]</span> <span class="o">*</span> <span class="mi">1L</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump221"></span></p><h2 id="221最大正方形">221.最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span>

<span class="nl">输出:</span> <span class="mi">4</span>
</pre></table></code></div></div><p>动态规划，<code class="language-plaintext highlighter-rouge">dp[i][j]</code>表示以<code class="language-plaintext highlighter-rouge">(i,j)</code>为右下角的正方形的最大边长。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximalSquare</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//dp[i][j]表示以(i,j)为右下角的正方形的最大边长</span>
        <span class="c1">//dp[i][j]的值由其左方，上方，左上方的dp值得到。</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//边界初始化</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'1'</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]),</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span> <span class="o">*</span> <span class="n">max</span><span class="o">;</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump222"></span></p><h2 id="222完全二叉树的节点个数">222.完全二叉树的节点个数</h2><p>给出一个完全二叉树，求出该树的节点个数。</p><p>说明：</p><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
    <span class="mi">1</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">2</span>   <span class="mi">3</span>
 <span class="o">/</span> <span class="err">\</span>  <span class="o">/</span>
<span class="mi">4</span>  <span class="mi">5</span> <span class="mi">6</span>

<span class="nl">输出:</span> <span class="mi">6</span>
</pre></table></code></div></div><p>层序遍历：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countNodes</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//首先求出二叉树的深度，再遍历倒数第二层的节点，统计最后一层的节点个数</span>
        <span class="c1">//由于是完全二叉树，所以只要持续探索左节点，就能得到深度</span>
        <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">depth</span><span class="o">++;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//层序遍历，直到到达第depth-1层</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">depth</span><span class="o">;</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">){</span>
            <span class="n">cnt</span><span class="o">--;</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//此时queue中的节点都是倒数第二层的节点</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">res</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">res</span><span class="o">+=</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>二分+位运算</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countNodes</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//首先求出二叉树的深度</span>
        <span class="c1">//由于是完全二叉树，所以只要持续探索左节点，就能得到深度</span>
        <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">depth</span><span class="o">++;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//知道了深度，就知道了此二叉树的节点数范围：2^depth~2^(depth+1)-1</span>
        <span class="c1">//可以利用二分搜索确定节点数</span>
        <span class="c1">// 1 00000 ～ 1 11111</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">depth</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">low</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"mid:"</span> <span class="o">+</span> <span class="n">mid</span><span class="o">);</span>
            <span class="c1">//判断二叉树是否有mid个节点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">exist</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">depth</span><span class="o">,</span> <span class="n">mid</span><span class="o">)){</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">low</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//根据节点编号寻找路径，最后判断节点是否为空，即可知道第mid个节点是否存在了</span>
    <span class="c1">//比如第mid个节点是第6个节点，那么编号为110，则1 0 表示二叉树先往右子树移动再往左子树移动，即可到达mid节点</span>
    <span class="kt">boolean</span> <span class="nf">exist</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">){</span>
        <span class="c1">//取出 11111，即最后一层的最大节点数</span>
        <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"mid:"</span> <span class="o">+</span> <span class="n">mid</span> <span class="o">+</span> <span class="s">"; bits :"</span> <span class="o">+</span> <span class="n">bits</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">mid</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote><p>立即推—&gt;白板撸代码无用！</p><p>递归交换：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">invert</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>迭代交换：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
      	<span class="c1">//层序遍历</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="c1">//交换子节点</span>
                <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="223-矩形面积">223. 矩形面积</h2><p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的</strong> 矩形，请你计算并返回两个矩形覆盖的总面积。</p><p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p><ul><li>第一个矩形由其左下顶点 <code class="language-plaintext highlighter-rouge">(ax1, ay1)</code> 和右上顶点 <code class="language-plaintext highlighter-rouge">(ax2, ay2)</code> 定义。</li><li>第二个矩形由其左下顶点 <code class="language-plaintext highlighter-rouge">(bx1, by1)</code> 和右上顶点 <code class="language-plaintext highlighter-rouge">(bx2, by2)</code> 定义。</li></ul><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入：ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
输出：45
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">computeArea</span><span class="o">(</span><span class="kt">int</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="no">B</span><span class="o">,</span> <span class="kt">int</span> <span class="no">C</span><span class="o">,</span> <span class="kt">int</span> <span class="no">D</span><span class="o">,</span> <span class="kt">int</span> <span class="no">E</span><span class="o">,</span> <span class="kt">int</span> <span class="no">F</span><span class="o">,</span> <span class="kt">int</span> <span class="no">G</span><span class="o">,</span> <span class="kt">int</span> <span class="no">H</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//第一个矩形的左下顶点是(A,B)，右上顶点是(C,D)</span>
        <span class="c1">//第二个矩形的左下顶点是(E,F)，右上顶点是(G,H)</span>
        <span class="c1">//求覆盖的总面积，那其实是二者面积之和，再减去一份重叠的面积</span>
        <span class="kt">int</span> <span class="n">area1</span> <span class="o">=</span> <span class="o">(</span><span class="no">D</span><span class="o">-</span><span class="no">B</span><span class="o">)*(</span><span class="no">C</span><span class="o">-</span><span class="no">A</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">area2</span> <span class="o">=</span> <span class="o">(</span><span class="no">H</span><span class="o">-</span><span class="no">F</span><span class="o">)*(</span><span class="no">G</span><span class="o">-</span><span class="no">E</span><span class="o">);</span>
        <span class="c1">//重叠部分该如何计算？</span>
        <span class="c1">//1. 如果完全重叠，即呈包含</span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span> <span class="o">&lt;=</span> <span class="no">E</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&gt;=</span> <span class="no">G</span> <span class="o">&amp;&amp;</span> <span class="no">B</span> <span class="o">&lt;=</span> <span class="no">F</span> <span class="o">&amp;&amp;</span> <span class="no">D</span> <span class="o">&gt;=</span> <span class="no">H</span><span class="o">)</span>    <span class="k">return</span> <span class="n">area1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span> <span class="o">&gt;=</span> <span class="no">E</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&lt;=</span> <span class="no">G</span> <span class="o">&amp;&amp;</span> <span class="no">B</span> <span class="o">&gt;=</span> <span class="no">F</span> <span class="o">&amp;&amp;</span> <span class="no">D</span> <span class="o">&lt;=</span> <span class="no">H</span><span class="o">)</span>    <span class="k">return</span> <span class="n">area2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">area</span> <span class="o">=</span> <span class="n">area1</span> <span class="o">+</span> <span class="n">area2</span><span class="o">;</span>
        <span class="c1">//2.任意一者是点或者线 </span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span> <span class="o">==</span> <span class="no">C</span> <span class="o">||</span> <span class="no">B</span> <span class="o">==</span> <span class="no">D</span><span class="o">)</span>    <span class="k">return</span> <span class="n">area</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="no">E</span> <span class="o">==</span> <span class="no">G</span> <span class="o">||</span> <span class="no">F</span> <span class="o">==</span> <span class="no">H</span><span class="o">)</span>    <span class="k">return</span> <span class="n">area</span><span class="o">;</span>
        <span class="c1">//3.只要Y的区间或者X的区间有一者不交叉，那么就不重叠</span>
        <span class="c1">//好，第一个矩形的Y区间是[B,D]，X区间是[A,C]</span>
        <span class="c1">//同理，第二个矩形Y区间是[F,H]，X区间是[E,G]</span>
        <span class="c1">//Y区间不重叠</span>
        <span class="k">if</span><span class="o">(</span><span class="no">H</span> <span class="o">&lt;=</span> <span class="no">B</span> <span class="o">||</span> <span class="no">F</span> <span class="o">&gt;=</span> <span class="no">D</span><span class="o">)</span>    <span class="k">return</span> <span class="n">area</span><span class="o">;</span>
        <span class="c1">//X区间不重叠</span>
        <span class="k">if</span><span class="o">(</span><span class="no">G</span> <span class="o">&lt;=</span> <span class="no">A</span> <span class="o">||</span> <span class="no">C</span> <span class="o">&lt;=</span> <span class="no">E</span><span class="o">)</span>    <span class="k">return</span> <span class="n">area</span><span class="o">;</span>
        <span class="c1">//到这里，说明二者有重叠区间</span>
        <span class="c1">//重叠时，我们选取两个矩形左边界的较大者作为左边界</span>
        <span class="c1">//      右边界的较小者作为右边界；上边界的较小者为上边界;下边界的较大者为下边界</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="no">A</span><span class="o">,</span><span class="no">E</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">C</span><span class="o">,</span><span class="no">G</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">D</span><span class="o">,</span><span class="no">H</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="no">B</span><span class="o">,</span><span class="no">F</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">area</span> <span class="o">-</span> <span class="o">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">)*(</span><span class="n">t</span><span class="o">-</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="224-基本计算器">224. 基本计算器</h2><p>实现一个基本的计算器来计算一个简单的字符串表达式 s 的值。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"(1+(4+5+2)-3)+(6+8)"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">23</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 3 * 105</li><li>s 由数字、’+’、’-‘、’(‘、’)’、和 ‘ ‘ 组成</li><li>s 表示一个有效的表达式</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">calculate</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//展开表达式中所有的括号</span>
        <span class="c1">//每遇到一个以-号开头的括号，则意味着此后的符号都要被翻转</span>
        <span class="c1">//维护一个栈，其中栈顶元素记录了当前位置所处的每个括号所共同形成的符号</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ops</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">ops</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>

            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span><span class="o">){</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="o">){</span><span class="c1">//遇到一个负号，就将共同的符号取反</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">ops</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">){</span><span class="c1">//如果遇到了一个左括号，就将左括号前的符号推入栈顶</span>
                <span class="n">ops</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">sign</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">){</span>
                <span class="n">ops</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span><span class="c1">//如果是数字</span>
                <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">))){</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
                    <span class="o">++</span><span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="225-用队列实现栈">225. 用队列实现栈</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code class="language-plaintext highlighter-rouge">push</code>、<code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">pop</code> 和 <code class="language-plaintext highlighter-rouge">empty</code>）。</p><p>实现 <code class="language-plaintext highlighter-rouge">MyStack</code> 类：</p><ul><li><code class="language-plaintext highlighter-rouge">void push(int x)</code> 将元素 x 压入栈顶。</li><li><code class="language-plaintext highlighter-rouge">int pop()</code> 移除并返回栈顶元素。</li><li><code class="language-plaintext highlighter-rouge">int top()</code> 返回栈顶元素。</li><li><code class="language-plaintext highlighter-rouge">boolean empty()</code> 如果栈是空的，返回 <code class="language-plaintext highlighter-rouge">true</code> ；否则，返回 <code class="language-plaintext highlighter-rouge">false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code class="language-plaintext highlighter-rouge">push to back</code>、<code class="language-plaintext highlighter-rouge">peek/pop from front</code>、<code class="language-plaintext highlighter-rouge">size</code> 和 <code class="language-plaintext highlighter-rouge">is empty</code> 这些操作。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">MyStack</span> <span class="o">{</span>
    <span class="c1">//栈的特性是先入先出，队列则是先入后出</span>
    <span class="c1">//如果用两个队列实现，</span>
    <span class="c1">//在push的时候，在队列1中始终保存栈顶元素</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="cm">/** Initialize your data structure here. */</span>
    <span class="kd">public</span> <span class="nf">MyStack</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>
    
    <span class="cm">/** Push element x onto stack. */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">queue2</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">queue2</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">queue1</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue1</span><span class="o">;</span>
        <span class="n">queue1</span> <span class="o">=</span> <span class="n">queue2</span><span class="o">;</span>
        <span class="n">queue2</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/** Removes the element on top of the stack and returns that element. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">queue1</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="cm">/** Get the top element. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">top</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">queue1</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="cm">/** Returns whether the stack is empty. */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">queue1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */</span>
</pre></table></code></div></div><h2 id="226翻转二叉树">226.翻转二叉树</h2><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		 <span class="mi">4</span>
   <span class="o">/</span>   <span class="err">\</span>
  <span class="mi">2</span>     <span class="mi">7</span>
 <span class="o">/</span> <span class="err">\</span>   <span class="o">/</span> <span class="err">\</span>
<span class="mi">1</span>   <span class="mi">3</span> <span class="mi">6</span>   <span class="mi">9</span>
</pre></table></code></div></div><p>输出：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		 <span class="mi">4</span>
   <span class="o">/</span>   <span class="err">\</span>
  <span class="mi">7</span>     <span class="mi">2</span>
 <span class="o">/</span> <span class="err">\</span>   <span class="o">/</span> <span class="err">\</span>
<span class="mi">9</span>   <span class="mi">6</span> <span class="mi">3</span>   <span class="mi">1</span>
</pre></table></code></div></div><p>备注: 这个问题是受到 Max Howell 的 原问题 启发的 ：</p><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote><p>递归交换：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">invert</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">invert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>迭代交换：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
      	<span class="c1">//层序遍历</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="c1">//交换子节点</span>
                <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="227-基本计算器-ii">227. 基本计算器 II</h2><p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p><p>字符串表达式仅包含非负整数，<code class="language-plaintext highlighter-rouge">+</code>， <code class="language-plaintext highlighter-rouge">-</code> ，<code class="language-plaintext highlighter-rouge">*</code>，<code class="language-plaintext highlighter-rouge">/</code> 四种运算符和空格 ` `。 整数除法仅保留整数部分。</p><p><strong>示例 3:</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: " 3+5 / 2 "
输出: 5
</pre></table></code></div></div><p><strong>说明：</strong></p><ul><li>你可以假设所给定的表达式都是有效的。</li><li>请<strong>不要</strong>使用内置的库函数 <code class="language-plaintext highlighter-rouge">eval</code>。</li></ul><p>不包含括号，但是增加了* 和 /号。和224题相比简单了一些。</p><ol><li>先跳过空格</li><li>出现了数字则记录整个数字是多少，然后根据之前的运算符决定下一步：<ol><li>如果是加号’+’，说明前面的运算独立于以后的运算，可以将结果暂时放入栈；</li><li>如果是减号’-‘，可以看成-1 * tempNum，然后将-tempNum入栈；</li><li>如果是乘号’*‘或者除号’/’，由于前面的运算独立于此，可以先计算lastNum和tempNum积，然后结果入栈。</li></ol></li><li>最后将栈中的所有元素相加就是答案。</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">calculate</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//优先处理乘除号</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">char</span> <span class="n">sign</span> <span class="o">=</span> <span class="sc">'+'</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
                <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))){</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>
                    <span class="n">i</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sign</span> <span class="o">==</span> <span class="sc">'+'</span><span class="o">){</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">sign</span> <span class="o">==</span> <span class="sc">'-'</span><span class="o">){</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(-</span><span class="n">num</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cal</span><span class="o">(</span><span class="n">sign</span><span class="o">,</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">(),</span> <span class="n">num</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">stack</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">char</span> <span class="n">sign</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sign</span> <span class="o">==</span> <span class="sc">'*'</span><span class="o">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="o">;</span>
        <span class="k">else</span>    <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump228"></span></p><h2 id="228-汇总区间">228. 汇总区间</h2><p>给定一个无重复元素的有序整数数组 nums 。</p><p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p><p>列表中的每个区间范围 [a,b] 应该按如下格式输出：</p><p>“a-&gt;b” ，如果 a != b “a” ，如果 a == b</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"0-&gt;2"</span><span class="o">,</span><span class="s">"4-&gt;5"</span><span class="o">,</span><span class="s">"7"</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">区间范围是</span><span class="err">：</span>
<span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">--&gt;</span> <span class="s">"0-&gt;2"</span>
<span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="o">--&gt;</span> <span class="s">"4-&gt;5"</span>
<span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span> <span class="o">--&gt;</span> <span class="s">"7"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"0"</span><span class="o">,</span><span class="s">"2-&gt;4"</span><span class="o">,</span><span class="s">"6"</span><span class="o">,</span><span class="s">"8-&gt;9"</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">区间范围是</span><span class="err">：</span>
<span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="o">--&gt;</span> <span class="s">"0"</span>
<span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">--&gt;</span> <span class="s">"2-&gt;4"</span>
<span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span> <span class="o">--&gt;</span> <span class="s">"6"</span>
<span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span> <span class="o">--&gt;</span> <span class="s">"8-&gt;9"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 20</li><li>-231 &lt;= nums[i] &lt;= 231 - 1</li><li>nums 中的所有值都 互不相同</li><li>nums 按升序排列</li></ul><p>双指针</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">summaryRanges</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span>
            <span class="n">idx</span><span class="o">++;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">idx</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">]));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"-&gt;"</span><span class="o">);</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">high</span><span class="o">]));</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="229-求众数-ii">229. 求众数 II</h2><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code class="language-plaintext highlighter-rouge">⌊ n/3 ⌋</code> 次的元素。</p><p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入：[3,2,3]
输出：[3]
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//找出所有出现次数超过 n/3的元素</span>
        <span class="c1">//出现次数超过n/3，说明什么呢？总共元素个数是n个，出现次数超过n/3，说明这种数字最多存在2个</span>
        <span class="c1">//不可能有三个以上的数字，出现次数超过n/3</span>
        <span class="c1">//用摩尔投票</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//初始化两个候选者</span>
        <span class="nc">Integer</span> <span class="n">cand1</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="nc">Integer</span> <span class="n">cand2</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">count1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cand1</span> <span class="o">==</span> <span class="n">num</span><span class="o">){</span>
                <span class="n">count1</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cand2</span> <span class="o">==</span> <span class="n">num</span><span class="o">){</span>
                <span class="n">count2</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//num不等于剩余的候选人</span>
            <span class="c1">//更新候选者</span>
            <span class="k">if</span><span class="o">(</span><span class="n">count1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">cand1</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="n">count1</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">count2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">cand2</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="n">count2</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">count1</span><span class="o">--;</span>
            <span class="n">count2</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="n">count1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">count2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">cand1</span><span class="o">)</span>    <span class="n">count1</span><span class="o">++;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">cand2</span><span class="o">)</span>   <span class="n">count2</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">count1</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">/</span><span class="mi">3</span><span class="o">)</span>    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cand1</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">count2</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">/</span><span class="mi">3</span><span class="o">)</span>    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cand2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="230-二叉搜索树中第k小的元素">230. 二叉搜索树中第K小的元素</h2><p>给定一个二叉搜索树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，和一个整数 <code class="language-plaintext highlighter-rouge">k</code> ，请你设计一个算法查找其中第 <code class="language-plaintext highlighter-rouge">k</code> 个最小元素（从 1 开始计数）。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//第k小的数字，那只需要中序遍历，遍历到第k个元素就找到了结果</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">k</span><span class="o">--;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="231-2-的幂">231. 2 的幂</h2><p>判断一个数字是否是2的幂次。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPowerOfTwo</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump232"></span></p><h2 id="232-用栈实现队列">232. 用栈实现队列</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false</p><p>说明：</p><p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p>进阶：</p><p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
<span class="o">[</span><span class="s">"MyQueue"</span><span class="o">,</span> <span class="s">"push"</span><span class="o">,</span> <span class="s">"push"</span><span class="o">,</span> <span class="s">"peek"</span><span class="o">,</span> <span class="s">"pop"</span><span class="o">,</span> <span class="s">"empty"</span><span class="o">]</span>
<span class="o">[[],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[],</span> <span class="o">[],</span> <span class="o">[]]</span>
<span class="n">输出</span><span class="err">：</span>
<span class="o">[</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">]</span>

<span class="n">解释</span><span class="err">：</span>
<span class="nc">MyQueue</span> <span class="n">myQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyQueue</span><span class="o">();</span>
<span class="n">myQueue</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// queue is: [1]</span>
<span class="n">myQueue</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// queue is: [1, 2] (leftmost is front of the queue)</span>
<span class="n">myQueue</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span> <span class="c1">// return 1</span>
<span class="n">myQueue</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span> <span class="c1">// return 1, queue is [2]</span>
<span class="n">myQueue</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span> <span class="c1">// return false</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= x &lt;= 9</li><li>最多调用 100 次 push、pop、peek 和 empty</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</li></ul><p>stack1用于输入，stack2用于输出，在stack2为空时调用pop和peek方法会触发以下操作：stack1中的元素都push到stack2中。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">MyQueue</span> <span class="o">{</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="cm">/** Initialize your data structure here. */</span>
    <span class="kd">public</span> <span class="nf">MyQueue</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="cm">/** Push element x to the back of queue. */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">stack1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/** Removes the element from in front of queue and returns that element. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                <span class="n">stack2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="cm">/** Get the front element. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                <span class="n">stack2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack2</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="cm">/** Returns whether the queue is empty. */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump234"></span></p><h2 id="234回文链表">234.回文链表</h2><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span>
<span class="nl">输出:</span> <span class="kc">false</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">1</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>进阶：</p><ul><li>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</li></ul><p>用栈实现逆序比对。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//统计节点个数</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">num</span><span class="o">++;</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">//将前一半节点入栈</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ptr</span><span class="o">);</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cnt</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">//如果是奇数，就需要继续向后移动一个节点，越过中间节点</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>    <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">//出栈比对</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>进阶：将后一半链表翻转，再双指针遍历比较，结束后将链表恢复原样</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//统计节点个数</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">num</span><span class="o">++;</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cnt</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">//将后一半链表翻转</span>
        <span class="nc">ListNode</span> <span class="n">revStart</span> <span class="o">=</span> <span class="n">reverseListNode</span><span class="o">(</span><span class="n">ptr</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">revStart</span><span class="o">;</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">reverseListNode</span><span class="o">(</span><span class="n">revStart</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cnt</span><span class="o">--;</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ptr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">reverseListNode</span><span class="o">(</span><span class="n">revStart</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">ListNode</span> <span class="nf">reverseListNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">){</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>            
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump235"></span></p><h2 id="235二叉搜索树的最近公共祖先">235.二叉搜索树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/binarytree.png" alt="" /></p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">root</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nl">输出:</span> <span class="mi">3</span>
<span class="nl">解释:</span> <span class="n">节点</span> <span class="mi">5</span> <span class="n">和节点</span> <span class="mi">1</span> <span class="n">的最近公共祖先是节点</span> <span class="mi">3</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">root</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nl">输出:</span> <span class="mi">5</span>
<span class="nl">解释:</span> <span class="n">节点</span> <span class="mi">5</span> <span class="n">和节点</span> <span class="mi">4</span> <span class="n">的最近公共祖先是节点</span> <span class="mi">5</span><span class="err">。</span><span class="n">因为根据定义最近公共祖先节点可以为节点本身</span><span class="err">。</span>
</pre></table></code></div></div><p>说明:</p><ul><li><p>所有节点的值都是唯一的。</p></li><li><p>p、q 为不同节点且均存在于给定的二叉树中。</p></li></ul><p>思路：</p><p>后序遍历，从树的底部开始向上回溯，这样可以保证搜索到的祖先是离p,q最近的。</p><ul><li>如果p和q分别是root的左右节点，那么root就是我们要找的最近公共祖先</li><li>如果p和q都是root的左节点，那么返回lowestCommonAncestor(root.left,p,q)</li><li>如果p和q都是root的右节点，那么返回lowestCommonAncestor(root.right,p,q)</li></ul><p>边界条件：</p><ul><li>如果root是null，则说明我们已经找到最底了，返回null表示没找到</li><li>如果root与p相等或者与q相等，则返回root</li><li>如果左子树没找到，递归函数返回null，证明p和q同在root的右侧，那么最终的公共祖先就是右子树找到的结点</li><li>如果右子树没找到，递归函数返回null，证明p和q同在root的左侧，那么最终的公共祖先就是左子树找到的结点</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">lowestCommonAncestor</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="o">)</span>  <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
        <span class="c1">//有一者为空，那么p和q在另一侧，由于是后序遍历，所以该侧指向最近的公共祖先</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
        <span class="c1">//p,q在两侧</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>   
    <span class="o">}</span>   
<span class="o">}</span>
</pre></table></code></div></div><h2 id="237-删除链表中的节点">237. 删除链表中的节点</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <strong>要被删除的节点</strong> 。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ListNode cur = node;</span>
        <span class="c1">// while(cur.next.next != null){</span>
        <span class="c1">//     cur.val = cur.next.val;</span>
        <span class="c1">//     cur = cur.next;</span>
        <span class="c1">// }</span>
        <span class="c1">// cur.val = cur.next.val;</span>
        <span class="c1">// cur.next = null;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump238"></span></p><h2 id="238除自身以外数组的乘积">238.除自身以外数组的乘积</h2><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">24</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p><p>说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p>进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">productExceptSelf</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
        <span class="c1">//pre[i]表示[0,i-1]元素的乘积</span>
        <span class="c1">//post[i]表示[i+1,nums.length-1]元素的乘积</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">pre</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">post</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="n">pre</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="n">post</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">post</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">post</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">post</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>线性空间：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">productExceptSelf</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
        <span class="c1">//pre[i]表示[0,i-1]元素的乘积</span>
        <span class="c1">//post[i]表示[i+1,nums.length-1]元素的乘积</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">output</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">post</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">post</span> <span class="o">=</span> <span class="n">post</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">post</span> <span class="o">*</span> <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump239"></span></p><h2 id="239滑动窗口最大值">239.滑动窗口最大值</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>进阶：</p><ul><li>你能在线性时间复杂度内解决此题吗？</li></ul><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],</span> <span class="n">和</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span> 
<span class="nl">解释:</span> 

  <span class="n">滑动窗口的位置</span>                <span class="n">最大值</span>

<span class="o">---------------</span>               <span class="o">-----</span>

<span class="o">[</span><span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">3</span>
 <span class="mi">1</span> <span class="o">[</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span><span class="o">]</span> <span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">3</span>
 <span class="mi">1</span>  <span class="mi">3</span> <span class="o">[-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span><span class="o">]</span> <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">5</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span> <span class="o">[-</span><span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">3</span><span class="o">]</span> <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">5</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span> <span class="o">[</span><span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span><span class="o">]</span> <span class="mi">7</span>       <span class="mi">6</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span> <span class="o">[</span><span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span><span class="o">]</span>      <span class="mi">7</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>1 &lt;= k &lt;= nums.length</li><li>通过次数83,092提交次数168,914</li></ul><p>暴力法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">//最终结果的数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">max_i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//还在第一个窗口内</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">){</span>
                    <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="n">max_i</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
                    <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//开始滑动窗口</span>
                <span class="c1">//去除的左边界就是最大值</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="n">k</span> <span class="o">==</span> <span class="n">max_i</span><span class="o">){</span>
                    <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
                    <span class="n">max_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="c1">//重新搜索最大值</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">){</span>
                            <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                            <span class="n">max_i</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//去除的左边界不是最大值</span>
                    <span class="c1">//比较加入的右边界是否比当前最大值大</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">){</span>
                        <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                        <span class="n">max_i</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>双向队列：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//建立一个双向队列</span>
    <span class="c1">//实现：遍历每一个元素，从右边删除（出队）所有小于等于该元素的队列元素</span>
    <span class="c1">//这样就能保证队列首元素为最大值</span>
    <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">k</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">//最终结果的数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max_i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="c1">//先遍历前k个元素，初始化队列</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">clean_deq</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()];</span>
        <span class="c1">//遍历剩余元素</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">clean_deq</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">clean_deq</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
        <span class="c1">//如果当前最大值为左边界</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">){</span>
            <span class="c1">//删除左边界</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//把nums[i]放入队列</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">deque</span><span class="o">.</span><span class="na">getLast</span><span class="o">()])</span> <span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>动态规划（别人写的，需要看！）：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>

    <span class="kt">int</span> <span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="kt">int</span> <span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">right</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="c1">// from left to right</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>  <span class="c1">// block_start</span>
      <span class="k">else</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

      <span class="c1">// from right to left</span>
      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">((</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">right</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>  <span class="c1">// block_end</span>
      <span class="k">else</span> <span class="n">right</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

    <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump240"></span></p><h2 id="240搜索二维矩阵-ii">240.搜索二维矩阵 II</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例:</p><p>现有矩阵 matrix 如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="o">[</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span>   <span class="mi">4</span><span class="o">,</span>  <span class="mi">7</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">15</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">2</span><span class="o">,</span>   <span class="mi">5</span><span class="o">,</span>  <span class="mi">8</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">19</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span>   <span class="mi">6</span><span class="o">,</span>  <span class="mi">9</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">22</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">24</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">18</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">26</span><span class="o">,</span> <span class="mi">30</span><span class="o">]</span>
<span class="o">]</span>
</pre></table></code></div></div><ul><li>给定 target = 5，返回 true。</li><li>给定 target = 20，返回 false。</li></ul><p>深度优先搜索，从左上角开始搜索：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">target</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">searchMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="c1">//超出边界</span>
        <span class="k">if</span><span class="o">(</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//找到了target</span>
        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//记录已访问元素</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//当前元素小于target</span>
        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="c1">//如果在右边界了，就往下走</span>
            <span class="k">if</span><span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//如果还没在右边界，并且(x,y+1)没有被访问过</span>
                <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span>
                    <span class="c1">//向右边走</span>
                    <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//右边已经访问过了，就往下走</span>
                    <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="c1">//如果当前元素大于target，就往左走</span>
            <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>从左下角开始搜索：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">searchMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">x</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">y</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>         
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>   
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="258-各位相加">258. 各位相加</h2><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">38</span>
<span class="nl">输出:</span> <span class="mi">2</span> 
<span class="nl">解释:</span> <span class="n">各位相加的过程为</span><span class="err">：</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">=</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="err">。</span> <span class="n">由于</span> <span class="mi">2</span> <span class="n">是一位数</span><span class="err">，</span><span class="n">所以返回</span> <span class="mi">2</span><span class="err">。</span>
</pre></table></code></div></div><p>进阶: 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">addDigits</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//找找规律吧</span>
        <span class="c1">// 1 -&gt; 1,  2 -&gt; 2,  3 -&gt; 3, ...,  9 -&gt; 9</span>
        <span class="c1">//10 -&gt; 1, 11 -&gt; 2, 12 -&gt; 3, ..., 18 -&gt; 9,</span>
        <span class="c1">//19 -&gt; 1, 20 -&gt; 2, 21 -&gt; 3, ..., 27 -&gt; 9,</span>
        <span class="c1">//28 -&gt; 1, 29 -&gt; 2, 30 -&gt; 3, ..., 36 -&gt; 9,</span>
        <span class="c1">//37 -&gt; 1, 38 -&gt; 2, 39 -&gt; 3, ..., 45 -&gt; 9,</span>
        <span class="c1">//其实是9个数一个轮回</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//那么直接对9取模，然后余数是几，就是几</span>
        <span class="n">num</span> <span class="o">%=</span> <span class="mi">9</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">9</span> <span class="o">:</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="260-只出现一次的数字-iii">260. 只出现一次的数字 III</h2><p>给定一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">singleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//简单题，直接异或，结果就剩下出现一次的两个元素</span>
        <span class="c1">//然后找到低位第一个1，用这个1来区分两个数字</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="n">k</span> <span class="o">^=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// k == 0110</span>
        <span class="c1">//定位末尾的第一个1</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">k</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">num</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">a</span> <span class="o">^=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">b</span> <span class="o">^=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump279"></span></p><h2 id="279完全平方数">279.完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">12</span>
<span class="nl">输出:</span> <span class="mi">3</span> 
<span class="nl">解释:</span> <span class="mi">12</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">.</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">13</span>
<span class="nl">输出:</span> <span class="mi">2</span>
<span class="nl">解释:</span> <span class="mi">13</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">9</span><span class="o">.</span>
</pre></table></code></div></div><p>动态规划：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numSquares</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//dp[i]表示组成数字i最少需要的完全平方数个数</span>
        <span class="c1">//dp[n]就是答案</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="c1">//那么dp[i]为min(dp[i - 可用的每个完全平方数] + 1)</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>
        <span class="c1">//边界处理</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//找出可用的完全平方数</span>
        <span class="kt">int</span> <span class="n">max_s_i</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">square_nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">max_s_i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_s_i</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">square_nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//遍历1～n所有的数</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//遍历所有的完全平方数</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">max_s_i</span><span class="o">;</span> <span class="o">++</span><span class="n">s</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">square_nums</span><span class="o">[</span><span class="n">s</span><span class="o">])</span>  <span class="k">break</span><span class="o">;</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">square_nums</span><span class="o">[</span><span class="n">s</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p>数学方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

  <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isSquare</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sq</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="n">sq</span> <span class="o">*</span> <span class="n">sq</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">//拉格朗日四平方数定理：所有的自然数都可以被表示为4个整数的平方和</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numSquares</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">n</span> <span class="o">/=</span> <span class="mi">4</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">7</span><span class="o">)</span>
      <span class="k">return</span> <span class="mi">4</span><span class="o">;</span>
		<span class="c1">//只要n ！= 4^k (8m+7)，那么这个正整数可以表示为3个平方</span>
    <span class="c1">//但是可以更少时，我们取更少</span>
    <span class="c1">//即当前数字就是个完全平方数</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">isSquare</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
      <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">//当前数字可以被分解为两个完全平方数</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">isSquare</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">))</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//不可以分解为1个或2个完全平方数，那么根据Adrien-Marie-Legendre的三平方定理只能是3个完全平方数了</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump242"></span></p><h2 id="242有效的字母异位词">242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"anagram"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"nagaram"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"rat"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"car"</span>
<span class="nl">输出:</span> <span class="kc">false</span>
</pre></table></code></div></div><p>说明: 你可以假设字符串只包含小写字母。</p><p>进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><p>排序比较：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAnagram</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="kt">char</span><span class="o">[]</span> <span class="n">char1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">char2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">char1</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">char2</span><span class="o">);</span>

        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">char1</span><span class="o">,</span><span class="n">char2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>哈希表：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAnagram</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">table</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">table</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">table</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">table</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump257"></span></p><h2 id="257二叉树的所有路径">257.二叉树的所有路径</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
   <span class="mi">1</span>
 <span class="o">/</span>   <span class="err">\</span>
<span class="mi">2</span>     <span class="mi">3</span>
 <span class="err">\</span>
  <span class="mi">5</span>

<span class="nl">输出:</span> <span class="o">[</span><span class="s">"1-&gt;2-&gt;5"</span><span class="o">,</span> <span class="s">"1-&gt;3"</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="nl">所有根节点到叶子节点的路径为:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span>
</pre></table></code></div></div><h3 id="回溯法-3">回溯法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">StringBuffer</span> <span class="n">path</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">binaryTreePaths</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">getPath</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">getPath</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="c1">//到达叶节点</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="c1">//回溯</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">).</span><span class="na">length</span><span class="o">();</span>
            <span class="n">path</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="n">len</span><span class="o">,</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="k">return</span><span class="o">;</span>
            
        <span class="o">}</span>
        <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"-&gt;"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">getPath</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>  <span class="n">getPath</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="c1">//回溯，这题比较奇葩，root.val长度是变化的，所以在删除字符的时候需要计算root.val的长度</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">).</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">path</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="n">len</span><span class="o">,</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="264-丑数-ii">264. 丑数 II</h2><p>给你一个整数 <code class="language-plaintext highlighter-rouge">n</code> ，请你找出并返回第 <code class="language-plaintext highlighter-rouge">n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code class="language-plaintext highlighter-rouge">2</code>、<code class="language-plaintext highlighter-rouge">3</code> 和/或 <code class="language-plaintext highlighter-rouge">5</code> 的正整数。</p><p>dp[i]中保存的是第i个丑数，只需要不断地用质因数2、3、5去乘dp中的丑数就能找到当前最小的丑数。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">nthUglyNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">*</span> <span class="mi">3</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">c5</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">*</span> <span class="mi">5</span><span class="o">;</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">b3</span><span class="o">,</span> <span class="n">c5</span><span class="o">));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span>    <span class="n">a</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">b3</span><span class="o">)</span>    <span class="n">b</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">c5</span><span class="o">)</span>    <span class="n">c</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="268-丢失的数字">268. 丢失的数字</h2><p>给定一个包含 <code class="language-plaintext highlighter-rouge">[0, n]</code> 中 <code class="language-plaintext highlighter-rouge">n</code> 个数的数组 <code class="language-plaintext highlighter-rouge">nums</code> ，找出 <code class="language-plaintext highlighter-rouge">[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>进阶：</strong></p><ul><li>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">missingNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//做下标映射，如果每个位置都被成功映射了一次，那么缺失的数字就是n</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span>  <span class="k">continue</span><span class="o">;</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">-=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>异或：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">missingNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//异或，最后只剩下缺失的数字</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">num</span> <span class="o">^=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span>   <span class="n">num</span> <span class="o">^=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="274-h-指数">274. H 指数</h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。</p><p>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hIndex</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">citations</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。</span>
        <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">citations</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">citations</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">citations</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">){</span>
                <span class="n">h</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="275-h-指数-ii">275. H 指数 II</h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 升序排列 。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><p><strong>进阶：</strong></p><ul><li>这是 <a href="https://leetcode-cn.com/problems/h-index/description/">H 指数</a> 的延伸题目，本题中的 <code class="language-plaintext highlighter-rouge">citations</code> 数组是保证有序的。</li><li>你可以优化你的算法到对数时间复杂度吗？</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hIndex</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">citations</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">citations</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">//有n-r篇论文至少被引用了citations[mid]次</span>
            <span class="k">if</span><span class="o">(</span><span class="n">citations</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">mid</span><span class="o">){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">l</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump283"></span></p><h2 id="283移动零">283.移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">12</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
</pre></table></code></div></div><p>说明:</p><ul><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ul><p>冒泡法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveZeroes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span>  <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
   
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">++</span><span class="n">left</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="o">++</span><span class="n">right</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>先排列所有非0元素，再填充0:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveZeroes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>   
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>快慢指针，快指针正常遍历，慢指针始终指向第一个0。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveZeroes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">ptr</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                <span class="o">++</span><span class="n">ptr</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump287"></span></p><h2 id="287寻找重复数">287.寻找重复数</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">3</span>
</pre></table></code></div></div><p>说明：</p><ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul><p>数字分布在1～n之间，如果重复的数字为k：</p><ol><li>那么在[1,k-1]范围内的数字nums[i]有：数组中小于等于nums[i]的数字个数为不会超过nums[i]个，例如1，小于等于1的数字有1个</li><li>在[k,n]范围内的数字nums[i]有：小于等于nums[i]数字个数均大于nums[i]，例如3，小于等于3的数字有4个。</li></ol><p>二分法，搜索单调性变化的边界即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//二分法：在1，2，3，4，...,n之间搜索</span>
        <span class="c1">//我们发现：如果重复的数字为k，</span>
        <span class="c1">//1、那么在[1,k-1]范围内的数字nums[i]有：</span>
        <span class="c1">//      数组中小于等于nums[i]的数字个数为不会超过nums[i]个，例如1，小于等于1的数字有1个</span>
        <span class="c1">//2、在[k,max]范围内的数字nums[i]有：</span>
        <span class="c1">//      小于等于nums[i]数字个数均大于nums[i]，例如3，小于等于3的数字有4个。</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">){</span>
                    <span class="n">cnt</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="289-生命游戏">289. 生命游戏</h2><p>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。</p><p>实际上就是统计周围活细胞的个数，根据当前细胞的状态进行转移。</p><p>为了支持原地算法，额外增加两个状态-1和-2，-1表示从前是1，但是需要变为0；-2表示从前是0，需要变为1。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">gameOfLife</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//八个相邻位置</span>
        <span class="cm">/*生存定律：
            1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
            2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
            3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
            4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
            对于一个活细胞来说，如果周围只有1个活细胞，那它必死
                            如果周围有2个或3个活细胞，那它还活着
                            如果周围有4,5,6,7,8个活细胞，那它必死
            对于一个死细胞来说，如果周围有3个活细胞，那它复活                            
        */</span>
        <span class="c1">//需要返回下一个状态</span>
        <span class="c1">//那么当前状态的变迁应当不会影响其他细胞的状态吧？</span>
        <span class="c1">//那岂不是只需要遍历即可？</span>
        <span class="c1">//试试看</span>

        <span class="c1">//原地算法，不能有额外空间</span>
        <span class="c1">//那如果细胞状态需要变化的时候，将其在原状态的基础上-2</span>
        <span class="c1">// 0需要变为1， 那先变为-2</span>
        <span class="c1">// 1需要变为0， 那先变为-1</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="c1">//先判断是活细胞还是死细胞</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="c1">//是死的</span>
                    <span class="c1">//能复活吗？</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">judge</span><span class="o">(</span><span class="n">board</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="mi">3</span><span class="o">)){</span>
                        <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//是活的</span>
                    <span class="c1">//会死吗？</span>
                    <span class="k">if</span><span class="o">(!(</span><span class="n">judge</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span> <span class="o">||</span> <span class="n">judge</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span><span class="mi">3</span><span class="o">))){</span>
                        <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="o">){</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">directions</span> <span class="o">=</span> <span class="err">。。。</span><span class="o">;</span><span class="c1">//博客语法限制，只能删除了</span>
    <span class="kt">boolean</span> <span class="nf">judge</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">directions</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">directions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">directions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">new_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_x</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">new_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">new_x</span><span class="o">][</span><span class="n">new_y</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">board</span><span class="o">[</span><span class="n">new_x</span><span class="o">][</span><span class="n">new_y</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)){</span>
                <span class="n">cnt</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="292-nim-游戏">292. Nim 游戏</h2><p>你和你的朋友，两个人一起玩 Nim 游戏：</p><p>桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span> 
<span class="n">解释</span><span class="err">：</span><span class="n">如果堆中有</span> <span class="mi">4</span> <span class="n">块石头</span><span class="err">，</span><span class="n">那么你永远不会赢得比赛</span><span class="err">；</span>
<span class="err"> </span>    <span class="n">因为无论你拿走</span> <span class="mi">1</span> <span class="n">块</span><span class="err">、</span><span class="mi">2</span> <span class="n">块</span> <span class="n">还是</span> <span class="mi">3</span> <span class="n">块石头</span><span class="err">，</span><span class="n">最后一块石头总是会被你的朋友拿走</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canWinNim</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//给定总数量为n，每次可以拿1到3块，我先拿</span>
        <span class="c1">//能否拿到最后一块石头</span>
        <span class="c1">//粗鲁一点，直接全部拿3块，快速消灭</span>
        <span class="c1">//我拿完剩4块，赢；拿完剩5块输，拿完剩6块输，拿完剩7块输，拿完剩8块</span>
        <span class="c1">//1 -&gt; 7; 2-&gt; 6, 3-&gt; 5;</span>
        <span class="c1">//8块是我赢</span>
        <span class="c1">//拿完剩9块输</span>
        <span class="c1">//拿完剩10块输</span>
        <span class="c1">//拿完剩11块输</span>
        <span class="c1">//12块赢</span>
        <span class="c1">// if(n &lt; 4)   return true;</span>
        <span class="c1">// if((n-1) % 4 == 0 || (n-2) % 4 == 0 || (n-3) % 4 == 0)  return true;</span>
        <span class="c1">// return false;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump297"></span></p><h2 id="297序列化二叉树">297.序列化二叉树</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例:</p><p>你可以将以下二叉树：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>		1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Codec</span> <span class="o">{</span>

    <span class="nc">String</span> <span class="nf">serialize</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="c1">//索性就用层序遍历的序列化吧，非空节点入队</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"#,"</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="s">","</span><span class="o">);</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">//反序列化，依旧使用队列实现，实际上就是上个函数的逆操作</span>
    <span class="nc">TreeNode</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">str</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"#"</span><span class="o">)){</span>
                <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">i</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"#"</span><span class="o">)){</span>
                <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump300"></span></p><h2 id="300最长上升子序列">300.最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">10</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">101</span><span class="o">,</span><span class="mi">18</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">4</span> 
<span class="nl">解释:</span> <span class="n">最长的上升子序列是</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">101</span><span class="o">]</span><span class="err">，</span><span class="n">它的长度是</span> <span class="mi">4</span><span class="err">。</span>
</pre></table></code></div></div><p>说明:</p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 O(n2) 。</li></ul><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p>动态规划：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//dp[i]表示[0,i]的最长上升子序列长度</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">//初始化边界</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>贪心：</p><p>设计思路：</p><p>新的状态定义： 我们考虑维护一个列表 tails，其中每个元素 tails[k] 的值代表 长度为k+1 的子序列尾部元素的值。 如 <code class="language-plaintext highlighter-rouge">[1,4,6]</code> 序列，长度为 <code class="language-plaintext highlighter-rouge">1,2,3</code> 的子序列尾部元素值分别为 tails=<code class="language-plaintext highlighter-rouge">[1,4,6]</code>。 状态转移设计： 设常量数字 N，和随机数字 x，我们可以容易推出：当 N 越小时，N&lt;x 的几率越大。例如： N=0 肯定比 N=1000 更可能满足 N&lt;x。 在遍历计算每个 tails[k]，不断更新长度为<code class="language-plaintext highlighter-rouge"> [1,k] </code>的子序列尾部元素值，始终保持每个尾部元素值最小 （例如 <code class="language-plaintext highlighter-rouge">[1,5,3]</code>， 遍历到元素 5 时，长度为 2 的子序列尾部元素值为 5；当遍历到元素 3 时，尾部元素值应更新至 3，因为 3 遇到比它大的数字的几率更大）。 tails 列表一定是严格递增的： 即当尽可能使每个子序列尾部元素值最小的前提下，子序列越长，其序列尾部元素值一定更大。</p><p>既然严格递增，每轮计算 tails[k] 时就可以使用二分法查找需要更新的尾部元素值的对应索引 i。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
	      <span class="c1">//其中每个元素 tails[k] 的值代表 长度为k+1 的子序列尾部元素的值。</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">res</span><span class="o">;</span>
            <span class="c1">//计算 tails[k] 时就可以使用二分法查找需要更新的尾部元素值的对应索引 i</span>
            <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tail</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="o">){</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">res</span><span class="o">)</span> <span class="n">res</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump303"></span></p><h2 id="303-区域和检索---数组不可变">303. 区域和检索 - 数组不可变</h2><p>给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。</p><p>实现 NumArray 类：</p><p>NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])）</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
<span class="o">[</span><span class="s">"NumArray"</span><span class="o">,</span> <span class="s">"sumRange"</span><span class="o">,</span> <span class="s">"sumRange"</span><span class="o">,</span> <span class="s">"sumRange"</span><span class="o">]</span>
<span class="o">[[[-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">]],</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">],</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span>
<span class="o">[</span><span class="kc">null</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">]</span>

<span class="n">解释</span><span class="err">：</span>
<span class="nc">NumArray</span> <span class="n">numArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumArray</span><span class="o">([-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
<span class="n">numArray</span><span class="o">.</span><span class="na">sumRange</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="c1">// return 1 ((-2) + 0 + 3)</span>
<span class="n">numArray</span><span class="o">.</span><span class="na">sumRange</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> <span class="c1">// return -1 (3 + (-5) + 2 + (-1)) </span>
<span class="n">numArray</span><span class="o">.</span><span class="na">sumRange</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> <span class="c1">// return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 104</li><li>-105 &lt;= nums[i] &lt;= 105</li><li>0 &lt;= i &lt;= j &lt; nums.length</li><li>最多调用 104 次 sumRange 方法</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">NumArray</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">pre</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//求前缀和</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>   
        
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump304"></span></p><h2 id="304-二维区域和检索---矩阵不可变">304. 二维区域和检索 - 矩阵不可变</h2><p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (<em>row</em>1, <em>col</em>1) ，右下角为 (<em>row</em>2, <em>col</em>2)。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/304.png" alt="Range Sum Query 2D" style="zoom:50%;" /></p><p>上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">给定</span> <span class="n">matrix</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">],</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>
<span class="o">]</span>

<span class="n">sumRegion</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">8</span>
<span class="n">sumRegion</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">11</span>
<span class="n">sumRegion</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">12</span>
</pre></table></code></div></div><p>说明:</p><ul><li>你可以假设矩阵不可变。</li><li>会多次调用 sumRegion 方法。</li><li>你可以假设 row1 ≤ row2 且 col1 ≤ col2。</li></ul><p>和一维区域和检索类似，只要计算每一行的前缀和即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">NumMatrix</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">pre</span><span class="o">;</span><span class="c1">//每一行的前缀和</span>
    <span class="kd">public</span> <span class="nf">NumMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="c1">//计算每一行的前缀和</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                    <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRegion</span><span class="o">(</span><span class="kt">int</span> <span class="n">row1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">row2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">col1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>二维前缀和：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/1614646493-EriDmE-304.001.jpeg" alt="304.001.jpeg" style="zoom: 25%;" /></p><p>S(O,D) = S(O,C) + S(O,B) - S(O,A) + D</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/1614646585-JOesrN-304.002.jpeg" alt="304.002.jpeg" style="zoom:25%;" /></p><p>S(A,D) = S(O,D) - S(O,E) - S(O,F) + S(O,G)</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">NumMatrix</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">sums</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">NumMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span><span class="c1">//计算（0，0）到（i，j）的前缀和</span>
                    <span class="n">sums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">sums</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">sums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">sums</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRegion</span><span class="o">(</span><span class="kt">int</span> <span class="n">row1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="o">)</span> <span class="o">{</span><span class="c1">//计算任意矩形的前缀和</span>
        <span class="k">return</span> <span class="n">sums</span><span class="o">[</span><span class="n">row2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">col2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">sums</span><span class="o">[</span><span class="n">row1</span><span class="o">][</span><span class="n">col2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">sums</span><span class="o">[</span><span class="n">row2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">col1</span><span class="o">]</span> <span class="o">+</span> <span class="n">sums</span><span class="o">[</span><span class="n">row1</span><span class="o">][</span><span class="n">col1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump309"></span></p><h2 id="309最佳买卖股票时机含冷冻期">309.最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
</pre></table></code></div></div><h3 id="动态规划-4">动态规划</h3><p>设<code class="language-plaintext highlighter-rouge">dp[i]</code>为第<code class="language-plaintext highlighter-rouge">i</code>天结束后，最大的累积收益。第<code class="language-plaintext highlighter-rouge">i</code>天结束后有3种状态：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">1.</span> 持有一支股票，对应的累积最大收益为<span class="sb">`dp[i][0]`</span>;
<span class="p">2.</span> 不持有任何股票，并处于冷冻期，累计最大收益为<span class="sb">`dp[i][1]`</span>;
<span class="p">3.</span> 不持有任何股票，并不处于冷冻期，累计最大收益为<span class="sb">`dp[i][2]`</span>;
</pre></table></code></div></div><p>第<code class="language-plaintext highlighter-rouge">i</code>天的状态由第<code class="language-plaintext highlighter-rouge">i-1</code>天状态转移而来，针对以上三种状态，分别有如下可能：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="p">1.</span> 当出现状态1时，说明第i天结束后持有一支股票，股票来源可能是
		第i-1天就持有的，那么dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span> = dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span>;
		第i天买入的，那么第i-1天结束后就不可能持有股票，且不可能处于冷冻期，则
								dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span>=dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">2</span><span class="p">]</span>-prices[i];
		综上：dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span> = max(dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span>, dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">2</span><span class="p">]</span>-prices[i]);
<span class="p">
2.</span> 当出现状态2时，说明第i天结束后不持有股票，并处于冷冻期，说明第i天卖出了股票，则只有一种可能，即第i-1天持有一支股票：
		dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">1</span><span class="p">]</span> = dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">0</span><span class="p">]</span>;
<span class="p">3.</span> 当出现状态3时，说明第i天结束后不持有股票，并不处于冷冻期，说明在第i天未买入也未卖出股票，则有两种可能，即第i-1天不持有股票，并处于冷冻期；或第i-1天不持有股票，并不处于冷冻期：
		dp<span class="p">[</span><span class="nv">i</span><span class="p">][</span><span class="ss">1</span><span class="p">]</span> = max(dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">1</span><span class="p">]</span>, dp<span class="p">[</span><span class="nv">i-1</span><span class="p">][</span><span class="ss">2</span><span class="p">]</span>);
</pre></table></code></div></div><p>初始条件：<code class="language-plaintext highlighter-rouge">dp[0][0]</code>表示第1天结束后，持有一支股票，则<code class="language-plaintext highlighter-rouge">dp[0][0] = -prices[0]</code>，<code class="language-plaintext highlighter-rouge">dp[0][1]</code>和<code class="language-plaintext highlighter-rouge">dp[0][2]</code>均为0；</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>


        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]-</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="空间优化">空间优化</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">f0</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">newf0</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">f0</span><span class="o">,</span> <span class="n">f2</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">newf1</span> <span class="o">=</span> <span class="n">f0</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">newf2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">f2</span><span class="o">);</span>
            <span class="n">f0</span> <span class="o">=</span> <span class="n">newf0</span><span class="o">;</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">newf1</span><span class="o">;</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">newf2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">f2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump316"></span></p><h2 id="316-去除重复字母">316. 去除重复字母</h2><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p>注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"bcabc"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"abc"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"cbacdcbc"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"acdb"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 104</li><li>s 由小写英文字母组成</li></ul><p>单调栈</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">removeDuplicateLetters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="c1">//维护一个单调栈，如果当前字母小于栈顶字母，就将栈顶字母出栈</span>
        <span class="c1">//  但是如果当前栈顶字母的计数已经为0了，那就不能出栈了</span>
      	<span class="c1">//	如果当前字母已经在栈中了，没必要访问了，计数-1</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">cur</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">sb</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>

                <span class="o">}</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">count</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump321"></span></p><h2 id="321拼接最大数tag">321.拼接最大数[tag]</h2><p>给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p><p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。</p><p>说明: 请尽可能地优化你算法的时间和空间复杂度。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">]</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span><span class="o">]</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">]</span>
</pre></table></code></div></div><p>与删除k个数字类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//单调栈：保留k个数相当于移除nums1.length+nums2.length - k个数</span>
    <span class="c1">//从两个数组中取k个数，相当于从nums1中取k1个数，从nums2中取k2个数</span>
    <span class="c1">//k1 + k2 = k</span>
    <span class="c1">//也就是:</span>
  	<span class="c1">//1.从nums1中删除n1 - k1个数，使得子序列最大</span>
    <span class="c1">//2.从nums2中删除n2 - k2个数，使得子序列最大</span>
    <span class="c1">//若k &lt; n1，那么nums1可以删除1、2、3、...、k个数</span>
    <span class="c1">//但是k有可能大于n1或n2，所以需要遍历每一种情况</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">maxSubsequence</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="o">),</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence1</span> <span class="o">=</span> <span class="n">maxSubsequence</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence2</span> <span class="o">=</span> <span class="n">maxSubsequence</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">curMaxSubsequence</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">subsequence1</span><span class="o">,</span> <span class="n">subsequence2</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">curMaxSubsequence</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">maxSubsequence</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">curMaxSubsequence</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">maxSubsequence</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxSubsequence</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//单调栈，找到长度为leng-k的最大子序列</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSubsequence</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">remain</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">top</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">[</span><span class="n">top</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">top</span><span class="o">--;</span>
                <span class="n">remain</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">[++</span><span class="n">top</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">remain</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//合并子序列</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">subsequence1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">subsequence2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">subsequence2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">subsequence1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">mergeLength</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">mergeLength</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">index1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mergeLength</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">subsequence1</span><span class="o">,</span> <span class="n">index1</span><span class="o">,</span> <span class="n">subsequence2</span><span class="o">,</span> <span class="n">index2</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">merged</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">subsequence1</span><span class="o">[</span><span class="n">index1</span><span class="o">++];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">merged</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">subsequence2</span><span class="o">[</span><span class="n">index2</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">merged</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//自定义比较方法。首先比较两个子序列的当前元素，</span>
  	<span class="c1">//如果两个当前元素不同，则选其中较大的元素作为下一个合并的元素，</span>
    <span class="c1">//否则需要比较后面的所有元素才能决定选哪个元素作为下一个合并的元素。</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">subsequence2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">subsequence1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">subsequence2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">index1</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">index2</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">subsequence1</span><span class="o">[</span><span class="n">index1</span><span class="o">]</span> <span class="o">-</span> <span class="n">subsequence2</span><span class="o">[</span><span class="n">index2</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">difference</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">difference</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">index1</span><span class="o">++;</span>
            <span class="n">index2</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">index1</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">index2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="322-零钱兑换">322. 零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>动态规划，我们设定dp[i]表示coins能组成总金额i的最少硬币数。</p><p>遍历coins，那么当<code class="language-plaintext highlighter-rouge">coins[j] &lt;= i</code>时，这个<code class="language-plaintext highlighter-rouge">coins[j]</code>是可以选择放入背包的，那么只需求当前的硬币数和放入这个coin的硬币数哪个大就行了。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//令dp[i]表示coins凑成总金额i的最少硬币数</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//遍历所有的总金额</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">coins</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coins</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">amount</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump327"></span></p><h2 id="327区间和的个数tag">327.区间和的个数[tag]</h2><p>给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。 区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。</p><p>说明: 最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,-</span><span class="mi">1</span><span class="o">],</span> <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span>
<span class="nl">输出:</span> <span class="mi">3</span> 
<span class="nl">解释:</span> <span class="mi">3</span><span class="nl">个区间分别是:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span><span class="err">，</span><span class="nl">它们表示的和分别为:</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="err">。</span>
</pre></table></code></div></div><p>归并排序是从最小子数组开始统计的，我们是在归并之前统计下标对，之后再归并，所以不影响。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//目的是为了统计符合</span>
    <span class="c1">//pre[j] - pre[i] &gt;= lower &amp;&amp; pre[j] - pre[i] &lt;= upper</span>
    <span class="c1">//的下标（i,j）的个数</span>
    <span class="c1">//归并排序</span>
    <span class="c1">//让排好序的，待归并的两个子数组作为pre</span>
    <span class="c1">//计算从左边数组下标i到右边数组下标j的和是否满足条件</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countRangeSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">sum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="c1">//计算[0,i]的前缀和</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">sum</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">count</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">sum</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">sum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">left</span><span class="o">;</span>
            <span class="c1">//归并</span>
            <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">;</span>

            <span class="c1">//统计下标对的数量</span>

            <span class="c1">//枚举左边数组的每一位</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
            
            <span class="c1">//让l和r指向右边数组的开头</span>
            <span class="c1">//让l向右移动，直到sum[l] - sum[i] &gt;= lower</span>
            <span class="c1">//让r向右移动，直到sum[r] - sum[i] &gt; upper</span>
            <span class="c1">//这样 r - l就是下标对的数量了</span>
             <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
             <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
             <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">){</span>
                 <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">-</span> <span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">lower</span><span class="o">){</span>
                     <span class="n">l</span><span class="o">++;</span>
                 <span class="o">}</span>
                 <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">-</span> <span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="o">){</span>
                     <span class="n">r</span><span class="o">++;</span>
                 <span class="o">}</span>
                 <span class="n">res</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">;</span>
                 <span class="o">++</span><span class="n">i</span><span class="o">;</span>
             <span class="o">}</span>
             <span class="c1">//执行左右数组合并</span>
             <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
             <span class="kt">int</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
             <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

             <span class="k">while</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">ptr2</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">){</span>
                 <span class="k">if</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">){</span>
                     <span class="n">arr</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr2</span><span class="o">++];</span>
                 <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">ptr2</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">){</span>
                     <span class="n">arr</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr1</span><span class="o">++];</span>
                 <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                     <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">[</span><span class="n">ptr1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr2</span><span class="o">]){</span>
                         <span class="n">arr</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr1</span><span class="o">++];</span>
                     <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                         <span class="n">arr</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">sum</span><span class="o">[</span><span class="n">ptr2</span><span class="o">++];</span>
                     <span class="o">}</span>
                 <span class="o">}</span>
             <span class="o">}</span>

             <span class="c1">//将归并好的数组放入前缀和数组中</span>
             <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
                 <span class="n">sum</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
             <span class="o">}</span>
             <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump328"></span></p><h2 id="328奇偶链表">328.奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="no">NULL</span>
<span class="nl">输出:</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="no">NULL</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">2</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">6</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="mi">7</span><span class="o">-&gt;</span><span class="no">NULL</span> 
<span class="nl">输出:</span> <span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="o">-&gt;</span><span class="mi">6</span><span class="o">-&gt;</span><span class="mi">7</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">-&gt;</span><span class="mi">4</span><span class="o">-&gt;</span><span class="no">NULL</span>
</pre></table></code></div></div><p>说明:</p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">oddEvenList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//双指针</span>
        <span class="nc">ListNode</span> <span class="n">pto</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">pte</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//移动节点</span>
            <span class="nc">ListNode</span> <span class="n">o</span> <span class="o">=</span> <span class="n">pte</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="k">break</span><span class="o">;</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">o</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pto</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">pto</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">o</span><span class="o">;</span>
            <span class="n">pte</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="c1">//让这两个指针分别指向奇数子链表和偶数子链表的末端</span>
            <span class="n">pte</span> <span class="o">=</span> <span class="n">pte</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">pto</span> <span class="o">=</span> <span class="n">pto</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">oddEvenList</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="n">ListNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="no">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">head</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="n">pto</span> <span class="o">*</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">var</span> <span class="n">pte</span> <span class="o">*</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">pte</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">var</span> <span class="n">o</span> <span class="o">*</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">pte</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">var</span> <span class="n">tmp</span> <span class="o">*</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">o</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">pto</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">pto</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">pte</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">pte</span> <span class="o">=</span> <span class="n">pte</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">pto</span> <span class="o">=</span> <span class="n">pto</span><span class="o">.</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><span id="jump331"></span></p><h2 id="331-验证二叉树的前序序列化">331. 验证二叉树的前序序列化</h2><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code class="language-plaintext highlighter-rouge">#</code>。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
</pre></table></code></div></div><p>例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"9,3,4,#,#,1,#,#,2,#,6,#,#"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidSerialization</span><span class="o">(</span><span class="nc">String</span> <span class="n">preorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//对于一个有n个节点的二叉树，其空指针的数量为n+1个，也就是“#”有n+1个</span>
        <span class="c1">//从前往后找，如果当前节点是非空节点，那么就消耗1个位子，并提供两个位子</span>
        <span class="c1">//如果当前节点是空节点，那么就消耗1个位子。</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">slots</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">slots</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">','</span><span class="o">){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">){</span>
                <span class="n">slots</span><span class="o">--;</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//遇到了数字，就往后找到第一个逗号</span>
                <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">preorder</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">','</span><span class="o">){</span>
                    <span class="n">i</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="n">slots</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">slots</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="332-重新安排行程">332. 重新安排行程</h2><p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p><p>说明:</p><ol><li>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前</li><li>所有的机场都用三个大写字母表示（机场代码）。</li><li>假定所有机票至少存在一种合理的行程。</li></ol><p>示例 1:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
输出: ["JFK", "MUC", "LHR", "SFO", "SJC"]
</pre></table></code></div></div><p>示例 2:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出: ["JFK","ATL","JFK","SFO","ATL","SFO"]
解释: 另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"]。但是它自然排序更大更靠后。
</pre></table></code></div></div><p>化简题意：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>给定一个n个点m条边的图，要求从指定顶点出发，经过所有边恰好一次，并且路径的字典序最小。
</pre></table></code></div></div><p>这种「一笔画」问题与欧拉图或者半欧拉图有着紧密的联系：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">*</span>	通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。
<span class="p">*</span>	通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。
<span class="p">*</span>	具有欧拉回路的无向图称为欧拉图。
<span class="p">*</span>	具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。
</pre></table></code></div></div><p>因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_重新安排行程_1.png" alt="leetcode_重新安排行程_1" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_重新安排行程_2.png" alt="leetcode_重新安排行程_2" /></p><h3 id="排序">排序</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">findItinerary</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 因为逆序插入，所以用链表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tickets</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tickets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将tickets中的所有边和点都对应存入graph中</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 因为涉及删除操作，我们用链表</span>
            <span class="c1">//当key不存在时，向map中插入(key=value);当key存在时，返回旧值</span>
<span class="c1">//            List&lt;String&gt; nbr = graph.computeIfAbsent(pair.get(0), k -&gt; new LinkedList&lt;&gt;());</span>
            <span class="c1">//所以理论上还可以这样写</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">graph</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))){</span><span class="c1">//不存在此key</span>
                <span class="c1">//新建一项</span>
                <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="c1">//获取邻居列表，并添加项</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="n">nbr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 将每个邻居节点列表按字典序排序</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">values</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">compareTo</span><span class="o">));</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="s">"JFK"</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// DFS方式遍历图，当走到不能走为止，再将节点加入到答案</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="nc">String</span> <span class="n">src</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//获取src的邻居列表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="c1">//nbr为空时，说明这个顶点从始至终都没有邻居，nbr.size等于0时，说明这个顶点的邻居已经被访问完了</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">nbr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">nbr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//访问一个邻居</span>
            <span class="nc">String</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">nbr</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="c1">//DFS</span>
            <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">dest</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">src</span><span class="o">);</span> <span class="c1">// 逆序插入</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="最小堆优先队列代替排序">最小堆/优先队列代替排序：</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">findItinerary</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 因为逆序插入，所以用链表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tickets</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tickets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将tickets中的所有边和点都对应存入graph中</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 因为涉及删除操作，我们用链表</span>
            <span class="c1">//当key不存在时，向map中插入(key=value);当key存在时，返回旧值</span>
<span class="c1">//            List&lt;String&gt; nbr = graph.computeIfAbsent(pair.get(0), k -&gt; new LinkedList&lt;&gt;());</span>
            <span class="c1">//所以理论上还可以这样写</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">graph</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))){</span><span class="c1">//不存在此key</span>
                <span class="c1">//新建一项</span>
                <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span><span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="c1">//获取邻居列表，并添加项</span>
            <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="n">nbr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 将每个邻居节点列表按字典序排序</span>
<span class="c1">//        graph.values().forEach(x -&gt; x.sort(String::compareTo));</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="s">"JFK"</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// DFS方式遍历图，当走到不能走为止，再将节点加入到答案</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="nc">String</span> <span class="n">src</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//获取src的邻居列表</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="c1">//nbr为空时，说明这个顶点从始至终都没有邻居，nbr.size等于0时，说明这个顶点的邻居已经被访问完了</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">nbr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">nbr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//访问一个邻居</span>
            <span class="nc">String</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">nbr</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">//DFS</span>
            <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">dest</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">src</span><span class="o">);</span> <span class="c1">// 逆序插入</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="用stack实现迭代代替递归">用stack实现迭代代替递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">findItinerary</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 因为逆序插入，所以用链表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tickets</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tickets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将tickets中的所有边和点都对应存入graph中</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 因为涉及删除操作，我们用链表</span>
            <span class="c1">//当key不存在时，向map中插入(key=value);当key存在时，返回旧值</span>
<span class="c1">//            List&lt;String&gt; nbr = graph.computeIfAbsent(pair.get(0), k -&gt; new LinkedList&lt;&gt;());</span>
            <span class="c1">//所以理论上还可以这样写</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">graph</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))){</span><span class="c1">//不存在此key</span>
                <span class="c1">//新建一项</span>
                <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span><span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="c1">//获取邻居列表，并添加项</span>
            <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="n">nbr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 将每个邻居节点列表按字典序排序</span>
<span class="c1">//        graph.values().forEach(x -&gt; x.sort(String::compareTo));</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="s">"JFK"</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// DFS方式遍历图，当走到不能走为止，再将节点加入到答案</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="nc">String</span> <span class="n">src</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nbr</span><span class="o">;</span>

            <span class="k">while</span> <span class="o">((</span><span class="n">nbr</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()))</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                    <span class="n">nbr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nbr</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
        <span class="o">}</span>

    <span class="o">}</span>
</pre></table></code></div></div><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：
<span class="p">
*</span> 对于无向图 GG，GG 是欧拉图当且仅当 GG 是连通的且没有奇度顶点。
<span class="p">*</span> 对于无向图 GG，GG 是半欧拉图当且仅当 GG 是连通的且 GG 中恰有 22 个奇度顶点。
<span class="p">*</span> 对于有向图 GG，GG 是欧拉图当且仅当 GG 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。
<span class="p">*</span> 对于有向图 GG，GG 是半欧拉图当且仅当 GG 的所有顶点属于同一个强连通分量且
<span class="p">*</span> 恰有一个顶点的出度与入度差为 11；
<span class="p">*</span> 恰有一个顶点的入度与出度差为 11；
<span class="p">*</span> 所有其他顶点的入度和出度相同。
</pre></table></code></div></div><p><span id="jump336"></span></p><h2 id="336-回文对">336. 回文对</h2><p>给定一组 互不相同 的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。</p><p>示例 1：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：["abcd","dcba","lls","s","sssll"]
输出：[[0,1],[1,0],[3,2],[2,4]] 
解释：可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"]
</pre></table></code></div></div><p>示例 2：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：["bat","tab","cat"]
输出：[[0,1],[1,0]] 
解释：可拼接成的回文串为 ["battab","tabbat"]
</pre></table></code></div></div><h3 id="暴力遍历超出时间限制">暴力遍历(超出时间限制)</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">palindromePairs</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        
        <span class="c1">//遍历所有的索引对，若拼接后的字符串是回文串则将索引加入list</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;++</span><span class="n">j</span><span class="o">){</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
                <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">words</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="c1">//String s2 = words[j] + words[i];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isHWC</span><span class="o">(</span><span class="n">s1</span><span class="o">)){</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
                    
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isHWC</span><span class="o">(</span><span class="n">s2</span><span class="o">)){</span>
                    <span class="n">tmp2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="n">tmp2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tmp2</span><span class="o">);</span>
                <span class="o">}</span>  
            <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>         
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHWC</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">j</span><span class="o">;){</span>
            <span class="k">if</span><span class="o">(!(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>       
            <span class="n">i</span><span class="o">++;</span>
            <span class="n">j</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="对暴力优化">对暴力优化</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_回文对.png" alt="leetcode_回文对" /></p><h3 id="字典树解法">字典树解法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">flag</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">palindromePairs</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">());</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">insert</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">leftId</span> <span class="o">=</span> <span class="n">findWord</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">leftId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">leftId</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">leftId</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">rightId</span> <span class="o">=</span> <span class="n">findWord</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">rightId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rightId</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">rightId</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">add</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">());</span>
                <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">add</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">flag</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">add</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">ch</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">add</span><span class="o">).</span><span class="na">flag</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="哈希表解法">哈希表解法</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordsRev</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">palindromePairs</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">word:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">wordsRev</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">(</span><span class="n">word</span><span class="o">).</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">indices</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">wordsRev</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">leftId</span> <span class="o">=</span> <span class="n">findWord</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">leftId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">leftId</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">leftId</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">rightId</span> <span class="o">=</span> <span class="n">findWord</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">rightId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rightId</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">rightId</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">indices</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump337"></span></p><h2 id="337-打家劫舍-3">337. 打家劫舍 3</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>示例 1:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>输入: [3,2,3,null,3,null,1]
 3
/ \
2  3
\   \ 
 3   1
 输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
</pre></table></code></div></div><p>示例 2:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre> 输入: [3,4,5,1,3,null,1]
     3
    / \
   4   5
  / \   \ 
 1   3   1
 
 输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
</pre></table></code></div></div><h3 id="暴力递归">暴力递归</h3><p><strong>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构</strong></p><p>由于是二叉树，这里可以选择计算所有子节点</p><p>4 个孙子投的钱加上爷爷的钱如下 <code class="language-plaintext highlighter-rouge">int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)</code> 两个儿子偷的钱如下 <code class="language-plaintext highlighter-rouge">int method2 = rob(root.left) + rob(root.right);</code> 挑选一个钱数多的方案则 <code class="language-plaintext highlighter-rouge">int result = Math.max(method1, method2);</code></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">money</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">money</span><span class="o">,</span><span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><h3 id="记忆化-解决重叠问题">记忆化-解决重叠问题</h3><p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p><p>我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。 由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">return</span> <span class="nf">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">memRob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">memo</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">memo</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">root</span><span class="o">))</span> <span class="k">return</span> <span class="n">memo</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">money</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">money</span><span class="o">,</span><span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">));</span>
        
        <span class="n">memo</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">res</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p><p>当前节点选择偷时，那么两个孩子节点就不能选择偷了 当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系) 我们使用一个大小为 2 的数组来表示 <code class="language-plaintext highlighter-rouge">int[] res = new int[2]</code> 0 代表不偷，1 代表偷 <strong>任何一个节点能偷到的最大钱的状态可以定义为</strong></p><ol><li>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</li><li>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li></ol><p>表示为公式如下:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])
root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;
</pre></table></code></div></div><h3 id="规划递归">规划+递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">robInternal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

    <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">left</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
    <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump338"></span></p><h2 id="338-比特位计数">338. 比特位计数</h2><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="mi">5</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>进阶:</p><ul><li>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为O(n)。</li><li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</li></ul><p>观察比特位变化：</p><ul><li>数字2和3是在数字0和1的基础上加1</li><li>数字4，5，6，7是在0，1，2，3的基础上加1</li><li>数字8，9，10，11，12，13，14，15是在0，1，2，3，4，5，6，7的基础上加1</li></ul><p>因此这是一个动态规划问题中的重复子问题。</p><p>最初我用了上述规律中，数字成倍增长的规律来计算，如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">countBits</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">diff</span><span class="o">){</span>
                <span class="n">diff</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">diff</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>   
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>后面发现可以根据最高位的状态来实现：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">countBits</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>  <span class="c1">//i &amp; i-1 == 0说明i已经变化到了最高位向左扩展1的情况</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
          	<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">high</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump341"></span></p><h2 id="341-扁平化嵌套列表迭代器">341. 扁平化嵌套列表迭代器</h2><p>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p><p>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span><span class="mi">2</span><span class="o">,[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="n">通过重复调用</span> <span class="n">next</span> <span class="n">直到</span> <span class="n">hasNext</span> <span class="n">返回</span> <span class="kc">false</span><span class="err">，</span><span class="n">next</span> <span class="nl">返回的元素的顺序应该是:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span><span class="err">。</span>
</pre></table></code></div></div><p>用一个栈存储列表的迭代器，当前栈顶的迭代器是目前访问的嵌套列表的迭代器。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NestedIterator</span> <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;&gt;</span> <span class="n">stack</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">NestedIterator</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">nestedList</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nestedList</span><span class="o">.</span><span class="na">iterator</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">next</span><span class="o">().</span><span class="na">getInteger</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">itr</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">NestedInteger</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">itr</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ni</span><span class="o">.</span><span class="na">isInteger</span><span class="o">()){</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ni</span><span class="o">);</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">());</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ni</span><span class="o">.</span><span class="na">getList</span><span class="o">().</span><span class="na">iterator</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="342-4的幂">342. 4的幂</h2><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。</p><p>整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4^x</p><p>4的幂次方，二进制形式只有1个1，并且这个1处于从低位0开始的偶数位上。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPowerOfFour</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//n如果是2的幂次方，那肯定是4的幂次方</span>
        <span class="c1">//那么只需要再判断出是2的幂次方基础上，判断其为4的幂次就行了</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0xaaaaaaaa</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump344"></span></p><h2 id="344反转字符串">344.反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="s">"h"</span><span class="o">,</span><span class="s">"e"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"o"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"o"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"e"</span><span class="o">,</span><span class="s">"h"</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="s">"H"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"n"</span><span class="o">,</span><span class="s">"n"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"h"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"h"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"n"</span><span class="o">,</span><span class="s">"n"</span><span class="o">,</span><span class="s">"a"</span><span class="o">,</span><span class="s">"H"</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverseString</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">!=</span> <span class="n">s</span><span class="o">[</span><span class="n">high</span><span class="o">]){</span>
                <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
                <span class="n">s</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
                <span class="n">s</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="o">++</span><span class="n">low</span><span class="o">;</span>
            <span class="o">--</span><span class="n">high</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="345-反转字符串中的元音字母">345. 反转字符串中的元音字母</h2><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入："hello"
输出："holle"
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseVowels</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// aeiou</span>
        <span class="c1">// 双指针可以吗？</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'e'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'i'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'o'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'u'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'A'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'E'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'I'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'O'</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'U'</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">l</span><span class="o">]))</span>  <span class="n">l</span><span class="o">++;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">]))</span>  <span class="n">r</span><span class="o">--;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="o">)</span>  <span class="k">break</span><span class="o">;</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
            <span class="n">l</span><span class="o">++;</span>
            <span class="n">r</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump337"></span></p><h2 id="337-打家劫舍-3-1">337. 打家劫舍 3</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>示例 1:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>输入: [3,2,3,null,3,null,1]
 3
/ \
2  3
\   \ 
 3   1
 输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
</pre></table></code></div></div><p>示例 2:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre> 输入: [3,4,5,1,3,null,1]
     3
    / \
   4   5
  / \   \ 
 1   3   1
 
 输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
</pre></table></code></div></div><h3 id="暴力递归-1">暴力递归</h3><p><strong>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构</strong></p><p>由于是二叉树，这里可以选择计算所有子节点</p><p>4 个孙子投的钱加上爷爷的钱如下 <code class="language-plaintext highlighter-rouge">int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)</code> 两个儿子偷的钱如下 <code class="language-plaintext highlighter-rouge">int method2 = rob(root.left) + rob(root.right);</code> 挑选一个钱数多的方案则 <code class="language-plaintext highlighter-rouge">int result = Math.max(method1, method2);</code></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">money</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">money</span><span class="o">,</span><span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><h3 id="记忆化-解决重叠问题-1">记忆化-解决重叠问题</h3><p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p><p>我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。 由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">return</span> <span class="nf">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">memRob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">memo</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">memo</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">root</span><span class="o">))</span> <span class="k">return</span> <span class="n">memo</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">money</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">money</span><span class="o">,</span><span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">memo</span><span class="o">)</span> <span class="o">+</span> <span class="n">memRob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">memo</span><span class="o">));</span>
        
        <span class="n">memo</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">res</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p><p>当前节点选择偷时，那么两个孩子节点就不能选择偷了 当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系) 我们使用一个大小为 2 的数组来表示 <code class="language-plaintext highlighter-rouge">int[] res = new int[2]</code> 0 代表不偷，1 代表偷 <strong>任何一个节点能偷到的最大钱的状态可以定义为</strong></p><ol><li>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</li><li>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li></ol><p>表示为公式如下:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])
root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;
</pre></table></code></div></div><h3 id="规划递归-1">规划+递归</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">robInternal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="n">robInternal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

    <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">left</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
    <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump349"></span></p><h2 id="349两个数组的交集">349.两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
</pre></table></code></div></div><p>说明：</p><ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p>哈希表：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//哈希表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>都放入set中，再遍历较小的set：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//哈希表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">set1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">set2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="nf">compareSet</span><span class="o">(</span><span class="n">set1</span><span class="o">,</span> <span class="n">set2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="nf">compareSet</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set2</span><span class="o">){</span>
      	<span class="c1">//这个很有趣，可以避免重复代码</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">set2</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
            <span class="k">return</span> <span class="nf">compareSet</span><span class="o">(</span><span class="n">set2</span><span class="o">,</span><span class="n">set1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">resSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">num</span> <span class="o">:</span> <span class="n">set1</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set2</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">)){</span>
                <span class="n">resSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">resSet</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>

        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">num</span> <span class="o">:</span> <span class="n">resSet</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump354"></span></p><h2 id="354-俄罗斯套娃信封问题">354. 俄罗斯套娃信封问题</h2><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>说明: 不允许旋转信封。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">envelopes</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="mi">3</span> 
<span class="nl">解释:</span> <span class="n">最多信封的个数为</span> <span class="mi">3</span><span class="o">,</span> <span class="nl">组合为:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span><span class="err">。</span>
</pre></table></code></div></div><p>固定一个维度，找出另一维度的最长递增序列</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//首先按宽度递增排序，在宽度相等的情况下，按长度递减排序</span>
    <span class="c1">//例如：（1，3），（1，2），（2，4），（2，3），</span>
    <span class="c1">//这样排序我们就能忽略宽度，找出最长严格递增的长度序列</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxEnvelopes</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">envelopes</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">envelopes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">envelopes</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">!=</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">envelopes</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">envelopes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump376"></span></p><h2 id="376-摆动序列">376. 摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">6</span> 
<span class="nl">解释:</span> <span class="n">整个序列均为摆动序列</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">7</span>
<span class="nl">解释:</span> <span class="n">这个序列包含几个长度为</span> <span class="mi">7</span> <span class="n">摆动序列</span><span class="err">，</span><span class="n">其中一个可为</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
</pre></table></code></div></div><p>进阶:</p><ul><li>你能否用 O(n) 时间复杂度完成此题?</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">wiggleMaxLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//遍历序列，遇到连续上升序列时，保留峰值，遇到连续下降序列时，保留谷值</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span><span class="c1">//相邻两个数字相等，需要去掉一个</span>
                <span class="n">cnt</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">*</span> <span class="n">cur</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span><span class="c1">//相邻两个差值同号，需要去掉一个数字</span>
                        <span class="n">cnt</span><span class="o">--;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="n">func</span> <span class="nf">wiggleMaxLength</span><span class="o">(</span><span class="n">nums</span> <span class="o">[]</span><span class="kt">int</span><span class="o">)</span> <span class="kt">int</span> <span class="o">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="n">len</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="o">}</span>

    <span class="n">pre</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">cnt</span> <span class="o">:=</span> <span class="n">n</span>
    <span class="c1">//遍历序列，遇到连续上升序列时，保留峰值，遇到连续下降序列时，保留谷值</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++</span> <span class="o">{</span>
        <span class="n">cur</span> <span class="o">:=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span>
        <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">{</span><span class="c1">//相邻两个数字相等，需要去掉一个</span>
            <span class="n">cnt</span><span class="o">--</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="k">if</span> <span class="n">pre</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">{</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span> <span class="n">pre</span> <span class="o">*</span> <span class="n">cur</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">{</span><span class="c1">//相邻两个差值同号，需要去掉一个数字</span>
                    <span class="n">cnt</span><span class="o">--</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">cnt</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump378"></span></p><h2 id="378-有序矩阵中第k小元素">378. 有序矩阵中第k小元素</h2><p>给定一个 <em><code class="language-plaintext highlighter-rouge">n x n</code></em> 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 <code class="language-plaintext highlighter-rouge">k</code> 小的元素。 请注意，它是排序后的第 <code class="language-plaintext highlighter-rouge">k</code> 小元素，而不是第 <code class="language-plaintext highlighter-rouge">k</code> 个不同的元素。</p><p><strong>示例：</strong></p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
</pre></table></code></div></div><p><strong>提示：</strong> 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。</p><h3 id="直接排序">直接排序</h3><p>将这个二维数组另存为一维数组，并对该一维数组进行排序。最后返回第k个数，即为答案。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">*</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">v</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></table></code></div></div><h3 id="归并排序没看懂">归并排序(没看懂)</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">});</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">now</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">matrix</span><span class="o">[</span><span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]][</span><span class="n">now</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">],</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">now</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">()[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="二分查找还没看">二分查找(还没看)</h3><p>由题目给出的性质可知，这个矩阵内的元素是从左上到右下递增的（假设矩阵左上角为 matrix[0][0]<em>m<strong>a</strong>t<strong>r</strong>i**x</em>[0][0]）。以下图为例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_有序矩阵中的第k小元素.png" alt="leetcode_有序矩阵中的第k小元素" /></p><p>我们知道整个二维数组中 <code class="language-plaintext highlighter-rouge">matrix[0][0]</code> 为最小值，<code class="language-plaintext highlighter-rouge">matrix[n−1][n−1]</code> 为最大值，现在我们将其分别记作<code class="language-plaintext highlighter-rouge"> l</code>和<code class="language-plaintext highlighter-rouge"> r</code>。</p><p>可以发现一个性质：任取一个数 <code class="language-plaintext highlighter-rouge">mid</code> 满足 <code class="language-plaintext highlighter-rouge">l≤mid≤r</code>，那么矩阵中不大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数，肯定全部分布在矩阵的左上角。</p><p>例如上图，取 <code class="language-plaintext highlighter-rouge">mid=8</code>，我们可以看到，矩阵中大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数就和不大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数分别形成了两个板块，沿着一条锯齿线将这个矩形分开。其中左上角板块的大小即为矩阵中不大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数的数量。</p><p>初始位置在 <code class="language-plaintext highlighter-rouge">matrix[n−1][0]</code>（即左下角）；</p><p>设当前位置为 <code class="language-plaintext highlighter-rouge">matrix[i][j]</code>。若<code class="language-plaintext highlighter-rouge">matrix[i][j]≤mid</code>，则将当前所在列的不大于 <code class="language-plaintext highlighter-rouge">mid</code> 的数的数量（即 <code class="language-plaintext highlighter-rouge">i+1</code>）累加到答案中，并向右移动，否则向上移动；</p><p>不断移动直到走出格子为止。</p><p>我们发现这样的走法时间复杂度为 O(n)，即我们可以线性计算对于任意一个 <code class="language-plaintext highlighter-rouge">mid</code>，矩阵中有多少数不大于它。这满足了二分查找的性质。</p><p>不妨假设答案为 <code class="language-plaintext highlighter-rouge">x</code>，那么可以知道<code class="language-plaintext highlighter-rouge">l≤x≤r</code>，这样就确定了二分查找的上下界。</p><p>每次对于「猜测」的答案<code class="language-plaintext highlighter-rouge"> mid</code>，计算矩阵中有多少数不大于 <code class="language-plaintext highlighter-rouge">mid</code> ：</p><p>如果数量不少于 <code class="language-plaintext highlighter-rouge">k</code>，那么说明最终答案 <code class="language-plaintext highlighter-rouge">x</code> 不大于 <code class="language-plaintext highlighter-rouge">mid</code>； 如果数量少于 <code class="language-plaintext highlighter-rouge">k</code>，那么说明最终答案 <code class="language-plaintext highlighter-rouge">x</code> 大于<code class="language-plaintext highlighter-rouge">mid</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump381"></span></p><h2 id="381o1-时间插入删除和获取随机元素---允许重复">381.O(1) 时间插入、删除和获取随机元素 - 允许重复</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><ul><li>insert(val)：向集合中插入元素 val。</li><li>remove(val)：当 val 存在时，从集合中移除一个 val。</li><li>getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</li></ul><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// 初始化一个空的集合。</span>
<span class="nc">RandomizedCollection</span> <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RandomizedCollection</span><span class="o">();</span>

<span class="c1">// 向集合中插入 1 。返回 true 表示集合不包含 1 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="c1">// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="c1">// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

<span class="c1">// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span>

<span class="c1">// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="c1">// getRandom 应有相同概率返回 1 和 2 。</span>
<span class="n">collection</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span>
</pre></table></code></div></div><p>用一个列表存放元素，再用一个map存放元素与下标的对应。</p><p>插入时，直接将元素插入到列表的最后，然后在map中更新元素索引。</p><p>删除时，从map中取出对应元素的索引，再在列表中将此元素与列表最后一个元素交换，最后删除列表最后一个元素即可。</p><p>需要注意的是：此元素可能与列表最后一个元素相等，那么就需要同步更新set和hashMap。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">RandomizedCollection</span> <span class="o">{</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">;</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">hashIndex</span><span class="o">;</span>
    <span class="cm">/** Initialize your data structure here. */</span>
    <span class="kd">public</span> <span class="nf">RandomizedCollection</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">hashIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="cm">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">hashIndex</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">hashIndex</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">set</span><span class="o">);</span>
        <span class="c1">//size==1说明当前插入的元素是唯一的，没有重复</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>

    <span class="o">}</span>
    
    <span class="cm">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">hashIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//根据迭代器获取val在set中的索引</span>
        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">itr</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">lastSet</span> <span class="o">=</span> <span class="n">hashIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
      	<span class="c1">//当需要删除的元素和列表最后一个元素不相等时，才需要分别更新两个集合</span>
      	<span class="c1">//因为从set中删除一个元素，需要更新索引</span>
      	<span class="c1">//从lastSet中删除并插入一个元素，需要更新索引</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set</span> <span class="o">!=</span> <span class="n">lastSet</span><span class="o">){</span>
            <span class="n">lastSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">lastSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
          	<span class="c1">//如果是同一个元素，那么直接删除set最后一个的值即可</span>
            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
      	<span class="c1">//当set为空时，就清出map</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">hashIndex</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="c1">//最后处理列表：将找到的索引与最后一个元素交换，然后删除</span>
        <span class="n">nums</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
        <span class="n">nums</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/** Get a random element from the collection. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump387"></span></p><h2 id="387-字符串中的第一个唯一字符">387. 字符串中的第一个唯一字符</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">s</span> <span class="o">=</span> <span class="s">"leetcode"</span>
<span class="n">返回</span> <span class="mi">0</span>

<span class="n">s</span> <span class="o">=</span> <span class="s">"loveleetcode"</span>
<span class="n">返回</span> <span class="mi">2</span>
</pre></table></code></div></div><p>提示：你可以假定该字符串只包含小写字母。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstUniqChar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump389"></span></p><h2 id="389-找不同">389. 找不同</h2><p>给定两个字符串 s 和 t，它们只包含小写字母。</p><p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 t 中被添加的字母。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"abcde"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"e"</span>
<span class="n">解释</span><span class="err">：</span><span class="sc">'e'</span> <span class="n">是那个被添加的字母</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">""</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"y"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"y"</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"aa"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"a"</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"ae"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"aea"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"a"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 1000</li><li>t.length == s.length + 1</li><li>s 和 t 只包含小写字母</li></ul><p>位运算：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">char</span> <span class="nf">findTheDifference</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>        
        <span class="kt">char</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">tl</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sl</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tl</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">findTheDifference</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">,</span> <span class="n">t</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
    <span class="nb">len</span><span class="p">,</span> <span class="n">ch</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">t</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">ch</span> <span class="o">^=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ch</span> <span class="o">^=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ch</span>
<span class="p">}</span>
</pre></table></code></div></div><p><span id="394"></span></p><h2 id="394字符串解码">394.字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"3[a]2[bc]"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"aaabcbc"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"3[a2[c]]"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"accaccacc"</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"2[abc]3[cd]ef"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"abcabccdcdcdef"</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abc3[cd]xyz"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"abccdcdcdxyz"</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">decodeString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">chars</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">times</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="c1">//遍历字符数组，把数字放入time栈，把字符放入chars栈</span>
        <span class="c1">//当遇到"]"时，出栈chars元素，直到碰到"["，再出栈一个times元素</span>
        <span class="c1">//将组成的字符串重复多次，再放入chars</span>
        <span class="c1">//当读取完了数组，就将chars字符串拼接并且reverse</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">']'</span><span class="o">){</span>
                <span class="c1">//出栈</span>
                <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
                <span class="k">while</span><span class="o">(!</span><span class="n">chars</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"["</span><span class="o">)){</span>
                    <span class="nc">String</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">chars</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">//删除"]"</span>
                <span class="n">chars</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="c1">//重复字符串time-1次</span>
                <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">time</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">chars</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="c1">//连续读取数字如'1','0','0'读为100</span>
                <span class="nc">StringBuffer</span> <span class="n">digit</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
                <span class="n">digit</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">])){</span>
                    <span class="n">digit</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
                    <span class="n">i</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="n">times</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">digit</span><span class="o">.</span><span class="na">toString</span><span class="o">()));</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">chars</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">""</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">StringBuffer</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">chars</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">chars</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump395"></span></p><h2 id="395-至少有k个重复字符的最长子串">395. 至少有K个重复字符的最长子串</h2><p>找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="n">s</span> <span class="o">=</span> <span class="s">"aaabb"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>

<span class="nl">输出:</span>
<span class="mi">3</span>

<span class="n">最长子串为</span> <span class="s">"aaa"</span> <span class="err">，</span><span class="n">其中</span> <span class="sc">'a'</span> <span class="n">重复了</span> <span class="mi">3</span> <span class="n">次</span><span class="err">。</span>
</pre></table></code></div></div><p>像这样把一个序列分成多段的问题，可以优先考虑分治。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//分治，以子串中数量少于k的字符作为分界</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">table</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="kt">char</span> <span class="n">split</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//找到子串中数量少于k的字符</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">split</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">split</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//分治</span>
        <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="c1">//先越过开头的所有split</span>
            <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span> <span class="o">==</span> <span class="n">split</span><span class="o">){</span>
                <span class="n">idx</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span>
            <span class="c1">//找到不含split的子串</span>
            <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span> <span class="o">!=</span> <span class="n">split</span><span class="o">){</span>
                <span class="n">idx</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">len</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump399"></span></p><h2 id="399-除法求值">399. 除法求值</h2><p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">equations</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"b"</span><span class="o">],[</span><span class="s">"b"</span><span class="o">,</span><span class="s">"c"</span><span class="o">]],</span> <span class="n">values</span> <span class="o">=</span> <span class="o">[</span><span class="mf">2.0</span><span class="o">,</span><span class="mf">3.0</span><span class="o">],</span> <span class="n">queries</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"c"</span><span class="o">],[</span><span class="s">"b"</span><span class="o">,</span><span class="s">"a"</span><span class="o">],[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"e"</span><span class="o">],[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"a"</span><span class="o">],[</span><span class="s">"x"</span><span class="o">,</span><span class="s">"x"</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mf">6.00000</span><span class="o">,</span><span class="mf">0.50000</span><span class="o">,-</span><span class="mf">1.00000</span><span class="o">,</span><span class="mf">1.00000</span><span class="o">,-</span><span class="mf">1.00000</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">条件</span><span class="err">：</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">,</span> <span class="n">b</span> <span class="o">/</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="n">问题</span><span class="err">：</span><span class="n">a</span> <span class="o">/</span> <span class="n">c</span> <span class="o">=</span> <span class="o">?,</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span> <span class="o">=</span> <span class="o">?,</span> <span class="n">a</span> <span class="o">/</span> <span class="n">e</span> <span class="o">=</span> <span class="o">?,</span> <span class="n">a</span> <span class="o">/</span> <span class="n">a</span> <span class="o">=</span> <span class="o">?,</span> <span class="n">x</span> <span class="o">/</span> <span class="n">x</span> <span class="o">=</span> <span class="o">?</span>
<span class="n">结果</span><span class="err">：</span><span class="o">[</span><span class="mf">6.0</span><span class="o">,</span> <span class="mf">0.5</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">equations</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"b"</span><span class="o">],[</span><span class="s">"b"</span><span class="o">,</span><span class="s">"c"</span><span class="o">],[</span><span class="s">"bc"</span><span class="o">,</span><span class="s">"cd"</span><span class="o">]],</span> <span class="n">values</span> <span class="o">=</span> <span class="o">[</span><span class="mf">1.5</span><span class="o">,</span><span class="mf">2.5</span><span class="o">,</span><span class="mf">5.0</span><span class="o">],</span> <span class="n">queries</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"c"</span><span class="o">],[</span><span class="s">"c"</span><span class="o">,</span><span class="s">"b"</span><span class="o">],[</span><span class="s">"bc"</span><span class="o">,</span><span class="s">"cd"</span><span class="o">],[</span><span class="s">"cd"</span><span class="o">,</span><span class="s">"bc"</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mf">3.75000</span><span class="o">,</span><span class="mf">0.40000</span><span class="o">,</span><span class="mf">5.00000</span><span class="o">,</span><span class="mf">0.20000</span><span class="o">]</span>
<span class="n">示例</span> <span class="mi">3</span><span class="err">：</span>

<span class="n">输入</span><span class="err">：</span><span class="n">equations</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"b"</span><span class="o">]],</span> <span class="n">values</span> <span class="o">=</span> <span class="o">[</span><span class="mf">0.5</span><span class="o">],</span> <span class="n">queries</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"b"</span><span class="o">],[</span><span class="s">"b"</span><span class="o">,</span><span class="s">"a"</span><span class="o">],[</span><span class="s">"a"</span><span class="o">,</span><span class="s">"c"</span><span class="o">],[</span><span class="s">"x"</span><span class="o">,</span><span class="s">"y"</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mf">0.50000</span><span class="o">,</span><span class="mf">2.00000</span><span class="o">,-</span><span class="mf">1.00000</span><span class="o">,-</span><span class="mf">1.00000</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= equations.length &lt;= 20</li><li>equations[i].length == 2</li><li>1 &lt;= Ai.length, Bi.length &lt;= 5</li><li>values.length == equations.length</li><li>0.0 &lt; values[i] &lt;= 20.0</li><li>1 &lt;= queries.length &lt;= 20</li><li>queries[i].length == 2</li><li>1 &lt;= Cj.length, Dj.length &lt;= 5</li><li>Ai, Bi, Cj, Dj 由小写英文字母与数字组成</li></ul><p>并查集：</p><p>a / b = 2.0 说明 a = 2b， a 和 b 在一个集合中；</p><p>b / c = 3.0 说明 b = 3c ，b 和 c 在一个集合中。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210106100326546.png" alt="image-20210106100326546" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210106100432917.png" alt="image-20210106100432917" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span><span class="o">[]</span> <span class="nf">calcEquation</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">equations</span><span class="o">,</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">values</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">e_size</span> <span class="o">=</span> <span class="n">equations</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="nc">UnionFind</span> <span class="n">unionFind</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UnionFind</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">e_size</span><span class="o">);</span>
        <span class="c1">//预处理，将变量值与id进行映射</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">e_size</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e_size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">equation</span> <span class="o">=</span> <span class="n">equations</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

            <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s1</span><span class="o">)){</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
                <span class="n">id</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s2</span><span class="o">)){</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
                <span class="n">id</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="n">unionFind</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s1</span><span class="o">),</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s2</span><span class="o">),</span> <span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">//做查询</span>
        <span class="kt">int</span> <span class="n">q_size</span> <span class="o">=</span> <span class="n">queries</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="kt">double</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">q_size</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q_size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">queries</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">queries</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

            <span class="nc">Integer</span> <span class="n">id1</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="nc">Integer</span> <span class="n">id2</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>

            <span class="k">if</span><span class="o">(</span><span class="n">id1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">id2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0d</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">unionFind</span><span class="o">.</span><span class="na">isConnected</span><span class="o">(</span><span class="n">id1</span><span class="o">,</span> <span class="n">id2</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">UnionFind</span><span class="o">{</span>
        <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
        <span class="c1">//指向父节点的权值</span>
        <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">weight</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">UnionFind</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="n">weight</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mf">1.0d</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">double</span> <span class="n">value</span><span class="o">){</span>
            <span class="c1">//找到x和y的根结点</span>
            <span class="kt">int</span> <span class="n">rootX</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">rootY</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rootX</span> <span class="o">==</span> <span class="n">rootY</span><span class="o">){</span>
                <span class="c1">//如果根结点相同，直接返回</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//如果根结点不相同，就指定x的根结点作为rootY的根结点</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootX</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="o">;</span>
            <span class="n">weight</span><span class="o">[</span><span class="n">rootX</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">[</span><span class="n">y</span><span class="o">]</span> <span class="o">*</span> <span class="n">value</span> <span class="o">/</span> <span class="n">weight</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="c1">//查找根结点，同时进行路径压缩</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]){</span>
                <span class="kt">int</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
                <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
                <span class="n">weight</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">*=</span> <span class="n">weight</span><span class="o">[</span><span class="n">origin</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">double</span> <span class="nf">isConnected</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">rootX</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">rootY</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rootX</span> <span class="o">==</span> <span class="n">rootY</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">weight</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">/</span> <span class="n">weight</span><span class="o">[</span><span class="n">y</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mf">1.0d</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>


    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump402"></span></p><h2 id="402移掉k位数字">402.移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><ul><li>num 的长度小于 10002 且 ≥ k。</li><li>num 不会包含任何前导零。</li></ul><p>示例 1 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">num</span> <span class="o">=</span> <span class="s">"1432219"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nl">输出:</span> <span class="s">"1219"</span>
<span class="nl">解释:</span> <span class="n">移除掉三个数字</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="n">和</span> <span class="mi">2</span> <span class="n">形成一个新的最小的数字</span> <span class="mi">1219</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">num</span> <span class="o">=</span> <span class="s">"10200"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nl">输出:</span> <span class="s">"200"</span>
<span class="nl">解释:</span> <span class="n">移掉首位的</span> <span class="mi">1</span> <span class="n">剩下的数字为</span> <span class="mi">200</span><span class="o">.</span> <span class="n">注意输出不能有任何前导零</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">num</span> <span class="o">=</span> <span class="s">"10"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="s">"0"</span>
<span class="nl">解释:</span> <span class="n">从原数字移除所有的数字</span><span class="err">，</span><span class="n">剩余为空就是0</span><span class="err">。</span>
</pre></table></code></div></div><p>逐个删除数字期望开头的数字越小越好。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">removeKdigits</span><span class="o">(</span><span class="nc">String</span> <span class="n">num</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="c1">//双端队列</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将所有元素依次入栈</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="c1">//当当前元素比栈顶元素小时，且k&gt;0时，将栈顶弹出</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">){</span>
                <span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
                <span class="n">k</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//若序列都已经单调不降了，但是还有没删干净的数字，那么就将最后几个数字删了</span>
        <span class="k">while</span><span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
            <span class="n">k</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">//去除前导0</span>
        <span class="k">while</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">){</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//读取数字</span>
        <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">//队列为空，就返回0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="s">"0"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump404"></span></p><h2 id="404左叶子之和">404.左叶子之和</h2><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>		<span class="mi">3</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">9</span>  <span class="mi">20</span>
    <span class="o">/</span>  <span class="err">\</span>
   <span class="mi">15</span>   <span class="mi">7</span>
</pre></table></code></div></div><p>递归即可，当访问左子树时，做一次标记，这样可以在访问到左叶子的时候计算和。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumOfLeftLeaves</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">traversal</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="kc">false</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">traversal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isLeft</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">isLeft</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>   <span class="n">traversal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>  <span class="n">traversal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id=" jump406"></span></p><h2 id="406根据身高重建队列">406.根据身高重建队列</h2><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p><p>注意： 总人数少于1100人。</p><p>示例</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="nl">输入:</span>       
<span class="o">[[</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>

<span class="nl">输出:</span>
<span class="o">[[</span><span class="mi">5</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
</pre></table></code></div></div><p>观察数组，如果将数组按<code class="language-plaintext highlighter-rouge">people[i][0]</code>逆序排序，然后逐个插入到新数组中，发现<code class="language-plaintext highlighter-rouge">people[i][1]</code>就是此元素需要在数组插入的位置，向后移动数组，再进行插入即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">reconstructQueue</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">people</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//将数组按people[i][0]逆序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span>
                    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">people</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">people</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">insert</span><span class="o">(</span><span class="n">res</span><span class="o">,</span><span class="n">people</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">people</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tail</span><span class="o">){</span>
        <span class="c1">//k是此元素在数组中需要被插入的位置</span>
        <span class="c1">//先把k以后的元素都往后挪，腾出第k个位置</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
        <span class="n">res</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>用list代替数组来提高效率，实际上用的方法是一样的，只不过上面这种方法实现了下面list的底层思想，效率没它高罢了：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">reconstructQueue</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">people</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//将数组按people[i][0]逆序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span>
                    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">people</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">people</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span><span class="n">people</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">people</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">]);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump416"></span></p><h2 id="416分割等和子集">416.分割等和子集</h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><p>每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>

<span class="nl">输出:</span> <span class="kc">true</span>

<span class="nl">解释:</span> <span class="n">数组可以分割成</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span> <span class="n">和</span> <span class="o">[</span><span class="mi">11</span><span class="o">].</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>

<span class="nl">输出:</span> <span class="kc">false</span>

<span class="nl">解释:</span> <span class="n">数组不能分割成两个元素和相等的子集</span><span class="o">.</span>
</pre></table></code></div></div><p>动态规划：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPartition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span>  <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxNum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">maxNum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxNum</span><span class="o">,</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">//和不能被2整除，肯定false</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span>  <span class="o">/</span><span class="mi">2</span><span class="o">;</span>
        <span class="c1">//最大元素比总和的一半都大，肯定不能平分</span>
        <span class="k">if</span><span class="o">(</span><span class="n">maxNum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">//dp[i][j] 表示是否能够从下标为0~i的数组元素中选取若干个元素时，和为j。</span>

        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                
                <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                    <span class="c1">//当j &lt; nums[i]时，肯定不能选nums[i]，所以dp[i][j]只能由dp[i-1][j]决定</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//当j &gt;= nums[i]时，nums[i]可选可不选</span>
                    <span class="c1">//如果选了，就取决于dp[i-1][j-nums[i]]是否为true</span>
                    <span class="c1">//如果不选，就取决于d[i-1][j]</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">target</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump424"></span></p><h2 id="424-替换后的最长重复字符">424. 替换后的最长重复字符</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p>注意：字符串长度 和 k 不会超过 104。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"ABAB"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">用两个</span><span class="sc">'A'</span><span class="n">替换为两个</span><span class="sc">'B'</span><span class="o">,</span><span class="n">反之亦然</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"AABABBA"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">将中间的一个</span><span class="sc">'A'</span><span class="n">替换为</span><span class="sc">'B'</span><span class="o">,</span><span class="n">字符串变为</span> <span class="s">"AABBBBA"</span><span class="err">。</span>
<span class="n">子串</span> <span class="s">"BBBB"</span> <span class="n">有最长重复字母</span><span class="o">,</span> <span class="n">答案为</span> <span class="mi">4</span><span class="err">。</span>
</pre></table></code></div></div><p>滑动窗口。</p><p>当k==0时，当窗口内的字母都是同一种字母时，窗口就往右扩张，如果出现了不同种字母，窗口就整体右移。</p><p>当k&gt;0时，当窗口内的其他字母数目低于k时，窗口就往右扩张，如果窗口内少数字母数目高于k时，窗口就整体右移。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">characterReplacement</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">]++;</span>
            <span class="c1">//更新窗口中出现最多的字符长度</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">max</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">count</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">]--;</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">right</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump435"></span></p><h2 id="435-无重叠区间">435. 无重叠区间</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">]</span>

<span class="nl">输出:</span> <span class="mi">1</span>

<span class="nl">解释:</span> <span class="n">移除</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="n">后</span><span class="err">，</span><span class="n">剩下的区间没有重叠</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">]</span>

<span class="nl">输出:</span> <span class="mi">2</span>

<span class="nl">解释:</span> <span class="n">你需要移除两个</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="n">来使剩下的区间没有重叠</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">]</span>

<span class="nl">输出:</span> <span class="mi">0</span>

<span class="nl">解释:</span> <span class="n">你不需要移除任何区间</span><span class="err">，</span><span class="n">因为它们已经是无重叠的了</span><span class="err">。</span>
</pre></table></code></div></div><p>贪心：</p><ul><li>区间相交，就把后一个区间删除</li><li>区间重合，就把前一个区间删除</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//按区间的开始位置排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="c1">//需要删除的区间个数</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//遍历区间</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//如果当前区间和前一个区间无重叠， 就更新l和r</span>
            <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="c1">//如果当前区间被前一个区间包裹住了，那就把前一个区间删除</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">res</span><span class="o">++;</span>

            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">){</span><span class="c1">//如果两个区间只是相交，那就把后一个区间删除</span>
                <span class="n">res</span><span class="o">++;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//按区间的结束位置排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">});</span>
        <span class="c1">//可留下的区间个数</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//遍历区间</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//如果当前区间和前一个区间无重叠， 就更新r</span>
            <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">){</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump437"></span></p><h2 id="437路径总和-iii">437.路径总和 III</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p>示例：</p><p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

 5 -&gt; 3
 5 -&gt; 2 -&gt; 1
-3 -&gt; 11
</pre></table></code></div></div><p>和第560题类似，只不过这里是多个数组。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pathSum</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//统计每个节点的前缀和pre，放入哈希表中</span>
        <span class="c1">//再遍历每条路径，统计pre - sum出现的个数</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">preOrder</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">root</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">preOrder</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pre</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">pre</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="o">)){</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">preOrder</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">pre</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="n">preOrder</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">pre</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="c1">//回溯，这样在每个时刻，map中的节点都是同一条路径上的</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pre</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump438"></span></p><h2 id="438找到字符串中所有字母异位词">438.找到字符串中所有字母异位词</h2><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><p>字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="nl">s:</span> <span class="s">"cbaebabacd"</span> <span class="nl">p:</span> <span class="s">"abc"</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>

<span class="nl">解释:</span>
<span class="n">起始索引等于</span> <span class="mi">0</span> <span class="n">的子串是</span> <span class="s">"cba"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"abc"</span> <span class="n">的字母异位词</span><span class="err">。</span>
<span class="n">起始索引等于</span> <span class="mi">6</span> <span class="n">的子串是</span> <span class="s">"bac"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"abc"</span> <span class="n">的字母异位词</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="nl">s:</span> <span class="s">"abab"</span> <span class="nl">p:</span> <span class="s">"ab"</span>

<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>

<span class="nl">解释:</span>
<span class="n">起始索引等于</span> <span class="mi">0</span> <span class="n">的子串是</span> <span class="s">"ab"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"ab"</span> <span class="n">的字母异位词</span><span class="err">。</span>
<span class="n">起始索引等于</span> <span class="mi">1</span> <span class="n">的子串是</span> <span class="s">"ba"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"ab"</span> <span class="n">的字母异位词</span><span class="err">。</span>
<span class="n">起始索引等于</span> <span class="mi">2</span> <span class="n">的子串是</span> <span class="s">"ab"</span><span class="o">,</span> <span class="n">它是</span> <span class="s">"ab"</span> <span class="n">的字母异位词</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findAnagrams</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">np</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ns</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span>  <span class="n">res</span><span class="o">;</span>

        <span class="c1">//现将p中的字符打到表中</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">table</span><span class="o">[</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="c1">//初始化滑动窗口，窗口大小为np</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="c1">//记录窗口状态的表</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="o">(</span><span class="n">ns</span><span class="o">-</span><span class="n">np</span><span class="o">)){</span>
            <span class="c1">//窗口增长期</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">l</span><span class="o">){</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
                <span class="kt">boolean</span> <span class="n">tag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">+</span><span class="n">np</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                    <span class="c1">//table表中没有这个字符</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">table</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="c1">//table表中有这个字符</span>

                    <span class="c1">//这个字符出现的次数超过了table表</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">table</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]+</span><span class="mi">1</span><span class="o">){</span>
                        <span class="n">l</span><span class="o">++;</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">cur</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
                <span class="o">}</span>
                <span class="c1">//是由于异常才结束循环的</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tag</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//正常结束循环，说明全部比较完毕了，都没有出现异常</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">np</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//窗口滑动期</span>
                <span class="c1">//指针l和r同时向右滑动一个单位</span>
                <span class="n">r</span><span class="o">++;</span>
                <span class="c1">//超出了边界</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ns</span><span class="o">){</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//新加入的字符和移出去的字符相同</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">l</span><span class="o">]){</span>
                    <span class="n">l</span><span class="o">++;</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//回到窗口增长期</span>
                    <span class="n">l</span><span class="o">++;</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>


        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump448"></span></p><h2 id="448找到所有数组中消失的数字">448.找到所有数组中消失的数字</h2><p>给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span>
<span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span>
</pre></table></code></div></div><p>另类哈希，这样可以处理哈希值是二值的情况！</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findDisappearedNumbers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    
        <span class="c1">//遍历数组每个元素，将|nums[i]| - 1处的数字标记为负数</span>
        <span class="c1">//已经是负数的就不处理</span>
        <span class="c1">//-1是为了让1~n映射到0~n-1</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//遍历处理过后的nums，</span>
        <span class="c1">//值为负数的位置对应的索引值就是出现在数组中的数字，</span>
        <span class="c1">//非负数就是没出现在其中的数字</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span>  <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="451-根据字符出现频率排序">451. 根据字符出现频率排序</h2><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p>示例 1:</p><p>输入: “tree”</p><p>输出: “eert”</p><p>解释: ‘e’出现两次，’r’和’t’都只出现一次。 因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">frequencySort</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">-</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="n">c</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">);</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump452"></span></p><h2 id="452用最少数量的箭引爆气球">452.用最少数量的箭引爆气球</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">10</span><span class="o">,</span><span class="mi">16</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">8</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">12</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span><span class="n">对于该样例</span><span class="err">，</span><span class="n">x</span> <span class="o">=</span> <span class="mi">6</span> <span class="n">可以射爆</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">8</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span> <span class="n">两个气球</span><span class="err">，</span><span class="n">以及</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">11</span> <span class="n">射爆另外两个气球</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>示例 5：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= points.length &lt;= 104</li><li>points[i].length == 2</li><li>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</li></ul><p>贪心左端点排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMinArrowShots</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">points</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//区间排序：先按开始坐标升序排序，再按结束坐标升序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//贪心地覆盖一个区间，使其包括后序与此区间相交区间，并更新此区间为二者的交集</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//cur的结束大于等于下一个区间的开始，说明可以一起戳破</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="c1">//更新cur</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//cur的结束小于下一个区间的开始，说明没办法一起戳破了</span>
                <span class="c1">//弓箭数+1，移动cur</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>贪心右端点排序，只需要知道最远可射到的位置即可</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMinArrowShots</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">points</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//区间排序：先按开始坐标升序排序，再按结束坐标升序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//贪心地覆盖一个区间，使其包括后序与此区间相交区间，并更新此区间为二者的交集</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//cur的结束大于等于下一个区间的开始，说明可以一起戳破</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump455"></span></p><h2 id="455-分发饼干">455. 分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">g</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">1</span>
<span class="nl">解释:</span> 
<span class="n">你有三个孩子和两块小饼干</span><span class="err">，</span><span class="mi">3</span><span class="n">个孩子的胃口值分别是</span><span class="err">：</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="err">。</span>
<span class="n">虽然你有两块小饼干</span><span class="err">，</span><span class="n">由于他们的尺寸都是1</span><span class="err">，</span><span class="n">你只能让胃口值是1的孩子满足</span><span class="err">。</span>
<span class="n">所以你应该输出1</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">g</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
<span class="nl">解释:</span> 
<span class="n">你有两个孩子和三块小饼干</span><span class="err">，</span><span class="mi">2</span><span class="n">个孩子的胃口值分别是1</span><span class="o">,</span><span class="mi">2</span><span class="err">。</span>
<span class="n">你拥有的饼干数量和尺寸都足以让所有孩子满足</span><span class="err">。</span>
<span class="n">所以你应该输出2</span><span class="o">.</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= g.length &lt;= 3 * 104</li><li>0 &lt;= s.length &lt;= 3 * 104</li><li>1 &lt;= g[i], s[j] &lt;= 231 - 1</li></ul><p>排序+双指针</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findContentChildren</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">g</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">g</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="n">g</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">g</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">[</span><span class="n">p2</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">p1</span><span class="o">++;</span>
                <span class="n">p2</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">p2</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump456"></span></p><h2 id="456-132模式">456. 132模式</h2><p>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。</p><p>注意：n 的值小于15000。</p><p>示例1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>

<span class="nl">输出:</span> <span class="nc">False</span>

<span class="nl">解释:</span> <span class="n">序列中不存在132模式的子序列</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">find132pattern</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//枚举模式3，用一个变量保存每个3左边序列的最小值即模式1，模式1需严格小于模式3</span>
        <span class="c1">//检查模式3的右边是否存在模式2，即存在一个数字小于模式3，但是大于模式1，用一个有序集合存放</span>
        <span class="c1">//TreeMap的ceilingKey可以找到集合中大于等于给定key的数字</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">lmin</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//枚举模式3</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">lmin</span><span class="o">){</span>
                <span class="nc">Integer</span> <span class="n">next</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">ceilingKey</span><span class="o">(</span><span class="n">lmin</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
                
            <span class="o">}</span>
            <span class="n">lmin</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">lmin</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">],</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump459"></span></p><h2 id="459重复的子字符串">459.重复的子字符串</h2><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"abab"</span>
<span class="nl">输出:</span> <span class="nc">True</span>
<span class="nl">解释:</span> <span class="n">可由子字符串</span> <span class="s">"ab"</span> <span class="n">重复两次构成</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"aba"</span>
<span class="nl">输出:</span> <span class="nc">False</span>
</pre></table></code></div></div><p>示例 3:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"abcabcabcabc"</span>
<span class="nl">输出:</span> <span class="nc">True</span>
<span class="nl">解释:</span> <span class="n">可由子字符串</span> <span class="s">"abc"</span> <span class="n">重复四次构成</span><span class="err">。</span> <span class="o">(</span><span class="n">或者子字符串</span> <span class="s">"abcabc"</span> <span class="n">重复两次构成</span><span class="err">。</span><span class="o">)</span>
</pre></table></code></div></div><h3 id="枚举法">枚举法</h3><p>若存在这种形式的字符串，那么必有：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sub</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">*</span> <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span>	<span class="o">(</span><span class="n">k</span><span class="o">!=</span><span class="mi">1</span><span class="o">)</span>
</pre></table></code></div></div><p>循环添加sub k-1次，最终结果若与s相等，则返回true。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">repeatedSubstringPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()/</span><span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">continue</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span>
            <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">subS</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">+=</span><span class="n">subS</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">res</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="o">)))</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="字符串匹配">字符串匹配</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_repeated_substring_pattern.png" alt="leetcode_repeated_substring_pattern" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">repeatedSubstringPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span><span class="o">).</span><span class="na">indexOf</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/</span>
</pre></table></code></div></div><h3 id="kmp算法">KMP算法</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/Users/huangyucai/Documents/code/git_depositorys/github_KolinHuang/HYCBlog/assets/img/leetcode/leetcode_repeated_substring_pattern_KMP_1.png" alt="leetcode_repeated_substring_pattern_KMP_1" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_repeated_substring_pattern_KMP_2.png" alt="leetcode_repeated_substring_pattern_KMP_2" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">repeatedSubstringPattern</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">kmp</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">kmp</span><span class="o">(</span><span class="nc">String</span> <span class="n">query</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">fail</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">fail</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">fail</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">fail</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">fail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">match</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">match</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">fail</span><span class="o">[</span><span class="n">match</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">match</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">match</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">match</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/</span>
</pre></table></code></div></div><p><span id="jump460"></span></p><h2 id="460-lfu-缓存">460. LFU 缓存</h2><p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p><p>实现 LFUCache 类：</p><p>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。 void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最久未使用 的键。 注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
<span class="o">[</span><span class="s">"LFUCache"</span><span class="o">,</span> <span class="s">"put"</span><span class="o">,</span> <span class="s">"put"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"put"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"put"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">,</span> <span class="s">"get"</span><span class="o">]</span>
<span class="o">[[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span>
<span class="o">[</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>

<span class="n">解释</span><span class="err">：</span>
<span class="c1">// cnt(x) = 键 x 的使用计数</span>
<span class="c1">// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span>
<span class="nc">LFUCache</span> <span class="n">lFUCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LFUCache</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>   <span class="c1">// cache=[1,_], cnt(1)=1</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>   <span class="c1">// cache=[2,1], cnt(2)=1, cnt(1)=1</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>      <span class="c1">// 返回 1</span>
                      <span class="c1">// cache=[1,2], cnt(2)=1, cnt(1)=2</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>   <span class="c1">// 去除键 2 ，因为 cnt(2)=1 ，使用计数最小</span>
                      <span class="c1">// cache=[3,1], cnt(3)=1, cnt(1)=2</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>      <span class="c1">// 返回 -1（未找到）</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>      <span class="c1">// 返回 3</span>
                      <span class="c1">// cache=[3,1], cnt(3)=2, cnt(1)=2</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>   <span class="c1">// 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span>
                      <span class="c1">// cache=[4,3], cnt(4)=1, cnt(3)=2</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>      <span class="c1">// 返回 -1（未找到）</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>      <span class="c1">// 返回 3</span>
                      <span class="c1">// cache=[3,4], cnt(4)=1, cnt(3)=3</span>
<span class="n">lFUCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>      <span class="c1">// 返回 4</span>
                      <span class="c1">// cache=[3,4], cnt(4)=2, cnt(3)=3</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= capacity, key, value &lt;= 104</li><li>最多调用 105 次 get 和 put 方法</li></ul><p>进阶：你可以为这两种操作设计时间复杂度为 O(1) 的实现吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">LFUCache</span> <span class="o">{</span>

    <span class="c1">//key为访问次数，value为访问次数都为key的节点组成的链表</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">DLinkList</span><span class="o">&gt;</span> <span class="n">listsMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//key为节点的key，value为节点</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">DLinkNode</span><span class="o">&gt;</span> <span class="n">nodesMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">minFreq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">nodeNum</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">LFUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//先到nodesMap里面查，没有就返回-1</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">nodesMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">//有就取节点，然后移动节点到上一层</span>
        <span class="nc">DLinkNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nodesMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">freq</span><span class="o">;</span>
        <span class="c1">//将这个节点从链表中删除</span>
        <span class="n">listsMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">//删除节点后，链表为空了，就把链表删了</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">listsMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">listsMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">freq</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">minFreq</span> <span class="o">==</span> <span class="n">freq</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//为什么要++呢？因为被删除的这个节点会被放入freq+1的链表中</span>
                <span class="c1">//freq+1链表必不为空，而且就是最底层的链表</span>
                <span class="n">minFreq</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//将这个节点插入到freq+1链表中，头插</span>
        <span class="n">node</span><span class="o">.</span><span class="na">freq</span><span class="o">++;</span>
        <span class="nc">DLinkList</span> <span class="n">dlist</span> <span class="o">=</span> <span class="n">listsMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">DLinkList</span><span class="o">());</span>
        <span class="n">dlist</span><span class="o">.</span><span class="na">addHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="c1">//需要更新</span>
        <span class="n">listsMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">dlist</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">capacity</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span><span class="o">;</span>
        <span class="c1">//没有这个节点</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">nodesMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">//缓存满了就删除一个节点</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nodeNum</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nodeNum</span><span class="o">--;</span>
                <span class="nc">DLinkNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">listsMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">minFreq</span><span class="o">).</span><span class="na">removeTail</span><span class="o">();</span>
                <span class="n">nodesMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">listsMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">minFreq</span><span class="o">).</span><span class="na">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">listsMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">minFreq</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">//执行插入</span>
            <span class="nc">DLinkList</span> <span class="n">list</span> <span class="o">=</span> <span class="n">listsMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">DLinkList</span><span class="o">());</span>
            <span class="n">list</span><span class="o">.</span><span class="na">addHead</span><span class="o">(</span><span class="k">new</span> <span class="nc">DLinkNode</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
            <span class="n">listsMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
            <span class="n">nodesMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">listsMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">peekFirst</span><span class="o">());</span>
            <span class="n">minFreq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">nodeNum</span><span class="o">++;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//有就取节点，然后移动节点到上一层</span>
            <span class="nc">DLinkNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nodesMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">freq</span><span class="o">;</span>
            <span class="c1">//将这个节点从链表中删除</span>
            <span class="n">listsMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="c1">//删除节点后，链表为空了，就把链表删了</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">listsMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">listsMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">freq</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">minFreq</span> <span class="o">==</span> <span class="n">freq</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">//为什么要++呢？因为被删除的这个节点会被放入freq+1的链表中</span>
                    <span class="c1">//freq+1链表必不为空，而且就是最底层的链表</span>
                    <span class="n">minFreq</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">//将这个节点插入到freq+1链表中，头插</span>
            <span class="n">node</span><span class="o">.</span><span class="na">freq</span><span class="o">++;</span>
            <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="nc">DLinkList</span> <span class="n">dlist</span> <span class="o">=</span> <span class="n">listsMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">DLinkList</span><span class="o">());</span>
            <span class="n">dlist</span><span class="o">.</span><span class="na">addHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="c1">//需要更新</span>
            <span class="n">listsMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">dlist</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">class</span> <span class="nc">DLinkList</span><span class="o">{</span>
        <span class="nc">DLinkNode</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">DLinkNode</span> <span class="n">tail</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">DLinkList</span><span class="o">(){</span>
            <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DLinkNode</span><span class="o">();</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//从该链表中删除节点</span>
        <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">){</span>

            <span class="c1">//从哈希表中取节点，然后删除</span>
            <span class="nc">DLinkNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nodesMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tail</span> <span class="o">==</span> <span class="n">node</span><span class="o">){</span>
                <span class="n">removeTail</span><span class="o">();</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="nc">DLinkNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">pre</span><span class="o">;</span>
                <span class="nc">DLinkNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="n">next</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
                <span class="n">size</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">DLinkNode</span> <span class="nf">removeTail</span><span class="o">(){</span>
            <span class="nc">DLinkNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">pre</span><span class="o">;</span>
            <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">size</span><span class="o">--;</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">DLinkNode</span> <span class="nf">peekFirst</span><span class="o">(){</span>
            <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">void</span> <span class="nf">addHead</span><span class="o">(</span><span class="nc">DLinkNode</span> <span class="n">node</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="n">node</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">node</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
                <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">size</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">class</span> <span class="nc">DLinkNode</span><span class="o">{</span>
        <span class="nc">DLinkNode</span> <span class="n">next</span><span class="o">;</span>
        <span class="nc">DLinkNode</span> <span class="n">pre</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">freq</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">DLinkNode</span><span class="o">(){</span>

        <span class="o">}</span>

        <span class="kd">public</span> <span class="nf">DLinkNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">_key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">_val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">_freq</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">_key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">_val</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">freq</span> <span class="o">=</span> <span class="n">_freq</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump463"></span></p><h2 id="463岛屿的周长">463.岛屿的周长</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p>示例 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span>
<span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
 <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
 <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span>
 <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span>

<span class="nl">输出:</span> <span class="mi">16</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">islandPerimeter</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                <span class="c1">//只有一行</span>
                <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="c1">//左边界</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="c1">//只有一列</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>


                <span class="c1">//边界和四个对角特别判断</span>

                <span class="c1">//1.在上边界</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="c1">//在左上角</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="c1">//在右上角</span>
                    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="c1">//上边界的边上，不包含角</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">//2.在下边界</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="c1">//在左下角</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="c1">//在右下角</span>
                    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="c1">//下边界的边上，不包含角</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">//3.在左边界，不包含角</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="c1">//4.在右边界，不包含角</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="c1">//5.其他情况</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>  <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>  <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>
            
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">islandPerimeter</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                        <span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                        <span class="kt">int</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">tx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">grid</span><span class="o">[</span><span class="n">tx</span><span class="o">][</span><span class="n">ty</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">ans</span> <span class="o">+=</span> <span class="n">cnt</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump480"></span></p><h2 id="480-滑动窗口中位数">480. 滑动窗口中位数</h2><p>中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p><p>例如：</p><p>[2,3,4]，中位数是 3 [2,3]，中位数是 (2 + 3) / 2 = 2.5 给你一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">给出</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span><span class="err">，</span><span class="n">以及</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="err">。</span>

<span class="n">窗口位置</span>                      <span class="n">中位数</span>

<span class="o">---------------</span>               <span class="o">-----</span>

<span class="o">[</span><span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">1</span>
 <span class="mi">1</span> <span class="o">[</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span><span class="o">]</span> <span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>      <span class="o">-</span><span class="mi">1</span>
 <span class="mi">1</span>  <span class="mi">3</span> <span class="o">[-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span><span class="o">]</span> <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span>      <span class="o">-</span><span class="mi">1</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span> <span class="o">[-</span><span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">3</span><span class="o">]</span> <span class="mi">6</span>  <span class="mi">7</span>       <span class="mi">3</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span> <span class="o">[</span><span class="mi">5</span>  <span class="mi">3</span>  <span class="mi">6</span><span class="o">]</span> <span class="mi">7</span>       <span class="mi">5</span>
 <span class="mi">1</span>  <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span>  <span class="mi">5</span> <span class="o">[</span><span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">7</span><span class="o">]</span>      <span class="mi">6</span>
 <span class="n">因此</span><span class="err">，</span><span class="n">返回该滑动窗口的中位数数组</span> <span class="o">[</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><p>你可以假设 k 始终有效，即：k 始终小于输入的非空数组的元素个数。 与真实值误差在 10 ^ -5 以内的答案将被视作正确答案。</p><p>用两个优先队列来维护各一半的窗口，较大的数放入最小堆，较小的数放入最大堆，每移动一次窗口，就从堆顶取中位数。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span><span class="o">[]</span> <span class="nf">medianSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[]{};</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="kt">double</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//中位数结果集</span>
        <span class="kt">double</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="c1">//用两个优先队列存储，一个是最大堆、一个是最小堆</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">maxHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="nc">Collections</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">());</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">minHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">){</span><span class="c1">//窗口需要滑动了</span>
                <span class="k">if</span><span class="o">(</span><span class="n">minHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">]){</span>
                    <span class="n">minHeap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">]);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">maxHeap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">//往队列中存元素，优先放入最小堆</span>
            <span class="k">if</span><span class="o">(</span><span class="n">minHeap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">maxHeap</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
                <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">maxHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">minHeap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">maxHeap</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">maxHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">maxHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                    <span class="n">maxHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">maxHeap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//i&gt;=k-1时，就从堆顶取中位数</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">minHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">()/</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">maxHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">()/</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">minHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump486"></span></p><h2 id="486预测赢家">486.预测赢家</h2><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="nc">False</span>
<span class="n">解释</span><span class="err">：</span><span class="n">一开始</span><span class="err">，</span><span class="n">玩家1可以从1和2中进行选择</span><span class="err">。</span>
<span class="n">如果他选择</span> <span class="mi">2</span><span class="err">（</span><span class="n">或者</span> <span class="mi">1</span> <span class="err">），</span><span class="n">那么玩家</span> <span class="mi">2</span> <span class="n">可以从</span> <span class="mi">1</span><span class="err">（</span><span class="n">或者</span> <span class="mi">2</span> <span class="err">）</span><span class="n">和</span> <span class="mi">5</span> <span class="n">中进行选择</span><span class="err">。</span><span class="n">如果玩家</span> <span class="mi">2</span> <span class="n">选择了</span> <span class="mi">5</span> <span class="err">，</span><span class="n">那么玩家</span> <span class="mi">1</span> <span class="n">则只剩下</span> <span class="mi">1</span><span class="err">（</span><span class="n">或者</span> <span class="mi">2</span> <span class="err">）</span><span class="n">可选</span><span class="err">。</span>
<span class="n">所以</span><span class="err">，</span><span class="n">玩家</span> <span class="mi">1</span> <span class="n">的最终分数为</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">3</span><span class="err">，</span><span class="n">而玩家</span> <span class="mi">2</span> <span class="n">为</span> <span class="mi">5</span> <span class="err">。</span>
<span class="n">因此</span><span class="err">，</span><span class="n">玩家</span> <span class="mi">1</span> <span class="n">永远不会成为赢家</span><span class="err">，</span><span class="n">返回</span> <span class="nc">False</span> <span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">233</span><span class="o">,</span> <span class="mi">7</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="nc">True</span>
<span class="n">解释</span><span class="err">：</span><span class="n">玩家</span> <span class="mi">1</span> <span class="n">一开始选择</span> <span class="mi">1</span> <span class="err">。</span><span class="n">然后玩家</span> <span class="mi">2</span> <span class="n">必须从</span> <span class="mi">5</span> <span class="n">和</span> <span class="mi">7</span> <span class="n">中进行选择</span><span class="err">。</span><span class="n">无论玩家</span> <span class="mi">2</span> <span class="n">选择了哪个</span><span class="err">，</span><span class="n">玩家</span> <span class="mi">1</span> <span class="n">都可以选择</span> <span class="mi">233</span> <span class="err">。</span>
<span class="n">最终</span><span class="err">，</span><span class="n">玩家</span> <span class="mi">1</span><span class="err">（</span><span class="mi">234</span> <span class="n">分</span><span class="err">）</span><span class="n">比玩家</span> <span class="mi">2</span><span class="err">（</span><span class="mi">12</span> <span class="n">分</span><span class="err">）</span><span class="n">获得更多的分数</span><span class="err">，</span><span class="n">所以返回</span> <span class="nc">True</span><span class="err">，</span><span class="n">表示玩家</span> <span class="mi">1</span> <span class="n">可以成为赢家</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><h3 id="动态规划-5">动态规划</h3><p>对于偶数个数字的数组，玩家1一定获胜。因为如果玩家1选择拿法A，玩家2选择拿法B，玩家1输了。则玩家1换一种拿法选择拿法B，因为玩家1是先手，所以玩家1一定可以获胜。</p><p>对于奇数个数字的数组，利用动态规划（dynamic programming）计算。 首先证明最优子结构性质。对于数组<code class="language-plaintext highlighter-rouge">[1..n]</code>中的子数组<code class="language-plaintext highlighter-rouge">[i..j]</code>，假设玩家1在子数组<code class="language-plaintext highlighter-rouge">[i..j]</code>中的拿法是最优的，即拿的分数比玩家2多出最多。假设玩家1拿了<code class="language-plaintext highlighter-rouge">i</code>，则<code class="language-plaintext highlighter-rouge">[i+1..j]</code>中玩家1拿的方法也一定是最优的。利用反证法证明：如果玩家1在<code class="language-plaintext highlighter-rouge">[i+1..j]</code>中有更优的拿法，即玩家1在<code class="language-plaintext highlighter-rouge">[i+1...j]</code>可以拿到更多的分数，则玩家在<code class="language-plaintext highlighter-rouge">[i..j]</code>中拿到的分数就会比假设的最优拿法拿到的分数更多，显然矛盾。如果玩家1拿了j，同理可证矛盾。 所以当前问题的最优解包含的子问题的解一定也是子问题的最优解。</p><p>对于只有一个数字的子数组,即<code class="language-plaintext highlighter-rouge">i=j，dp[i][i] = num[i]</code>，因为玩家1先手拿了这一个分数，玩家2就没得拿了，所以是最优拿法。 对于两个数字的子数组,即<code class="language-plaintext highlighter-rouge">j-i=1，dp[i][j]=abs(num[i]-num[j])</code>,玩家1先手拿两个数中大的一个，所以玩家1一定比玩家2多两个数字差的绝对值，为最优拿法。 对于<code class="language-plaintext highlighter-rouge">j-i&gt;1</code>的子数组，如果玩家1先手拿了<code class="language-plaintext highlighter-rouge">i</code>，则玩家1手里有<code class="language-plaintext highlighter-rouge">num[i]</code>分，则玩家2一定会按照<code class="language-plaintext highlighter-rouge">[i+1..j]</code>这个子数组中的最优拿法去拿，于是玩家2此时手里相当于有<code class="language-plaintext highlighter-rouge">dp[i+1][j]</code>分，于是玩家1比玩家2多<code class="language-plaintext highlighter-rouge">num[i]-dp[i+1][j]</code>分。如果玩家1先手拿了<code class="language-plaintext highlighter-rouge">j</code>，则玩家1手里有<code class="language-plaintext highlighter-rouge">num[j]</code>分，则玩家2一定会按照<code class="language-plaintext highlighter-rouge">[i..j-1]</code>这个子数组中的最优拿法去拿，于是玩家2此时手里相当于有<code class="language-plaintext highlighter-rouge">dp[i][j-1]</code>分，于是玩家1比玩家2多<code class="language-plaintext highlighter-rouge">num[j]-dp[i][j-1]</code>分。数组的填充方向是从下往上，从左到右，最后填充的是<code class="language-plaintext highlighter-rouge">dp[1][n]</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">player1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">player2</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">flag</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">PredictTheWinner</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
      	<span class="c1">//先填充对角线</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
     <span class="c1">//从对角线开始迭代，从下往上，因为最小的子结构为i=j，最终的结果是[0,n]，所以dp的结果是dp[0][n-1]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
              	<span class="c1">//记录得分差，若当前玩家选择了i，那么下一个玩家肯定会选择[i+1,j]的最优拿法</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="o">}</span>

    
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump493"></span></p><h2 id="493翻转对">493.翻转对</h2><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p><p>你需要返回给定数组中的重要翻转对的数量。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">2</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">3</span>
</pre></table></code></div></div><p>注意:</p><ul><li>给定数组的长度不会超过50000。</li><li>输入数组中的所有数字都在32位整数的表示范围内。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//归并排序，对于数组nums[l...r]</span>
    <span class="c1">//我们已经分别求出了子数组nums[l...m]与nums[m+1...r]的翻转对数量</span>
    <span class="c1">//并已经将两个子数组分别排好序(归并排序的特点)</span>
    <span class="c1">//则nums[l...r]中的翻转对数量就是两个子数组翻转对数量之和</span>
    <span class="c1">//加上左右端点分别位于两个子数组的翻转对数量</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">reversePairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">reversePair</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">reversePair</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">right</span> <span class="o">+</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">reversePair</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">reversePair</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">;</span>

        <span class="c1">//统计下标对的数量</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">//遍历每一个i</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">){</span>
            <span class="c1">//移动j,直到找到nums[i] &lt;= 2 * nums[j]的位置，那么后续的nums[j]就没必要遍历了</span>
            <span class="k">while</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                <span class="o">++</span><span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//记录符合要求的下标对</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">//合并数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sorted</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">p1</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">){</span>
                <span class="n">sorted</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">p2</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">){</span>
                <span class="n">sorted</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">++];</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">]){</span>
                    <span class="n">sorted</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">++];</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">sorted</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">++];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">sorted</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">sorted</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump494"></span></p><h2 id="494目标和">494.目标和</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="nl">nums:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span> <span class="nl">S:</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：</span>

<span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">一共有5种方法让最终目标和为3</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><p>深搜回溯：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">target</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="no">S</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span>    <span class="n">cnt</span><span class="o">++;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">cur</span><span class="o">]);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">cur</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>动态规划：</p><p>这道题也是一个常见的背包问题，我们可以用类似求解背包问题的方法来求出可能的方法数。</p><p>我们用 <code class="language-plaintext highlighter-rouge">dp[i][j] </code>表示用数组中的前 i 个元素，组成和为 j 的方案数。考虑第 i 个数 <code class="language-plaintext highlighter-rouge">nums[i]</code>，它可以被添加 + 或 -，因此状态转移方程如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span>
</pre></table></code></div></div><p>也可以写成递推的形式：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
</pre></table></code></div></div><p>由于数组中所有数的和不超过 1000，那么 j 的最小值可以达到 -1000。在很多语言中，是不允许数组的下标为负数的，因此我们需要给 dp[i][j] 的第二维预先增加 1000，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2001</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][-</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span><span class="o">;</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">sum</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">];</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">sum</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">S</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="no">S</span> <span class="o">+</span> <span class="mi">1000</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="cm">/*
        设nums总和为sum，加负号的数字总和为neg，则加正数的总和为sum - neg
        有 S = sum - neg - neg = sum - 2*neg
        neg = (sum - S) / 2
        所以问题就转化为找到一个组合，使得加负号的数字总和为neg，即可满足条件
        同时sum - S要大于等于0，且为偶数
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">-</span> <span class="no">S</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">diff</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">//设dp[i][j]表示，前i个数字中，加负号的数字总和为j的组合个数</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">neg</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">neg</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="c1">//如果j &gt;= nums[i-1]说明当前数字可加负号</span>
                <span class="c1">//和[0, j-nums[i-1]]的区间数字总和为S</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">neg</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump501"></span></p><h2 id="501二叉搜索树中的众数">501.二叉搜索树中的众数</h2><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><ul><li>结点左子树中所含结点的值小于等于当前结点的值</li><li>结点右子树中所含结点的值大于等于当前结点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>例如：</p><p>给定 BST [1,null,2,2],</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>   <span class="mi">1</span>
    <span class="err">\</span>
     <span class="mi">2</span>
    <span class="o">/</span>
   <span class="mi">2</span>
</pre></table></code></div></div><p>返回[2].</p><p>提示：如果众数超过1个，不需考虑输出顺序</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p>二叉搜索树的中序遍历是非严格升序，所以先用中序遍历一遍，拿到升序数组，再用哈希表找到数组中的众数。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">max_times</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findMode</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="mi">0</span><span class="o">);</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">list</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">max_times</span><span class="o">){</span>
                <span class="n">max_times</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
                <span class="n">list</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">max_times</span><span class="o">){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">inOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>

            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></table></code></div></div><p>进阶：直接在中序遍历过程中统计众数，为了不使用额外空间，遍历树两次，第一次记录结果集的长度，第二次记录结果集。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">max_times</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>	<span class="c1">//众数的出现次数</span>
    <span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>	<span class="c1">//当前数字的出现次数</span>
    <span class="kt">int</span> <span class="n">res_length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>	<span class="c1">//结果集的长度</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span><span class="o">;</span>	<span class="c1">//结果集，第一次遍历时设空</span>
    <span class="nc">TreeNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>	<span class="c1">//上一个节点</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findMode</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">res_length</span><span class="o">];</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">res_length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">inOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

            <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
                <span class="n">times</span><span class="o">++;</span>
            <span class="k">else</span>
                <span class="n">times</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            
            <span class="k">if</span><span class="o">(</span><span class="n">times</span> <span class="o">&gt;</span> <span class="n">max_times</span><span class="o">){</span>
                <span class="n">max_times</span> <span class="o">=</span> <span class="n">times</span><span class="o">;</span>
                <span class="n">res_length</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">//max_times在第一次遍历中会记录最大的次数，在第二次遍历中用于判断哪些数字是众数</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">times</span> <span class="o">==</span> <span class="n">max_times</span><span class="o">){</span>
              	<span class="c1">//当前是第二次遍历的话，就记录结果集</span>
                <span class="k">if</span><span class="o">(</span><span class="n">res</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">res</span><span class="o">[</span><span class="n">res_length</span><span class="o">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">res_length</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump503"></span></p><h2 id="503-下一个更大元素-ii">503. 下一个更大元素 II</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="n">第一个</span> <span class="mi">1</span> <span class="n">的下一个更大的数是</span> <span class="mi">2</span><span class="err">；</span>
<span class="n">数字</span> <span class="mi">2</span> <span class="n">找不到下一个更大的数</span><span class="err">；</span> 
<span class="n">第二个</span> <span class="mi">1</span> <span class="n">的下一个最大的数需要循环搜索</span><span class="err">，</span><span class="n">结果也是</span> <span class="mi">2</span><span class="err">。</span>
</pre></table></code></div></div><p>注意: 输入数组的长度不会超过 10000。</p><p>单调递减栈，当当前元素比栈顶元素大时，把栈顶元素弹出，记录该栈顶的下一个更大元素为当前元素。</p><p>需要在栈中存放索引，以便回填。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">nextGreaterElements</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="c1">//用单调栈，递减的</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//遍历两遍，因为是循环数组</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">%</span><span class="n">n</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="n">res</span><span class="o">[</span><span class="n">tmp</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">%</span><span class="n">n</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="n">n</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump509"></span></p><h2 id="509-斐波那契数">509. 斐波那契数</h2><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你 n ，请计算 F(n) 。</p><p>提示：</p><ul><li>0 &lt;= n &lt;= 30</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210104090303916.png" alt="image-20210104090303916" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">sqrt5</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="kt">double</span> <span class="n">fibN</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sqrt5</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">-</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sqrt5</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">fibN</span> <span class="o">/</span> <span class="n">sqrt5</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump514"></span></p><h2 id="514自由之路">514.自由之路</h2><p>视频游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。</p><p>给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。</p><p>最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。</p><p>旋转 ring 拼出 key 字符 key[i] 的阶段中：</p><ul><li>您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。</li><li>如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">ring</span> <span class="o">=</span> <span class="s">"godding"</span><span class="o">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"gd"</span>
<span class="nl">输出:</span> <span class="mi">4</span>
<span class="nl">解释:</span>
 <span class="n">对于</span> <span class="n">key</span> <span class="n">的第一个字符</span> <span class="sc">'g'</span><span class="err">，</span><span class="n">已经在正确的位置</span><span class="o">,</span> <span class="n">我们只需要1步来拼写这个字符</span><span class="err">。</span> 
 <span class="n">对于</span> <span class="n">key</span> <span class="n">的第二个字符</span> <span class="sc">'d'</span><span class="err">，</span><span class="n">我们需要逆时针旋转</span> <span class="n">ring</span> <span class="s">"godding"</span> <span class="mi">2</span><span class="n">步使它变成</span> <span class="s">"ddinggo"</span><span class="err">。</span>
 <span class="n">当然</span><span class="o">,</span> <span class="n">我们还需要1步进行拼写</span><span class="err">。</span>
 <span class="n">因此最终的输出是</span> <span class="mi">4</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>ring 和 key 的字符串长度取值范围均为 1 至 100；</li><li>两个字符串中都只有小写字符，并且均可能存在重复字符；</li><li>字符串 key 一定可以由字符串 ring 旋转拼出。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//用dp[i][j]表示从游戏开始到拼接完成key[0:i]在ring[j] == key[i]时的最小步数</span>
    <span class="c1">//因为存在重复字符串，所以我们把所有重复的位置都考虑到。</span>
    <span class="c1">//无论顺时针还是逆时针，同一个字符出现的所有位置都有可能是最小的步数</span>
    <span class="c1">//所以干脆将每个字符出现的位置放入一个哈希表中，用列表维护某个字符的所有出现位置</span>
    <span class="c1">//状态转移：枚举上一次与12:00方向对齐的位置k，</span>
    <span class="c1">//计算顺时针从k转到j和逆时针从k转到j的最小步数，即：min{abs(j - k), n - abs(j - k)} + 1</span>
    <span class="c1">//加上之前走的步数dp[i-1][k]</span>
    <span class="c1">//再将上面的值跟dp[i][j]比较，取最小值:</span>
    <span class="c1">//dp[i][j] = min{dp[i][j], dp[i-1][k] + min{abs(j - k), n - abs(j - k)} + 1}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findRotateSteps</span><span class="o">(</span><span class="nc">String</span> <span class="n">ring</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">m</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="mh">0x3f3f3f</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//维护一个map，存放每个字符在ring中出现的位置集合</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ring</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ring</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">list</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//边界初始化：即使第一个字符就对应好了，也不一定是最优解，因为很有可能其他位置的才是更优的</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))){</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))){</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">k</span><span class="o">),</span> <span class="n">n</span> <span class="o">-</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">k</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        
    <span class="o">}</span>

    
<span class="o">}</span>
</pre></table></code></div></div><h2 id="518-零钱兑换-ii">518. 零钱兑换 II</h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>这是一个背包问题，但是要计算组合数。</p><p>根据背包问题的思路，我们是需要判断每个硬币是否需要被放入背包的。</p><ul><li>如果放入后不超过容量，那就可以放入</li><li>如果放入后超过了容量，那就不允许放入</li></ul><p>动态规划，设dp[i]表示coin数组能凑出总金额i的组合数。</p><p>状态转移：</p><ul><li>对于每个coin，都可以选择放入或者不放入</li><li>如果存在总金额i - coin的组合，那么把当前coin放入背包后，组合数应当为dp[i-coin]</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">change</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//dp[i]表示用coin能够组成总金额i的最大组合数</span>
        <span class="cm">/**
        状态转移：
        dp[i] = dp[i - coin]
         */</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">coin</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
    <span class="o">}</span>
    
<span class="o">}</span>
</pre></table></code></div></div><h2 id="525-连续数组">525. 连续数组</h2><p>给定一个二进制数组 <code class="language-plaintext highlighter-rouge">nums</code> , 找到含有相同数量的 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 的最长连续子数组，并返回该子数组的长度。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMaxLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//连续子数组，0和1的个数要一样</span>
        <span class="c1">//前缀和，1的数量必须是子数组长度的一半</span>
        <span class="c1">//那就意味着这个子数组的和等于子数组长度的一半</span>
        <span class="c1">//如果我们把0视作-1，那么本题就转化为和为0的最长子数组了</span>
        <span class="c1">//动态维护前缀和，到哈希表里找，找前缀和的位置</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//map维护某个前缀和出现的第一个位置</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">pre</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">pre</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pre</span><span class="o">)){</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pre</span><span class="o">));</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump529"></span></p><h2 id="529-扫雷游戏">529. 扫雷游戏</h2><p>让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。</p><p>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。</li><li>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。</li><li>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量</li><li>如果在此次点击中，若无更多方块可被揭露，则返回面板。</li></ol><p>示例 1：</p><p>输入:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="o">[[</span><span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'M'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">]]</span>

<span class="nc">Click</span> <span class="o">:</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="nl">输出:</span> 

<span class="o">[[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'M'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">]]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 

<span class="o">[[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'M'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">]]</span>

<span class="nc">Click</span> <span class="o">:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>

<span class="nl">输出:</span> 

<span class="o">[[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'X'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">],</span>
 <span class="o">[</span><span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">]]</span>
</pre></table></code></div></div><p>注意：</p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><h3 id="深度优先-2">深度优先</h3><p>八个方向都是相邻节点。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">;</span>
    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">char</span><span class="o">[][]</span> <span class="nf">updateBoard</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">click</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">click</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">click</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">){</span>
            <span class="n">board</span><span class="o">[</span><span class="n">click</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">click</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">board</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">board</span> <span class="o">=</span> <span class="n">board</span><span class="o">;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">click</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">click</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="k">return</span> <span class="n">board</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">])</span>   <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">cnt</span><span class="o">+</span><span class="mi">48</span><span class="o">);</span>
            <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'B'</span><span class="o">;</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>    <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">)</span>   <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>    <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span>     <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>   <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>   <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span>   <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span>   <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>   <span class="n">res</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>   <span class="n">res</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>   <span class="n">res</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>   <span class="n">res</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>   <span class="n">res</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>   <span class="n">res</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>   <span class="n">res</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span>   <span class="n">res</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="广度优先-2">广度优先</h3><p>同样地，我们也可以将深度优先搜索改为广度优先搜索来模拟，我们只要在\textit{cnt}cnt 为零的时候，将当前点相邻的未挖出的方块加入广度优先搜索的队列里即可，其他情况不加入队列，这里不再赘述。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dirX</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dirY</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kt">char</span><span class="o">[][]</span> <span class="nf">updateBoard</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">click</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">click</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">click</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 规则 1</span>
            <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span><span class="o">{</span>
            <span class="n">bfs</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">board</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sx</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sy</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;();</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">sx</span><span class="o">,</span> <span class="n">sy</span><span class="o">});</span>
        <span class="n">vis</span><span class="o">[</span><span class="n">sx</span><span class="o">][</span><span class="n">sy</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dirX</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dirY</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">tx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// 不用判断 M，因为如果有 M 的话游戏已经结束了</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">tx</span><span class="o">][</span><span class="n">ty</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'M'</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">++</span><span class="n">cnt</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 规则 3</span>
                <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="sc">'0'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 规则 2</span>
                <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'B'</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dirX</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dirY</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="c1">// 这里不需要在存在 B 的时候继续扩展，因为 B 之前被点击的时候已经被扩展过了</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">tx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">||</span> <span class="n">board</span><span class="o">[</span><span class="n">tx</span><span class="o">][</span><span class="n">ty</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'E'</span> <span class="o">||</span> <span class="n">vis</span><span class="o">[</span><span class="n">tx</span><span class="o">][</span><span class="n">ty</span><span class="o">])</span> <span class="o">{</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">tx</span><span class="o">,</span> <span class="n">ty</span><span class="o">});</span>
                    <span class="n">vis</span><span class="o">[</span><span class="n">tx</span><span class="o">][</span><span class="n">ty</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/minesweeper/solution/sao-lei-you-xi-by-leetcode-solution/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump530"></span></p><h2 id="530二叉搜索树的最小绝对差">530.二叉搜索树的最小绝对差</h2><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>

   <span class="mi">1</span>
    <span class="err">\</span>
     <span class="mi">3</span>
    <span class="o">/</span>
   <span class="mi">2</span>

<span class="n">输出</span><span class="err">：</span>
<span class="mi">1</span>

<span class="n">解释</span><span class="err">：</span>
<span class="n">最小绝对差为</span> <span class="mi">1</span><span class="err">，</span><span class="n">其中</span> <span class="mi">2</span> <span class="n">和</span> <span class="mi">1</span> <span class="n">的差的绝对值为</span> <span class="mi">1</span><span class="err">（</span><span class="n">或者</span> <span class="mi">2</span> <span class="n">和</span> <span class="mi">3</span><span class="err">）。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>树中至少有 2 个节点。</li></ul><p>中序遍历：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">TreeNode</span> <span class="n">pre</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getMinimumDifference</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">min</span><span class="o">;</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">min</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">inOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="n">pre</span><span class="o">.</span><span class="na">val</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump538"></span></p><h2 id="538把二叉搜索树转换为累加树">538.把二叉搜索树转换为累加树</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="nl">原始二叉搜索树:</span>
              <span class="mi">5</span>
            <span class="o">/</span>   <span class="err">\</span>
           <span class="mi">2</span>     <span class="mi">13</span>

<span class="nl">输出:</span> <span class="nl">转换为累加树:</span>
             <span class="mi">18</span>
            <span class="o">/</span>   <span class="err">\</span>
          <span class="mi">20</span>     <span class="mi">13</span>
</pre></table></code></div></div><p>递归反中序遍历，可以得到二叉搜索树的降序排序节点。将较大值加到前一个较小值即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">convertBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
      	<span class="c1">//将节点值累加到较小节点</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">).</span><span class="na">val</span> <span class="o">+=</span> <span class="n">nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
		<span class="c1">//逆中序遍历，将节点添加到list中</span>
    <span class="kt">void</span> <span class="nf">inOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>或：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">convertBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">convertBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
            <span class="n">convertBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>   
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>    
<span class="o">}</span>
</pre></table></code></div></div><h2 id="541-反转字符串-ii">541. 反转字符串 II</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abcdefg"</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"bacdfeg"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 10^4</li><li>s 仅由小写英文组成</li><li>1 &lt;= k &lt;= 10^4</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//每2k个字符，反转前k个</span>
        <span class="c1">//那就是先读前k个字符，进行反转，然后再掠过后k个字符</span>
        <span class="kt">char</span><span class="o">[]</span>  <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="n">reverse</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="o">+</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
            <span class="n">l</span><span class="o">++;</span>
            <span class="n">r</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump543"></span></p><h2 id="543二叉树的直径">543.二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 : 给定二叉树</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>      1
     / \
    2   3
   / \     
  4   5    
</pre></table></code></div></div><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">//实际上是要找出左右子树深度和最大的结点</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">diameterOfBinaryTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">getDepth</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">getDepth</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">getDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">getDepth</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

        <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>

        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">,</span><span class="n">right</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump546"></span></p><h2 id="546移除盒子">546.移除盒子</h2><p>给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。 当你将所有盒子都去掉之后，求你能获得的最大积分和。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">boxes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">23</span>
<span class="n">解释</span><span class="err">：</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> 
<span class="o">----&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">=</span><span class="mi">9</span> <span class="n">分</span><span class="o">)</span> 
<span class="o">----&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">(</span><span class="mi">1</span><span class="o">*</span><span class="mi">1</span><span class="o">=</span><span class="mi">1</span> <span class="n">分</span><span class="o">)</span> 
<span class="o">----&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">=</span><span class="mi">9</span> <span class="n">分</span><span class="o">)</span> 
<span class="o">----&gt;</span> <span class="o">[]</span> <span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">=</span><span class="mi">4</span> <span class="n">分</span><span class="o">)</span>
</pre></table></code></div></div><p>提示：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">boxes</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">100</span>
<span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">boxes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="mi">100</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_移除盒子_1.png" alt="leetcode_移除盒子_2" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_移除盒子_1.png" alt="leetcode_移除盒子_1" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeBoxes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">boxes</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">][</span><span class="mi">100</span><span class="o">][</span><span class="mi">100</span><span class="o">];</span>
        <span class="k">return</span> <span class="nf">calculatePoints</span><span class="o">(</span><span class="n">boxes</span><span class="o">,</span> <span class="n">dp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">boxes</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">calculatePoints</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">boxes</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][][]</span> <span class="n">dp</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">][</span><span class="n">r</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">][</span><span class="n">r</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">boxes</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">==</span> <span class="n">boxes</span><span class="o">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">r</span><span class="o">--;</span>
            <span class="n">k</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">][</span><span class="n">r</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">calculatePoints</span><span class="o">(</span><span class="n">boxes</span><span class="o">,</span> <span class="n">dp</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">boxes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">boxes</span><span class="o">[</span><span class="n">r</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">][</span><span class="n">r</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">][</span><span class="n">r</span><span class="o">][</span><span class="n">k</span><span class="o">],</span> <span class="n">calculatePoints</span><span class="o">(</span><span class="n">boxes</span><span class="o">,</span> <span class="n">dp</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">calculatePoints</span><span class="o">(</span><span class="n">boxes</span><span class="o">,</span> <span class="n">dp</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">l</span><span class="o">][</span><span class="n">r</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/remove-boxes/solution/yi-chu-he-zi-by-leetcode-solution/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump547"></span></p><h2 id="547-省份数量">547. 省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中<code class="language-plaintext highlighter-rouge"> isConnected[i][j] = 1</code> 表示第 i 个城市和第 j 个城市直接相连，而 <code class="language-plaintext highlighter-rouge">isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">isConnected</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">isConnected</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= n &lt;= 200</li><li>n == isConnected.length</li><li>n == isConnected[i].length</li><li><code class="language-plaintext highlighter-rouge">isConnected[i][j]</code> 为 1 或 0</li><li><code class="language-plaintext highlighter-rouge">isConnected[i][i] == 1</code></li><li><code class="language-plaintext highlighter-rouge">isConnected[i][j] == isConnected[j][i]</code></li></ul><p>深度优先搜索着色</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findCircleNum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">isConnected</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">isConnected</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//统计需要着色几次才能全都着上色</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">isConnected</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                <span class="n">cnt</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//着色，将这一轮dfs访问的城市都着色</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">isConnected</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">isConnected</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isConnected</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">isConnected</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>并查集</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//并查集</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findCircleNum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">isConnected</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">isConnected</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isConnected</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="c1">//i和j之间有连接，就将其合并</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//合并的过程，就是找出各自的祖先，然后将其合并</span>
    <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">=</span> <span class="n">py</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//在找祖先的时候，执行路径压缩</span>
    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump557"></span></p><h2 id="557反转字符串中的单词-iii">557.反转字符串中的单词 III</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"Let's take LeetCode contest"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"s'teL ekat edoCteeL tsetnoc"</span>
</pre></table></code></div></div><p>提示:</p><p>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseWords</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>    <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="nc">StringBuffer</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span> 
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">reverseString</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
            <span class="k">else</span>
                <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">reverseString</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>

    <span class="o">}</span>

    <span class="nc">String</span> <span class="nf">reverseString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>  <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>发现字符串直接相加的效率比StringBuffer的append慢多了，以后尽量不用字符串直接相加。</p><p><span id="jump560"></span></p><h2 id="560和为k的子数组">560.和为K的子数组</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="mi">2</span> <span class="o">,</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">与</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">为两种不同的情况</span><span class="err">。</span>
</pre></table></code></div></div><p>说明 :</p><ul><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li></ul><p>暴力遍历子数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">subarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
                    <span class="n">cnt</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>记录前缀和，统计<code class="language-plaintext highlighter-rouge">pre[j] = pre[i] - k</code>的个数。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">subarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//pre[i]表示从[0,i]的元素之和，那么我们只需要找到所有符合条件的下标j</span>
        <span class="c1">//使得pre[j] == pre[i] - k即可，这样的j可能有多个，所以我们把所有元素的前缀和pre[i]都放入一个哈希表中</span>
        <span class="c1">//再从左往右遍历数组，统计pre[j]出现的次数</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">pre</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="o">)){</span>
               <span class="n">cnt</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="o">);</span> 
            <span class="o">}</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump561"></span></p><h2 id="561-数组拆分-i">561. 数组拆分 I</h2><p>给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。</p><p>返回该 最大总和 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">所有可能的分法</span><span class="err">（</span><span class="n">忽略元素顺序</span><span class="err">）</span><span class="n">为</span><span class="err">：</span>

<span class="mi">1</span><span class="o">.</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">min</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="o">+</span> <span class="n">min</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">2</span><span class="o">.</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">min</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="n">min</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">3</span><span class="o">.</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">min</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">min</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">4</span>
   <span class="n">所以最大总和为</span> <span class="mi">4</span>
</pre></table></code></div></div><p>提示：</p><p>1 &lt;= n &lt;= 104 nums.length == 2 * n -104 &lt;= nums[i] &lt;= 104</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">arrayPairSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump566"></span></p><h2 id="566-重塑矩阵">566. 重塑矩阵</h2><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p><p>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</p><p>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</p><p>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
<span class="n">nums</span> <span class="o">=</span> 
<span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span>
 <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]]</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nl">输出:</span> 
<span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]]</span>
<span class="nl">解释:</span>
<span class="n">行遍历nums的结果是</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span><span class="err">。</span><span class="n">新的矩阵是</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">4</span> <span class="n">矩阵</span><span class="o">,</span> <span class="n">用之前的元素值一行一行填充新矩阵</span><span class="err">。</span>
</pre></table></code></div></div><p>注意：</p><ul><li>给定矩阵的宽和高范围在 [1, 100]。</li><li>给定的 r 和 c 都是正数。</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/Users/huangyucai/Library/Application Support/typora-user-images/image-20210217081332951.png" alt="image-20210217081332951" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">matrixReshape</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sr</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">!=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">c</span><span class="o">)</span>    <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">cur_r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cur_c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sr</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">sc</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur_r</span><span class="o">][</span><span class="n">cur_c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur_c</span> <span class="o">==</span> <span class="n">c</span><span class="o">){</span>
                    <span class="n">cur_r</span><span class="o">++;</span>
                    <span class="n">cur_c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">matrixReshape</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">x</span> <span class="o">/</span> <span class="n">c</span><span class="o">][</span><span class="n">x</span> <span class="o">%</span> <span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">x</span> <span class="o">/</span> <span class="n">n</span><span class="o">][</span><span class="n">x</span> <span class="o">%</span> <span class="n">n</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump567"></span></p><h2 id="567-字符串的排列">567. 字符串的排列</h2><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"ab"</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"eidbaooo"</span>
<span class="nl">输出:</span> <span class="nc">True</span>
<span class="nl">解释:</span> <span class="n">s2</span> <span class="n">包含</span> <span class="n">s1</span> <span class="n">的排列之一</span> <span class="o">(</span><span class="s">"ba"</span><span class="o">).</span>
</pre></table></code></div></div><p>注意：</p><ul><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkInclusion</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n1</span> <span class="o">&gt;</span> <span class="n">n2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//将s1放入哈希表中</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">table</span><span class="o">[</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="c1">//以窗口n1滑动</span>
        
        <span class="c1">//初始化窗口</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">table</span><span class="o">,</span> <span class="n">count</span><span class="o">)){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">n1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]--;</span>
            <span class="n">count</span><span class="o">[</span><span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">table</span><span class="o">,</span> <span class="n">count</span><span class="o">)){</span>
               <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>   
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump581"></span></p><h2 id="581最短无序连续子数组">581.最短无序连续子数组</h2><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">15</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">5</span>
<span class="nl">解释:</span> <span class="n">你只需要对</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">]</span> <span class="n">进行升序排序</span><span class="err">，</span><span class="n">那么整个表都会变为升序排序</span><span class="err">。</span>
</pre></table></code></div></div><p>说明 :</p><ul><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findUnsortedSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//对子数组排序， 整个数组都会有序</span>
        <span class="c1">//从左往右遍历，找到第一个失序的数字，即nums[i] &gt; nums[i+1]</span>
        <span class="c1">//从右往左遍历，找到第一个失序的数字，即nums[i] &lt; nums[i-1]</span>
        <span class="c1">//以这个区间作为当前的最小数组，只要区间左边的数字都比区间数字小，区间右边的数字都比区间大</span>
        <span class="c1">//那么就符合要求</span>
        <span class="c1">//那么就要找出区间的最大值和最小值</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//说明存在失序数组，从[l,r]里找到最小值和最大值</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">100001</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100001</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">//找到了最大最小值，往左右扩张</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">min</span><span class="o">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump605"></span></p><h2 id="605-种花问题">605. 种花问题</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">flowerbed</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nl">输出:</span> <span class="nc">True</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">flowerbed</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="nc">False</span>
</pre></table></code></div></div><p>注意:</p><ul><li>数组内已种好的花不会违反种植规则。</li><li>输入的数组长度范围为 [1, 20000]。</li><li>n 是非负整数，且不会超过输入数组的大小。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPlaceFlowers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">flowerbed</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">flowerbed</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">flowerbed</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">flowerbed</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">flowerbed</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>   <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span><span class="o">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span> <span class="n">flowerbed</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> 
            <span class="o">||</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">flowerbed</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span>  <span class="o">&amp;&amp;</span> <span class="n">flowerbed</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">||</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">flowerbed</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">flowerbed</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flowerbed</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)){</span>
                <span class="n">flowerbed</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">n</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPlaceFlowers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">flowerbed</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//在两个已经种了花的位置[i,j]之间，可以种花的数量为(j - i - 3 + 1) / 2</span>
        <span class="c1">//双指针找这样的区间，计算可种花的数量</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">flowerbed</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">flowerbed</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">prev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">prev</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">//全空</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="o">(</span><span class="n">flowerbed</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="c1">//到了最后一个位置都没有花，就假设位置flowerbed.length + 1 处有花</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="o">(</span><span class="n">flowerbed</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">prev</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="611-有效三角形的个数">611. 有效三角形的个数</h2><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p><p>示例1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">3</span>
<span class="nl">解释:</span>
<span class="nl">有效的组合是:</span> 
<span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span> <span class="o">(</span><span class="n">使用第一个</span> <span class="mi">2</span><span class="o">)</span>
<span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span> <span class="o">(</span><span class="n">使用第二个</span> <span class="mi">2</span><span class="o">)</span>
<span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span>
</pre></table></code></div></div><p><strong>注意:</strong></p><ol><li>数组长度不超过1000。</li><li>数组里整数的范围为 [0, 1000]。</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">triangleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//两边之和大于第三边即可</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">a</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">b</span><span class="o">){</span>
                <span class="c1">//确定下nums[a]和nums[b]后，二分查找大于nums[a]+nums[b]的第一个位置</span>
                <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]);</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">b</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
        <span class="c1">//二分查找第一个大于target的数字</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump617"></span></p><h2 id="617合并二叉树">617.合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
				<span class="nc">Tree</span> <span class="mi">1</span>                     <span class="nc">Tree</span> <span class="mi">2</span>                  
          <span class="mi">1</span>                         <span class="mi">2</span>                             
         <span class="o">/</span> <span class="err">\</span>                       <span class="o">/</span> <span class="err">\</span>                            
        <span class="mi">3</span>   <span class="mi">2</span>                     <span class="mi">1</span>   <span class="mi">3</span>                        
       <span class="o">/</span>                           <span class="err">\</span>   <span class="err">\</span>                      
      <span class="mi">5</span>                             <span class="mi">4</span>   <span class="mi">7</span>                  
<span class="nl">输出:</span> 
<span class="nl">合并后的树:</span>
	     <span class="mi">3</span>
	    <span class="o">/</span> <span class="err">\</span>
	   <span class="mi">4</span>   <span class="mi">5</span>
	  <span class="o">/</span> <span class="err">\</span>   <span class="err">\</span> 
	 <span class="mi">5</span>   <span class="mi">4</span>   <span class="mi">7</span>
</pre></table></code></div></div><p>注意: 合并必须从两个树的根节点开始。</p><p>以Tree 2为参照，同时遍历两颗树：</p><ul><li>如果Tree2的左子节点不为空，就在Tree1的左子节点上合并这个节点，如果此时Tree1的左子节点为空，就新建一个值为0的节点，再合并。</li><li>如果Tree2的右子节点不为空，就在Tree1的右子节点上合并这个节点，如果此时Tree1的右子节点为空，就新建一个值为0的节点，再合并。</li><li>Tree2子树为空的情况无需处理</li></ul><p>最终返回Tree1，即为答案。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">mergeTrees</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="n">t2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="n">t1</span><span class="o">;</span>
        <span class="n">merge</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">t1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">t2</span><span class="o">){</span>
        <span class="c1">//传进来的节点肯定不为空</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">val</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">t1</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//合并左子树</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">t2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">t1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//合并右子树</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">t2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>或：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">mergeTrees</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="n">t2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="k">return</span> <span class="n">t1</span><span class="o">;</span>

        <span class="nc">TreeNode</span> <span class="n">merge</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">t2</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">merge</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">t2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">merge</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">t2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">merge</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump621"></span></p><h2 id="621任务调度器">621.任务调度器</h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的最短时间。</p><p>示例 ：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">tasks</span> <span class="o">=</span> <span class="o">[</span><span class="s">"A"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span><span class="s">"B"</span><span class="o">],</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">8</span>
<span class="n">解释</span><span class="err">：</span><span class="no">A</span> <span class="o">-&gt;</span> <span class="no">B</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">待命</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">A</span> <span class="o">-&gt;</span> <span class="no">B</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">待命</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">A</span> <span class="o">-&gt;</span> <span class="no">B</span><span class="o">.</span>
     <span class="n">在本示例中</span><span class="err">，</span><span class="n">两个相同类型任务之间必须间隔长度为</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">的冷却时间</span><span class="err">，</span><span class="n">而执行一个任务只需要一个单位时间</span><span class="err">，</span><span class="n">所以中间出现了</span><span class="err">（</span><span class="n">待命</span><span class="err">）</span><span class="n">状态</span><span class="err">。</span> 
</pre></table></code></div></div><p>提示：</p><ul><li>任务的总个数为 [1, 10000]。</li><li>n 的取值范围为 [0, 100]。</li></ul><p>每次从任务列表中选取剩余次数最多的n+1个任务执行，如果剩余任务没有超过n+1个，则选取剩余所有任务执行，多余的时间待命。</p><p>只要每次选取剩余次数最多的n+1个任务，那么下一轮选取的时候，每个任务都是处于可选择状态。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leastInterval</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">tasks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
				<span class="c1">//记录所有任务的次数</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">65</span><span class="o">;</span>
            <span class="n">counts</span><span class="o">[</span><span class="n">index</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">counts</span><span class="o">);</span>

        <span class="k">while</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="mi">25</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
          	<span class="c1">//选取剩余次数最多的n+1个任务</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
              	<span class="c1">//剩余次数最多的任务，次数都为0了，那么就执行完毕了</span>
                <span class="k">if</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="mi">25</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span> <span class="mi">25</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">counts</span><span class="o">[</span><span class="mi">25</span> <span class="o">-</span> <span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="n">counts</span><span class="o">[</span><span class="mi">25</span><span class="o">-</span><span class="n">i</span><span class="o">]--;</span>
                <span class="n">res</span><span class="o">++;</span>
            <span class="o">}</span>
          	<span class="c1">//选取完后，需要重新排序</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">counts</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>最小堆解法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leastInterval</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">tasks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">65</span><span class="o">;</span>
            <span class="n">counts</span><span class="o">[</span><span class="n">index</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="mi">26</span><span class="o">,</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">());</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">counts</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>


        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="c1">//为了避免重复选取任务，每次取出一个任务时，先放入list中，最后再统一插入到最小堆</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
                        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="k">else</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">e</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump637"></span></p><h2 id="637二叉树的层平均值">637.二叉树的层平均值</h2><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
    <span class="mi">3</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">9</span>  <span class="mi">20</span>
    <span class="o">/</span>  <span class="err">\</span>
   <span class="mi">15</span>   <span class="mi">7</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mf">14.5</span><span class="o">,</span> <span class="mi">11</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">第</span> <span class="mi">0</span> <span class="n">层的平均值是</span> <span class="mi">3</span> <span class="o">,</span>  <span class="n">第1层是</span> <span class="mf">14.5</span> <span class="o">,</span> <span class="n">第2层是</span> <span class="mi">11</span> <span class="err">。</span><span class="n">因此返回</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mf">14.5</span><span class="o">,</span> <span class="mi">11</span><span class="o">]</span> <span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>节点值的范围在32位有符号整数范围内。</li></ul><p>层序遍历</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="nf">averageOfLevels</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sum</span><span class="o">/</span><span class="n">size</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump643"></span></p><h2 id="643-子数组最大平均数-i">643. 子数组最大平均数 I</h2><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">12</span><span class="o">,-</span><span class="mi">5</span><span class="o">,-</span><span class="mi">6</span><span class="o">,</span><span class="mi">50</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">输出</span><span class="err">：</span><span class="mf">12.75</span>
<span class="n">解释</span><span class="err">：</span><span class="n">最大平均数</span> <span class="o">(</span><span class="mi">12</span><span class="o">-</span><span class="mi">5</span><span class="o">-</span><span class="mi">6</span><span class="o">+</span><span class="mi">50</span><span class="o">)/</span><span class="mi">4</span> <span class="o">=</span> <span class="mi">51</span><span class="o">/</span><span class="mi">4</span> <span class="o">=</span> <span class="mf">12.75</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= k &lt;= n &lt;= 30,000。</li><li>所给数据范围 [-10,000，10,000]。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">findMaxAverage</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">]);</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxSum</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump647"></span></p><h2 id="647-回文子串">647. 回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"abc"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="nl">三个回文子串:</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"aaa"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="mi">6</span><span class="nl">个回文子串:</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"aa"</span><span class="o">,</span> <span class="s">"aa"</span><span class="o">,</span> <span class="s">"aaa"</span>
</pre></table></code></div></div><p>提示：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">输入的字符串长度不会超过</span> <span class="mi">1000</span> <span class="err">。</span>
</pre></table></code></div></div><h3 id="暴力法-1">暴力法</h3><p>遍历所有子串</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">isPlindromeString</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">isPlindromeString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">++</span><span class="n">l</span><span class="o">;</span>
            <span class="o">--</span><span class="n">r</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>剪枝</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      	<span class="c1">//------------剪枝------------------</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">){</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="k">return</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()*(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))/</span><span class="mi">2</span><span class="o">;</span>
      	<span class="c1">//------------剪枝------------------</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">isPlindromeString</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">isPlindromeString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">++</span><span class="n">l</span><span class="o">;</span>
            <span class="o">--</span><span class="n">r</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="回文中心法">回文中心法</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_回文子串.png" alt="leetcode_回文子串" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">))</span> <span class="o">{</span>
                <span class="o">--</span><span class="n">l</span><span class="o">;</span>
                <span class="o">++</span><span class="n">r</span><span class="o">;</span>
                <span class="o">++</span><span class="n">ans</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="manacher算法">Manacher算法</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_回文子串_Manacher算法_1.png" alt="leetcode_回文子串_Manacher算法_1" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/leetcode_回文子串_Manacher算法_2.png" alt="leetcode_回文子串_Manacher算法_2" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countSubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">StringBuffer</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">(</span><span class="s">"$#"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">t</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="n">t</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'#'</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'!'</span><span class="o">);</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">iMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 初始化 f[i]</span>
            <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rMax</span> <span class="o">?</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">rMax</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">f</span><span class="o">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iMax</span> <span class="o">-</span> <span class="n">i</span><span class="o">])</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// 中心拓展</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="c1">// 动态维护 iMax 和 rMax</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">rMax</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">iMax</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="n">rMax</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">作者</span><span class="err">：</span><span class="nc">LeetCode</span><span class="o">-</span><span class="nc">Solution</span>
<span class="n">链接</span><span class="err">：</span><span class="nl">https:</span><span class="c1">//leetcode-cn.com/problems/palindromic-substrings/solution/hui-wen-zi-chuan-by-leetcode-solution/</span>
<span class="n">来源</span><span class="err">：</span><span class="n">力扣</span><span class="err">（</span><span class="nc">LeetCode</span><span class="err">）</span>
<span class="n">著作权归作者所有</span><span class="err">。</span><span class="n">商业转载请联系作者获得授权</span><span class="err">，</span><span class="n">非商业转载请注明出处</span><span class="err">。</span>
</pre></table></code></div></div><p><span id="jump649"></span></p><h2 id="649-dota2-参议院">649. Dota2 参议院</h2><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><p><strong>禁止一名参议员的权利：</strong></p><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p><p><strong>宣布胜利：</strong></p><p>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"RD"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"Radiant"</span>
<span class="n">解释</span><span class="err">：</span><span class="n">第一个参议员来自</span> <span class="nc">Radiant</span> <span class="n">阵营并且他可以使用第一项权利让第二个参议员失去权力</span><span class="err">，</span><span class="n">因此第二个参议员将被跳过因为他没有任何权利</span><span class="err">。</span><span class="n">然后在第二轮的时候</span><span class="err">，</span><span class="n">第一个参议员可以宣布胜利</span><span class="err">，</span><span class="n">因为他是唯一一个有投票权的人</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"RDD"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"Dire"</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">第一轮中</span><span class="o">,</span><span class="n">第一个来自</span> <span class="nc">Radiant</span> <span class="n">阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span>
<span class="n">第二个来自</span> <span class="nc">Dire</span> <span class="n">阵营的参议员会被跳过因为他的权利被禁止</span>
<span class="n">第三个来自</span> <span class="nc">Dire</span> <span class="n">阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span>
<span class="n">因此在第二轮只剩下第三个参议员拥有投票的权利</span><span class="o">,</span><span class="n">于是他可以宣布胜利</span>
</pre></table></code></div></div><p>提示：</p><ul><li>给定字符串的长度在 [1, 10,000] 之间.</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">predictPartyVictory</span><span class="o">(</span><span class="nc">String</span> <span class="n">senate</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">senate</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">//将R和D的索引入队，再依次弹出比较，索引较小的放在队尾，较大的放弃</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">radiant</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">dire</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">senate</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'R'</span><span class="o">){</span>
                <span class="n">radiant</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">dire</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">radiant</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dire</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">radiant</span><span class="o">.</span><span class="na">poll</span><span class="o">(),</span> <span class="n">d</span> <span class="o">=</span> <span class="n">dire</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">){</span>
                <span class="n">radiant</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">n</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">dire</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">n</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">dire</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="s">"Dire"</span> <span class="o">:</span> <span class="s">"Radiant"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump657"></span></p><h2 id="657-机器人能否返回原点">657. 机器人能否返回原点</h2><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。</p><p>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。</p><p>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"UD"</span>
<span class="nl">输出:</span> <span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">机器人向上移动一次</span><span class="err">，</span><span class="n">然后向下移动一次</span><span class="err">。</span><span class="n">所有动作都具有相同的幅度</span><span class="err">，</span><span class="n">因此它最终回到它开始的原点</span><span class="err">。</span><span class="n">因此</span><span class="err">，</span><span class="n">我们返回</span> <span class="kc">true</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"LL"</span>
<span class="nl">输出:</span> <span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="n">机器人向左移动两次</span><span class="err">。</span><span class="n">它最终位于原点的左侧</span><span class="err">，</span><span class="n">距原点有两次</span> <span class="err">“</span><span class="n">移动</span><span class="err">”</span> <span class="n">的距离</span><span class="err">。</span><span class="n">我们返回</span> <span class="kc">false</span><span class="err">，</span><span class="n">因为它在移动结束时没有返回原点</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">judgeCircle</span><span class="o">(</span><span class="nc">String</span> <span class="n">moves</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">moves</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">moves</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">switch</span> <span class="o">(</span><span class="n">c</span><span class="o">){</span>
                <span class="k">case</span> <span class="sc">'R'</span><span class="o">:</span>
                    <span class="n">x</span><span class="o">++;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'L'</span><span class="o">:</span>
                    <span class="n">x</span><span class="o">--;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'U'</span><span class="o">:</span>
                    <span class="n">y</span><span class="o">--;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'D'</span><span class="o">:</span>
                    <span class="n">y</span><span class="o">++;</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump659"></span></p><h2 id="659分割数组为连续子序列">659.分割数组为连续子序列</h2><p>给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。</p><p>如果可以完成上述分割，则返回 true ；否则，返回 false 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="nc">True</span>
<span class="nl">解释:</span>
<span class="n">你可以分割出这样两个连续子序列</span> <span class="o">:</span> 
<span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span>
<span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="nc">True</span>
<span class="nl">解释:</span>
<span class="n">你可以分割出这样两个连续子序列</span> <span class="o">:</span> 
<span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span>
<span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="nc">False</span>
</pre></table></code></div></div><p>提示：</p><ul><li>输入的数组长度范围为 [1, 10000]</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c1">//贪心</span>
<span class="c1">//由于序列是升序，所以在遍历过程中，不会过度增长子序列</span>
<span class="c1">//因为只会把较小的每个数字都安排完以后，才会去处理更大的数字</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPossible</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//记录nums中数字的个数</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//记录以数字key结尾的子序列个数</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="c1">//当前数字可以接在以num-1为结尾的子序列后</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tail</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">tail</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span><span class="n">tail</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">//消耗掉一个以num-1为结尾的子序列</span>
                <span class="n">tail</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">tail</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="c1">//消耗掉一个num</span>
                <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">//当前数字只能自成一个序列</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span>
                        <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">tail</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">+</span><span class="mi">2</span><span class="o">,</span> <span class="n">tail</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">+</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump665"></span></p><h2 id="665-非递减数列">665. 非递减数列</h2><p>给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="kc">true</span>
<span class="nl">解释:</span> <span class="n">你可以通过把第一个4变成1来使得它成为一个非递减数列</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="kc">false</span>
<span class="nl">解释:</span> <span class="n">你不能在只改变一个元素的情况下将其变为非递减数列</span><span class="err">。</span>
</pre></table></code></div></div><p>说明：</p><ul><li><p>1 &lt;= n &lt;= 10 ^ 4</p></li><li><p>10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</p></li></ul><p>关键点在于nums[i+1]是否小于nums[i-1]，如果nums[i+1]小于nums[i-1]那么意味着只能将nums[i+1]增大才能满足要求，但是我们不能把它变得太大，否则会影响后面的序列，所以最好将其增大为nums[i]；如果nums[i+1]大于等于nums[i-1]，那么意味着nums[i+1]可以保持原样，只需修改nums[i]，nums[i]无需显式修改，只需记录修改的次数即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkPossibility</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">cnt</span><span class="o">++;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="671-二叉树中第二小的节点">671. 二叉树中第二小的节点</h2><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p><p>更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</p><p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findSecondMinimumValue</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//如果一个节点有两个子节点，那么该节点的值等于两个子节点的最小值</span>
        <span class="c1">//首先根节点是最小值，然后迭代找第二小的</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">min</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump679"></span></p><h2 id="679-24点游戏">679. 24点游戏</h2><p>给出4个1-10的数字，通过加减乘除，得到数字为24就算胜利</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">judgePoint24</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span> <span class="no">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">v:</span> <span class="n">nums</span><span class="o">)</span> <span class="no">A</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="n">v</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="o">(</span><span class="no">A</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">solve</span><span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="mi">24</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">nums2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;();</span>
                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">k</span><span class="o">++)</span> <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">nums2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
                    <span class="o">}</span>
                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">nums2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">nums2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">*</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="n">nums2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">nums2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">/</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                <span class="k">continue</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">nums2</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">nums2</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums2</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">judgePoint24</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span>
            <span class="n">numbers</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span><span class="n">num</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="o">(</span><span class="n">numbers</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">solve</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="o">){</span>
        <span class="c1">//若list为空，返回false</span>
        <span class="k">if</span><span class="o">(</span><span class="n">numbers</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//若list长度为1，则说明计算到了最终结果，比较</span>
        <span class="k">if</span><span class="o">(</span><span class="n">numbers</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">((</span><span class="n">numbers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="mi">24</span><span class="o">*</span><span class="mf">1.0</span><span class="o">))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="o">;</span>
        
        <span class="c1">//从其中取出2个不同的数</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
                    <span class="c1">//新建一个数组，避免将取出的数插入到原来的位置</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                    <span class="c1">//将原数组的剩余的数插入到新数组中</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span>
                            <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">numbers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
                    <span class="o">}</span>
                    <span class="c1">//计算i,j两个数的结果集，也加入nums数组中</span>
                    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">resultSet</span> <span class="o">=</span> <span class="n">cal</span><span class="o">(</span><span class="n">numbers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">numbers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                    <span class="c1">//回溯</span>
                    <span class="k">for</span><span class="o">(</span><span class="nc">Double</span> <span class="n">res</span> <span class="o">:</span> <span class="n">resultSet</span><span class="o">){</span>
                        <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">nums</span><span class="o">))</span>
                            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">nums</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="nf">cal</span><span class="o">(</span><span class="nc">Double</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Double</span> <span class="n">b</span><span class="o">){</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">;</span>
    <span class="o">}</span>


<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump684"></span></p><h2 id="684-冗余连接">684. 冗余连接</h2><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="nl">给定的无向图为:</span>
  <span class="mi">1</span>
 <span class="o">/</span> <span class="err">\</span>
<span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="nl">给定的无向图为:</span>
<span class="mi">5</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="o">|</span>   <span class="o">|</span>
    <span class="mi">4</span> <span class="o">-</span> <span class="mi">3</span>
</pre></table></code></div></div><p>注意:</p><ul><li>输入的二维数组大小在 3 到 1000。</li><li>二维数组中的整数在1到N之间，其中N是输入数组的大小。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//并查集：</span>
    <span class="c1">//在一棵树上加1条边，使其形成环</span>
    <span class="c1">//初始时让每个节点都属于不同的连通分量</span>
    <span class="c1">//遍历每一条边，若当前边的两个顶点属于不同的连通分量，则这条边不会导致环路出现</span>
    <span class="c1">//若当前边的两个顶点已经属于同一个连通分量，说明这条边加上后会导致环路出现</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findRedundantConnection</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="c1">//图中顶点的个数</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">union</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">])){</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]};</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">=</span> <span class="n">py</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump685"></span></p><h2 id="685冗余连接-ii">685.冗余连接 II</h2><p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="nl">给定的有向图如下:</span>
  <span class="mi">1</span>
 <span class="o">/</span> <span class="err">\</span>
<span class="n">v</span>   <span class="n">v</span>
<span class="mi">2</span><span class="o">--&gt;</span><span class="mi">3</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">]]</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="nl">给定的有向图如下:</span>
<span class="mi">5</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">2</span>
     <span class="o">^</span>    <span class="o">|</span>
     <span class="o">|</span>    <span class="n">v</span>
     <span class="mi">4</span> <span class="o">&lt;-</span> <span class="mi">3</span>
</pre></table></code></div></div><p>注意:</p><ul><li>二维数组大小的在3到1000范围内。</li><li>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</li></ul><p>原始图有是由一颗有根树添加一条附加边而来，那么这个图中的边数等于图的顶点数。</p><p>树中的每个节点都有一个父节点，除了根节点没有父节点。在多了一条附加的边之后，可能有以下两种情况：</p><ul><li>附加的边指向<strong>根节点</strong>，则包括根节点在内的每个节点都有一个父节点，此时图中一定有环路；</li><li>附加的边指向<strong>非根节点</strong>，则恰好有一个节点（即被附加的边指向的节点）有两个父节点，此时图中可能有环路也可能没有环路。</li></ul><p>要找到附加的边，需要遍历图中的所有的边构建出一棵树，在构建树的过程中寻找导致<strong>冲突（即导致一个节点有两个父节点）</strong>的边以及<strong>导致环路</strong>出现的边。</p><p>具体做法是，使用数组<code class="language-plaintext highlighter-rouge">parent </code>记录每个节点的父节点，初始时对于任何 <code class="language-plaintext highlighter-rouge">1≤i≤N </code>都有<code class="language-plaintext highlighter-rouge">parent[i]=i</code>，另外创建并查集，初始时并查集中的每个节点都是一个连通分支，该连通分支的根节点就是该节点本身。遍历每条边的过程中，维护导致冲突的边和导致环路出现的边，由于只有一条附加的边，因此<strong>最多有一条导致冲突的边和一条导致环路出现的边。</strong></p><p>当访问到边 <code class="language-plaintext highlighter-rouge">[u,v]</code> 时，进行如下操作：</p><ul><li>如果此时已经有<code class="language-plaintext highlighter-rouge">parent[v] !=v</code>，说明 v 有两个父节点，将当前的边 <code class="language-plaintext highlighter-rouge">[u,v]</code> 记为导致冲突的边；</li><li>否则，令<code class="language-plaintext highlighter-rouge">parent[v]=u</code>，然后在并查集中分别找到<code class="language-plaintext highlighter-rouge">u </code>和 <code class="language-plaintext highlighter-rouge">v</code> 的祖先（即各自的连通分支中的根节点），如果祖先相同，说明这条边导致环路出现，将当前的边 <code class="language-plaintext highlighter-rouge">[u,v]</code>记为导致环路出现的边，如果祖先不同，则在并查集中将 <code class="language-plaintext highlighter-rouge">u</code> 和 <code class="language-plaintext highlighter-rouge">v </code>进行合并。</li><li>根据上述操作，同一条边不可能同时被记为导致冲突的边和导致环路出现的边。</li></ul><p>遍历所有边之后，根据是否存在导致冲突的边和导致环路的边，来得到附加的边。</p><ul><li>如果没有导致冲突的边，说明附加的边一定导致环路出现，而且是在环路中的最后一条被访问到的边，因此附加的边即为导致环路出现的边。</li><li>如果有导致冲突的边，记这条边为 <code class="language-plaintext highlighter-rouge">[u,v]</code>，则有两条边指向 <code class="language-plaintext highlighter-rouge">v</code>，另一条边为 <code class="language-plaintext highlighter-rouge">[parent[v],v]</code>，需要通过判断是否有导致环路的边决定哪条边是附加的边。<ul><li>如果有导致环路的边，则附加的边不可能是 <code class="language-plaintext highlighter-rouge">[u,v]</code>（因为 <code class="language-plaintext highlighter-rouge">[u,v]</code> 已经被记为导致冲突的边，不可能被记为导致环路出现的边），因此附加的边是 <code class="language-plaintext highlighter-rouge">[parent[v],v]</code>。</li><li>如果没有导致环路的边，则附加的边是后被访问到的指向<code class="language-plaintext highlighter-rouge"> v</code> 的边，因此附加的边是 <code class="language-plaintext highlighter-rouge">[u,v]</code>。</li></ul></li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findRedundantDirectedConnection</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="nc">UnionFind</span> <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UnionFind</span><span class="o">(</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//导致冲突的边</span>
        <span class="kt">int</span> <span class="n">conflict</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">//导致环路的边</span>
        <span class="kt">int</span> <span class="n">cycle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">//遍历所有边</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="c1">//若此时这条边的子节点的父节点早就记录过了，所以v除了u之外，还有一个父节点，记录为导致冲突的边</span>
            <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">!=</span> <span class="n">v</span><span class="o">){</span>
                <span class="n">conflict</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="c1">//否则就更新v的父节点</span>
                <span class="n">parent</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">;</span>
                <span class="c1">//如果u和v的父节点相同，则说明这条边导致了环路</span>
                <span class="k">if</span><span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">u</span><span class="o">)</span> <span class="o">==</span> <span class="n">uf</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">v</span><span class="o">)){</span>
                    <span class="n">cycle</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="c1">//将这条边加入并查集中</span>
                    <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">);</span>
                <span class="o">}</span>

            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//没有发生冲突</span>
        <span class="k">if</span><span class="o">(</span><span class="n">conflict</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">//那么附加的边一定是导致环路出现的边，而且是最后一条导致环路的边</span>
            <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">cycle</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">res</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">cycle</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="c1">//有发生了冲突的边(u,v)，说明节点v有两个父节点，分别是u和parent[v]</span>
            <span class="c1">//那么附加边就是(u,v)和(parent[v],v)的其中一条</span>

            <span class="c1">//有导致环路的边，那么附加的边不可能是(u,v),因为(u,v)已经被记为导致冲突的边了，不可能被记为导致环路的边</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cycle</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">edges</span><span class="o">[</span><span class="n">conflict</span><span class="o">][</span><span class="mi">1</span><span class="o">]];</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">conflict</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="c1">//没有导致环路的边，那么附加的边就是导致冲突的变</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">conflict</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">conflict</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">UnionFind</span><span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">pre</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">UnionFind</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">pre</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//顺带做了路径压缩，最后把x的父节点修改为了根节点</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">pre</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">){</span>
            <span class="n">pre</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">pre</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
        <span class="n">pre</span><span class="o">[</span><span class="n">find</span><span class="o">(</span><span class="n">a</span><span class="o">)]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p><span id="jump696"></span></p><h2 id="696-计数二进制子串">696. 计数二进制子串</h2><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p><p>重复出现的子串要计算它们出现的次数。</p><p>示例 1 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"00110011"</span>
<span class="nl">输出:</span> <span class="mi">6</span>
<span class="nl">解释:</span> <span class="n">有6个子串具有相同数量的连续1和0</span><span class="err">：“</span><span class="mo">0011</span><span class="err">”，“</span><span class="mo">01</span><span class="err">”，“</span><span class="mi">1100</span><span class="err">”，“</span><span class="mi">10</span><span class="err">”，“</span><span class="mo">0011</span><span class="err">”</span> <span class="n">和</span> <span class="err">“</span><span class="mo">01</span><span class="err">”。</span>
<span class="n">请注意</span><span class="err">，</span><span class="n">一些重复出现的子串要计算它们出现的次数</span><span class="err">。</span>
<span class="n">另外</span><span class="err">，“</span><span class="mo">00110011</span><span class="err">”</span><span class="n">不是有效的子串</span><span class="err">，</span><span class="n">因为所有的0</span><span class="err">（</span><span class="n">和1</span><span class="err">）</span><span class="n">没有组合在一起</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"10101"</span>
<span class="nl">输出:</span> <span class="mi">4</span>
<span class="nl">解释:</span> <span class="n">有4个子串</span><span class="err">：“</span><span class="mi">10</span><span class="err">”，“</span><span class="mo">01</span><span class="err">”，“</span><span class="mi">10</span><span class="err">”，“</span><span class="mo">01</span><span class="err">”，</span><span class="n">它们具有相同数量的连续1和0</span><span class="err">。</span>
</pre></table></code></div></div><p>注意：</p><ul><li>s.length 在1到50,000之间。</li><li>s 只包含“0”或“1”字符。</li></ul><h3 id="按字符分组">按字符分组</h3><p>将字符串串 s 按照 00 和 11 的连续段分组，存在counts 数组中，例如 s=00111011，可以得到这样的counts 数组：counts={2,3,1,2}。</p><p>只要遍历这个数组，相邻元素的最小值即为第i次的贡献。一共需遍历n-1次</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountBinarySubString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countBinarySubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)){</span>
                <span class="k">if</span><span class="o">(++</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">counts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">);</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">counts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="n">counts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">CountBinarySubString</span><span class="o">().</span><span class="na">countBinarySubstrings</span><span class="o">(</span><span class="s">"00110011"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="左右扩展">左右扩展</h3><p>每遍历到一个相邻互异对，则左右扩展，统计数量。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countBinarySubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span>
                <span class="n">subCounts</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">subCounts</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span> 
        <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
        <span class="o">){</span>
            <span class="n">right</span><span class="o">++;</span>
            <span class="n">left</span><span class="o">--;</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump701"></span></p><h2 id="701二叉搜索树中的插入操作tag">701.二叉搜索树中的插入操作[tag]</h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如,</p><p>给定二叉搜索树:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    4
   / \
  2   7
 / \
1   3
</pre></table></code></div></div><p>和 插入的值: 5 你可以返回这个二叉搜索树:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>     4
   /   \
  2     7
 / \   /
1   3 5
</pre></table></code></div></div><p>或者这个树也是有效的:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>     5
   /   \
  2     7
 / \   
1   3
     \
      4
</pre></table></code></div></div><p>提示：</p><ul><li>给定的树上的节点数介于 0 和 10^4 之间</li><li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li><li>-10^8 &lt;= val &lt;= 10^8</li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><p>递归插入即可。如果说是插入到一个平衡的二叉搜索树，就没这么简单了！打个tag，改天试试！</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">insertIntoBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">insert</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">val</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
                    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">insert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">val</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
                    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">insert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">val</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
                
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump703"></span></p><h2 id="703-数据流中的第-k-大元素">703. 数据流中的第 K 大元素</h2><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p><p>请实现 KthLargest 类：</p><p>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
<span class="o">[</span><span class="s">"KthLargest"</span><span class="o">,</span> <span class="s">"add"</span><span class="o">,</span> <span class="s">"add"</span><span class="o">,</span> <span class="s">"add"</span><span class="o">,</span> <span class="s">"add"</span><span class="o">,</span> <span class="s">"add"</span><span class="o">]</span>
<span class="o">[[</span><span class="mi">3</span><span class="o">,</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">]],</span> <span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">5</span><span class="o">],</span> <span class="o">[</span><span class="mi">10</span><span class="o">],</span> <span class="o">[</span><span class="mi">9</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span>
<span class="o">[</span><span class="kc">null</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">]</span>

<span class="n">解释</span><span class="err">：</span>
<span class="nc">KthLargest</span> <span class="n">kthLargest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KthLargest</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">]);</span>
<span class="n">kthLargest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>   <span class="c1">// return 4</span>
<span class="n">kthLargest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>   <span class="c1">// return 5</span>
<span class="n">kthLargest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>  <span class="c1">// return 5</span>
<span class="n">kthLargest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">9</span><span class="o">);</span>   <span class="c1">// return 8</span>
<span class="n">kthLargest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>   <span class="c1">// return 8</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= k &lt;= 104</li><li>0 &lt;= nums.length &lt;= 104</li><li>-104 &lt;= nums[i] &lt;= 104</li><li>-104 &lt;= val &lt;= 104</li><li>最多调用 add 方法 104 次</li><li>题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">KthLargest</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">KthLargest</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//初始化</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="c1">//入优先队列</span>
            <span class="n">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">size</span><span class="o">){</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump705"></span></p><h2 id="705-设计哈希集合">705. 设计哈希集合</h2><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 MyHashSet 类：</p><p>void add(key) 向哈希集合中插入值 key 。 bool contains(key) 返回哈希集合中是否存在这个值 key 。 void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
<span class="o">[</span><span class="s">"MyHashSet"</span><span class="o">,</span> <span class="s">"add"</span><span class="o">,</span> <span class="s">"add"</span><span class="o">,</span> <span class="s">"contains"</span><span class="o">,</span> <span class="s">"contains"</span><span class="o">,</span> <span class="s">"add"</span><span class="o">,</span> <span class="s">"contains"</span><span class="o">,</span> <span class="s">"remove"</span><span class="o">,</span> <span class="s">"contains"</span><span class="o">]</span>
<span class="o">[[],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span>
<span class="o">[</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">]</span>

<span class="n">解释</span><span class="err">：</span>
<span class="nc">MyHashSet</span> <span class="n">myHashSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyHashSet</span><span class="o">();</span>
<span class="n">myHashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>      <span class="c1">// set = [1]</span>
<span class="n">myHashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>      <span class="c1">// set = [1, 2]</span>
<span class="n">myHashSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 返回 True</span>
<span class="n">myHashSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span> <span class="c1">// 返回 False ，（未找到）</span>
<span class="n">myHashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>      <span class="c1">// set = [1, 2]</span>
<span class="n">myHashSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// 返回 True</span>
<span class="n">myHashSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>   <span class="c1">// set = [1]</span>
<span class="n">myHashSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// 返回 False ，（已移除）</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= key &lt;= 106</li><li>最多调用 104 次 add、remove 和 contains 。</li></ul><p>进阶：你可以不使用内建的哈希集合库解决此问题吗？</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">MyHashSet</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">[]</span> <span class="n">nodes</span><span class="o">;</span>
    <span class="cm">/** Initialize your data structure here. */</span>
    <span class="kd">public</span> <span class="nf">MyHashSet</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="mi">10001</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">contains</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>   <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">hashcode</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        
        <span class="nc">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
        <span class="n">tmp</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nodes</span><span class="o">[</span><span class="n">hashcode</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span><span class="c1">//槽位为空，直接填入</span>
            <span class="n">nodes</span><span class="o">[</span><span class="n">hashcode</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="nc">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">[</span><span class="n">hashcode</span><span class="o">];</span>
            <span class="k">while</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span><span class="c1">//拉链</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">contains</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>  <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">hashcode</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nodes</span><span class="o">[</span><span class="n">hashcode</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">[</span><span class="n">hashcode</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">key</span><span class="o">){</span><span class="c1">//头节点就是需要被删除的节点</span>
                <span class="nc">Node</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">nodes</span><span class="o">[</span><span class="n">hashcode</span><span class="o">]</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">while</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">key</span><span class="o">){</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span><span class="c1">//在链表中已经找到了需要被删除的节点</span>
                <span class="nc">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="cm">/** Returns true if this set contains the specified element */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hashcode</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">[</span><span class="n">hashcode</span><span class="o">];</span>
        <span class="k">while</span><span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span><span class="c1">//为了避免两个hash值相等，但是key不等的情况，把链表遍历一遍</span>
            <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">key</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">hashVal</span> <span class="o">=</span> <span class="o">((</span><span class="n">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="o">)</span> <span class="o">|</span> <span class="n">key</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10001</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">hashVal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">Node</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">(){</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * boolean param_3 = obj.contains(key);
 */</span>
</pre></table></code></div></div><p><span id="jump714"></span></p><h2 id="714-买卖股票的最佳时机含手续费">714. 买卖股票的最佳时机含手续费</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">prices</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">],</span> <span class="n">fee</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="mi">8</span>
<span class="nl">解释:</span> <span class="nl">能够达到的最大利润:</span>  
<span class="n">在此处买入</span> <span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">在此处卖出</span> <span class="n">prices</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">在此处买入</span> <span class="n">prices</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">在此处卖出</span> <span class="n">prices</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="mi">9</span>
<span class="nl">总利润:</span> <span class="o">((</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="o">((</span><span class="mi">9</span> <span class="o">-</span> <span class="mi">4</span><span class="o">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">=</span> <span class="mi">8</span><span class="o">.</span>
</pre></table></code></div></div><p>注意:</p><ul><li>0 &lt; prices.length &lt;= 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;= fee &lt; 50000.</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fee</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//dp[i]表示对第i只股票操作后能够得到的最大收益，</span>
        <span class="c1">//dp[i][0]表示持有一只股票，dp[i][1]表示不持有一只股票</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//第i轮过后持有一只股票</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">//第i轮过后不持有一只股票</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">fee</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span><span class="n">dp</span><span class="o">[</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>空间优化</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fee</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//dp[i]表示对第i只股票操作后能够得到的最大收益，</span>
        <span class="c1">//dp[i][0]表示持有一只股票，dp[i][1]表示不持有一只股票</span>
        <span class="kt">int</span> <span class="n">hold</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">selt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//第i轮过后持有一只股票</span>
            <span class="kt">int</span> <span class="n">tmp_hold</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">hold</span><span class="o">,</span> <span class="n">selt</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">//第i轮过后不持有一只股票</span>
            <span class="n">selt</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">selt</span><span class="o">,</span> <span class="n">hold</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">fee</span><span class="o">);</span>
            <span class="n">hold</span> <span class="o">=</span> <span class="n">tmp_hold</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">selt</span><span class="o">;</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump718"></span></p><h2 id="718最长公共连续子数组">718.最长公共连续子数组</h2><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><p>示例 1:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3

解释: 
长度最长的公共子数组是 [3, 2, 1]。
</pre></table></code></div></div><p>说明:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>1 &lt;= len(A), len(B) &lt;= 1000
0 &lt;= A[i], B[i] &lt; 100
</pre></table></code></div></div><h3 id="动态规划-6">动态规划</h3><p>这个题目是最长公共子序列的变化形式，要求子序列连续。</p><p>最长公共子序列解法：设<code class="language-plaintext highlighter-rouge">c[i][j]</code>为序列a的前<code class="language-plaintext highlighter-rouge">i</code>个元素和序列b前<code class="language-plaintext highlighter-rouge">j</code>个元素的最长公共子序列长度（可不连续，只要求找出的子序列下标递增）。那么</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>当<span class="sb">`a[i] == b[j]`</span>时，<span class="sb">`c[i][j] = c[i-1][j-1]+1`</span>。
当<span class="sb">`a[i] != b[j]`</span>时，<span class="sb">`c[i][j] = max(c[i-1][j],c[i][j-1])`</span>
</pre></table></code></div></div><p>只需返回<code class="language-plaintext highlighter-rouge">c[a.length][b.length]</code>就能得到最终的结果。</p><p>但是这个题目要求子数组必须连续，则当<code class="language-plaintext highlighter-rouge">a[i] != b[j]</code>时，要令<code class="language-plaintext highlighter-rouge">c[i][j]=0</code>，最后返回数组c的最大值就能得到最终结果。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">B</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//c[i][j]表示A数组的前i个元素和B数组的前i个元素的最长公共子数组长度</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="no">B</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">;++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">B</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">;++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">c</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="no">B</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="no">B</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                    <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">)</span>
                        <span class="n">max</span> <span class="o">=</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="k">else</span>
                    <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>


        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="no">B</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">().</span><span class="na">findLength</span><span class="o">(</span><span class="no">A</span><span class="o">,</span><span class="no">B</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">B</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="no">B</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="no">B</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">?</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="滑动窗口">滑动窗口</h3><p>待补充</p><h3 id="二分法哈希">二分法+哈希</h3><p>待补充</p><p><span id="jump721"></span></p><h2 id="721-账户合并">721. 账户合并</h2><p>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
<span class="n">accounts</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"johnsmith@mail.com"</span><span class="o">,</span> <span class="s">"john00@mail.com"</span><span class="o">],</span> <span class="o">[</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"johnnybravo@mail.com"</span><span class="o">],</span> <span class="o">[</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"johnsmith@mail.com"</span><span class="o">,</span> <span class="s">"john_newyork@mail.com"</span><span class="o">],</span> <span class="o">[</span><span class="s">"Mary"</span><span class="o">,</span> <span class="s">"mary@mail.com"</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span>
<span class="o">[[</span><span class="s">"John"</span><span class="o">,</span> <span class="err">'</span><span class="n">john00</span><span class="nd">@mail</span><span class="o">.</span><span class="na">com</span><span class="err">'</span><span class="o">,</span> <span class="err">'</span><span class="n">john_newyork</span><span class="nd">@mail</span><span class="o">.</span><span class="na">com</span><span class="err">'</span><span class="o">,</span> <span class="err">'</span><span class="n">johnsmith</span><span class="nd">@mail</span><span class="o">.</span><span class="na">com</span><span class="err">'</span><span class="o">],</span>  <span class="o">[</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"johnnybravo@mail.com"</span><span class="o">],</span> <span class="o">[</span><span class="s">"Mary"</span><span class="o">,</span> <span class="s">"mary@mail.com"</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">第一个和第三个</span> <span class="nc">John</span> <span class="n">是同一个人</span><span class="err">，</span><span class="n">因为他们有共同的邮箱地址</span> <span class="s">"johnsmith@mail.com"</span><span class="err">。</span> 
<span class="n">第二个</span> <span class="nc">John</span> <span class="n">和</span> <span class="nc">Mary</span> <span class="n">是不同的人</span><span class="err">，</span><span class="n">因为他们的邮箱地址没有被其他帐户使用</span><span class="err">。</span>
<span class="n">可以以任何顺序返回这些列表</span><span class="err">，</span><span class="n">例如答案</span> <span class="o">[[</span><span class="err">'</span><span class="nc">Mary</span><span class="sc">'，'</span><span class="n">mary</span><span class="nd">@mail</span><span class="o">.</span><span class="na">com</span><span class="err">'</span><span class="o">]</span><span class="err">，</span><span class="o">[</span><span class="err">'</span><span class="nc">John</span><span class="sc">'，'</span><span class="n">johnnybravo</span><span class="nd">@mail</span><span class="o">.</span><span class="na">com</span><span class="err">'</span><span class="o">]</span><span class="err">，</span>
<span class="o">[</span><span class="err">'</span><span class="nc">John</span><span class="sc">'，'</span><span class="n">john00</span><span class="nd">@mail</span><span class="o">.</span><span class="na">com</span><span class="sc">'，'</span><span class="n">john_newyork</span><span class="nd">@mail</span><span class="o">.</span><span class="na">com</span><span class="sc">'，'</span><span class="n">johnsmith</span><span class="nd">@mail</span><span class="o">.</span><span class="na">com</span><span class="err">'</span><span class="o">]]</span> <span class="n">也是正确的</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>accounts的长度将在[1，1000]的范围内。</li><li>accounts[i]的长度将在[1，10]的范围内。</li><li><code class="language-plaintext highlighter-rouge">accounts[i][j]</code>的长度将在[1，30]的范围内。</li></ul><p>并查集+哈希表，将邮件地址作为顶点进行编号，然后将同一个账户的邮件地址通过并查集合并，最后将同一个账户的邮件地址进行排序。</p><p>需要邮件地址-&gt;编号的映射，在合并邮件时，需要读取邮件的编号。</p><p>需要邮件地址-&gt;账户名的映射，最终记录结果时，需要将账户名放在列表首位。</p><p>需要parent-&gt;邮件列表的映射，同一个账户的邮件地址放入同一个列表中。</p><p>所以需要三个哈希表。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//并查集，将每个邮件地址作为顶点，若同属于一个账户，就进行合并</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">accountsMerge</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">accounts</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//两个哈希表</span>
        <span class="c1">//邮件对编号</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">emailToIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//邮件对名称</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">emailToName</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//对邮件进行编号</span>
        <span class="kt">int</span> <span class="n">emailCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//遍历所有邮件</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">account</span> <span class="o">:</span> <span class="n">accounts</span><span class="o">){</span>
            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">String</span> <span class="n">email</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="c1">//建立邮件对编号、邮件对账户名的映射</span>
                <span class="c1">//即使在不同列表中的邮件地址，只要邮件地址相同，编号就一样</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">emailToIndex</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">email</span><span class="o">)){</span>
                    <span class="n">emailToIndex</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">email</span><span class="o">,</span> <span class="n">emailCount</span><span class="o">++);</span>
                    <span class="n">emailToName</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">email</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//并查集</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">emailCount</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">emailCount</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//将同个账户的邮件编号在并查集中合并</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">account</span> <span class="o">:</span> <span class="n">accounts</span><span class="o">){</span>
            <span class="nc">String</span> <span class="n">firstEmail</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">firstIndex</span> <span class="o">=</span> <span class="n">emailToIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">firstEmail</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">String</span> <span class="n">nextEmail</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="kt">int</span> <span class="n">nextIndex</span> <span class="o">=</span> <span class="n">emailToIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nextEmail</span><span class="o">);</span>
                <span class="c1">//将邮箱地址进行合并</span>
                <span class="n">union</span><span class="o">(</span><span class="n">firstIndex</span><span class="o">,</span> <span class="n">nextIndex</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//将parent作为key，邮件列表作为value</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">indexToEmails</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//遍历所有邮件，将相同parent的邮件地址放入同一个列表中</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span> <span class="o">:</span> <span class="n">emailToIndex</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="c1">//找到每个邮件地址的parent，将邮件地址放入哈希表中</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">emailToIndex</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">email</span><span class="o">));</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">account</span> <span class="o">=</span> <span class="n">indexToEmails</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;());</span>
            <span class="n">account</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">email</span><span class="o">);</span>
            <span class="n">indexToEmails</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">account</span><span class="o">);</span>
        <span class="o">}</span>


        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">emails</span> <span class="o">:</span> <span class="n">indexToEmails</span><span class="o">.</span><span class="na">values</span><span class="o">()){</span>
            <span class="c1">//将邮件地址排序</span>
            <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">emails</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">emailToName</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">emails</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">account</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="c1">//组装放入account</span>
            <span class="n">account</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="n">account</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">emails</span><span class="o">);</span>

            <span class="c1">//放入结果集</span>
            <span class="n">merged</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">account</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">merged</span><span class="o">;</span>


    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>

        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

        <span class="n">parent</span><span class="o">[</span><span class="n">py</span><span class="o">]</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><h2 id="726-原子的数量">726. 原子的数量</h2><p>给定一个化学式formula（作为字符串），返回每种原子的数量。</p><p>原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。</p><p>如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。</p><p>两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。</p><p>一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。</p><p>给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。</p><p>示例 :</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
<span class="n">formula</span> <span class="o">=</span> <span class="s">"K4(ON(SO3)2)2"</span>
<span class="nl">输出:</span> <span class="s">"K4N2O14S4"</span>
<span class="nl">解释:</span> 
<span class="n">原子的数量是</span> <span class="o">{</span><span class="sc">'K'</span><span class="o">:</span> <span class="mi">4</span><span class="o">,</span> <span class="sc">'N'</span><span class="o">:</span> <span class="mi">2</span><span class="o">,</span> <span class="sc">'O'</span><span class="o">:</span> <span class="mi">14</span><span class="o">,</span> <span class="sc">'S'</span><span class="o">:</span> <span class="mi">4</span><span class="o">}</span><span class="err">。</span>
<span class="nl">注意:</span>

<span class="n">所有原子的第一个字母为大写</span><span class="err">，</span><span class="n">剩余字母都是小写</span><span class="err">。</span>
<span class="n">formula的长度在</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1000</span><span class="o">]</span><span class="n">之间</span><span class="err">。</span>
<span class="n">formula只包含字母</span><span class="err">、</span><span class="n">数字和圆括号</span><span class="err">，</span><span class="n">并且题目中给定的是合法的化学式</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">().</span><span class="na">countOfAtoms</span><span class="o">(</span><span class="s">"(H)"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>

    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">countOfAtoms</span><span class="o">(</span><span class="nc">String</span> <span class="n">formula</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//每一层完整括号用一个哈希表存</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//最外层的哈希表</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//用一个列表存内层哈希表，列表最尾端的哈希表是当前最内部（最内括号）的哈希表</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">mList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="s">"("</span><span class="o">);</span>
                <span class="n">mList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;());</span>
                <span class="n">idx</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">){</span>
                <span class="n">idx</span><span class="o">++;</span>
                <span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="n">scanInteger</span><span class="o">(</span><span class="n">formula</span><span class="o">);</span>
                <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">mList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">help</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
                <span class="c1">//拆括号，执行乘法</span>
                <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"("</span><span class="o">)){</span>
                    <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">times</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>   <span class="n">tmp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">tmp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="o">*</span> <span class="n">times</span><span class="o">);</span>
                    <span class="n">help</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">//左括号出栈</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="c1">//移除这一层的哈希表</span>
                <span class="n">mList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">mList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">map</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">mList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">mList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">//将这一层哈希表合并到上一层</span>
                <span class="k">while</span><span class="o">(!</span><span class="n">help</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">help</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">pre</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
                        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">tmp</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">pre</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">pre</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">tmp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
                <span class="o">}</span>

            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">map</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">mList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">mList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mList</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">//找原子</span>
                <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">scanItem</span><span class="o">(</span><span class="n">formula</span><span class="o">);</span>
                <span class="c1">//找次数</span>
                <span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="n">scanInteger</span><span class="o">(</span><span class="n">formula</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">times</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="n">times</span><span class="o">++;</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">tmp</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">)){</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">tmp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">tmp</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">times</span><span class="o">);</span>

            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>
        <span class="c1">//字典序</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">scanInteger</span><span class="o">(</span><span class="nc">String</span> <span class="n">formula</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">formula</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span> <span class="o">!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">));</span>
        <span class="n">idx</span><span class="o">++;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">formula</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">))){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">));</span>
            <span class="n">idx</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">scanItem</span><span class="o">(</span><span class="nc">String</span> <span class="n">formula</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">formula</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">));</span>
        <span class="n">idx</span><span class="o">++;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">formula</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isLowerCase</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">))){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">formula</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">));</span>
            <span class="n">idx</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>



<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump733"></span></p><h2 id="733-图像渲染">733. 图像渲染</h2><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> 
<span class="n">image</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="n">sr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">newColor</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nl">输出:</span> <span class="o">[[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="nl">解析:</span> 
<span class="n">在图像的正中间</span><span class="err">，</span><span class="o">(</span><span class="n">坐标</span><span class="o">(</span><span class="n">sr</span><span class="o">,</span><span class="n">sc</span><span class="o">)=(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">)),</span>
<span class="n">在路径上所有符合条件的像素点的颜色都被更改成2</span><span class="err">。</span>
<span class="n">注意</span><span class="err">，</span><span class="n">右下角的像素没有更改为2</span><span class="err">，</span>
<span class="n">因为它不是在上下左右四个方向上与初始点相连的像素点</span><span class="err">。</span>
</pre></table></code></div></div><p>注意:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">image</span> <span class="n">和</span> <span class="n">image</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">的长度在范围</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">50</span><span class="o">]</span> <span class="n">内</span><span class="err">。</span>
<span class="n">给出的初始点将满足</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sr</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">.</span><span class="na">length</span> <span class="n">和</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sc</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="err">。</span>
<span class="n">image</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="n">和</span> <span class="n">newColor</span> <span class="n">表示的颜色值在范围</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">65535</span><span class="o">]</span><span class="n">内</span><span class="err">。</span>
</pre></table></code></div></div><h3 id="深搜-1">深搜</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.awt.Point</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">images</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">srcColor</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">color</span><span class="o">;</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Point</span><span class="o">&gt;</span> <span class="n">set</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">floodFill</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">image</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sc</span><span class="o">,</span> <span class="kt">int</span> <span class="n">newColor</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">image</span><span class="o">[</span><span class="n">sr</span><span class="o">][</span><span class="n">sc</span><span class="o">]</span> <span class="o">==</span> <span class="n">newColor</span><span class="o">)</span> <span class="k">return</span> <span class="n">image</span><span class="o">;</span>
        <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">image</span><span class="o">;</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">newColor</span><span class="o">;</span>
        <span class="n">srcColor</span> <span class="o">=</span> <span class="n">images</span><span class="o">[</span><span class="n">sr</span><span class="o">][</span><span class="n">sc</span><span class="o">];</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">sr</span><span class="o">,</span><span class="n">sc</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">images</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">sr</span><span class="o">,</span><span class="kt">int</span> <span class="n">sc</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sr</span> <span class="o">&gt;=</span> <span class="n">images</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">sc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sc</span> <span class="o">&gt;=</span> <span class="n">images</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">images</span><span class="o">[</span><span class="n">sr</span><span class="o">][</span><span class="n">sc</span><span class="o">]</span> <span class="o">!=</span> <span class="n">srcColor</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="n">sr</span><span class="o">,</span><span class="n">sc</span><span class="o">)))</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="n">sr</span><span class="o">,</span><span class="n">sc</span><span class="o">));</span>
        <span class="n">images</span><span class="o">[</span><span class="n">sr</span><span class="o">][</span><span class="n">sc</span><span class="o">]</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">sr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span><span class="n">sc</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">sr</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span><span class="n">sc</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">sr</span><span class="o">,</span><span class="n">sc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">sr</span><span class="o">,</span><span class="n">sc</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>    
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="广搜-1">广搜</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">floodFill</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">image</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sc</span><span class="o">,</span> <span class="kt">int</span> <span class="n">newColor</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">currColor</span> <span class="o">=</span> <span class="n">image</span><span class="o">[</span><span class="n">sr</span><span class="o">][</span><span class="n">sc</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currColor</span> <span class="o">==</span> <span class="n">newColor</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">image</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">sr</span><span class="o">,</span> <span class="n">sc</span><span class="o">});</span>
        <span class="n">image</span><span class="o">[</span><span class="n">sr</span><span class="o">][</span><span class="n">sc</span><span class="o">]</span> <span class="o">=</span> <span class="n">newColor</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cell</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cell</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">my</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">mx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">my</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">my</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">image</span><span class="o">[</span><span class="n">mx</span><span class="o">][</span><span class="n">my</span><span class="o">]</span> <span class="o">==</span> <span class="n">currColor</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">mx</span><span class="o">,</span> <span class="n">my</span><span class="o">});</span>
                    <span class="n">image</span><span class="o">[</span><span class="n">mx</span><span class="o">][</span><span class="n">my</span><span class="o">]</span> <span class="o">=</span> <span class="n">newColor</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">image</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="743-网络延迟时间">743. 网络延迟时间</h2><p>有 n 个网络节点，标记为 1 到 n。</p><p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p><p>单源最短路，计算从源点到各点的距离，如果有INF存在，说明有到达不了的顶点，否则取距离最远的。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">networkDelayTime</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">times</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//单源最短路</span>
        <span class="kt">int</span> <span class="no">INF</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">nbrs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">nbrs</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="no">INF</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//建图</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">time</span> <span class="o">:</span> <span class="n">times</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">time</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">time</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">time</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="n">nbrs</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="no">INF</span><span class="o">);</span>
        <span class="n">dist</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="n">dist</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="c1">//找出一个距离k最近的顶点</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">u</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">u</span><span class="o">])){</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">visited</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">dist</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">nbrs</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">dist</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">res</span> <span class="o">==</span> <span class="no">INF</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">res</span><span class="o">;</span>
        
    <span class="o">}</span>
    

<span class="o">}</span>


</pre></table></code></div></div><h2 id="752-打开转盘锁">752. 打开转盘锁</h2><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">deadends</span> <span class="o">=</span> <span class="o">[</span><span class="s">"0201"</span><span class="o">,</span><span class="s">"0101"</span><span class="o">,</span><span class="s">"0102"</span><span class="o">,</span><span class="s">"1212"</span><span class="o">,</span><span class="s">"2002"</span><span class="o">],</span> <span class="n">target</span> <span class="o">=</span> <span class="s">"0202"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">可能的移动序列为</span> <span class="s">"0000"</span> <span class="o">-&gt;</span> <span class="s">"1000"</span> <span class="o">-&gt;</span> <span class="s">"1100"</span> <span class="o">-&gt;</span> <span class="s">"1200"</span> <span class="o">-&gt;</span> <span class="s">"1201"</span> <span class="o">-&gt;</span> <span class="s">"1202"</span> <span class="o">-&gt;</span> <span class="s">"0202"</span><span class="err">。</span>
<span class="n">注意</span> <span class="s">"0000"</span> <span class="o">-&gt;</span> <span class="s">"0001"</span> <span class="o">-&gt;</span> <span class="s">"0002"</span> <span class="o">-&gt;</span> <span class="s">"0102"</span> <span class="o">-&gt;</span> <span class="s">"0202"</span> <span class="n">这样的序列是不能解锁的</span><span class="err">，</span>
<span class="n">因为当拨动到</span> <span class="s">"0102"</span> <span class="n">时这个锁就会被锁定</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">openLock</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">deadends</span><span class="o">,</span> <span class="nc">String</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="s">"0000"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">target</span><span class="o">))</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//初始为0000，目标数字为target，从初始到目标的状态不能出现在deadends中</span>
        <span class="c1">//每次只能转动一位位置，并且只能+1或者-1</span>
        <span class="c1">//两个状态相邻：只能在某一位上相差1，其余位必须相同</span>
        <span class="c1">//那么搜索的时候有这些情况：在4个位置选一位执行+1或者-1操作。</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span> <span class="o">:</span> <span class="n">deadends</span><span class="o">){</span>
            <span class="n">dead</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">dead</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"0000"</span><span class="o">))</span>   <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"0000"</span><span class="o">);</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"0000"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//广度优先搜索：搜索到的就是最小步数</span>
        <span class="c1">//遍历当前状态的所有邻状态</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="o">++</span><span class="n">step</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">String</span> <span class="n">status</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nxtStatusList</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
                <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">nxtStatus</span> <span class="o">:</span> <span class="n">nxtStatusList</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nxtStatus</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dead</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nxtStatus</span><span class="o">)){</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">nxtStatus</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">target</span><span class="o">))</span>    <span class="k">return</span> <span class="n">step</span><span class="o">;</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nxtStatus</span><span class="o">);</span>
                        <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nxtStatus</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">(</span><span class="nc">String</span> <span class="n">status</span><span class="o">){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">status</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">num</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">==</span> <span class="sc">'9'</span> <span class="o">?</span> <span class="sc">'0'</span> <span class="o">:</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">==</span> <span class="sc">'0'</span> <span class="o">?</span> <span class="sc">'9'</span> <span class="o">:</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump763"></span></p><h2 id="763划分字母区间">763.划分字母区间</h2><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">S</span> <span class="o">=</span> <span class="s">"ababcbacadefegdehijhklij"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">划分结果为</span> <span class="s">"ababcbaca"</span><span class="o">,</span> <span class="s">"defegde"</span><span class="o">,</span> <span class="s">"hijhklij"</span><span class="err">。</span>
<span class="n">每个字母最多出现在一个片段中</span><span class="err">。</span>
<span class="n">像</span> <span class="s">"ababcbacadefegde"</span><span class="o">,</span> <span class="s">"hijhklij"</span> <span class="n">的划分是错误的</span><span class="err">，</span><span class="n">因为划分的片段数较少</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>S的长度在[1, 500]之间。</li><li>S只包含小写字母 ‘a’ 到 ‘z’ 。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">hashTable</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">partitionLabels</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="n">dfs</span><span class="o">(</span><span class="no">S</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">){</span>
      	<span class="c1">//以start为起点</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">lastIndex</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
      	<span class="c1">//找出字符串中start的最后出现位置</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">start</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">c</span><span class="o">){</span>
                <span class="n">lastIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//遍历[start, lastIndex]区间内的字符，找出区间内每个字符在S中出现的最后位置，取最大值</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lastIndex</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
          	<span class="c1">//避免重复搜索同一个字符</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hashTable</span><span class="o">[</span><span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>   <span class="k">continue</span><span class="o">;</span>
            <span class="n">hashTable</span><span class="o">[</span><span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
                  	<span class="c1">//更新lastIndex，精髓在这，lastIndex可能会变大，这样循环能够包含到扩大后的字符</span>
                    <span class="n">lastIndex</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">lastIndex</span><span class="o">,</span><span class="n">j</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
      	<span class="c1">//记录结果</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lastIndex</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
      	<span class="c1">//更新start指针</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">lastIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump765"></span></p><h2 id="765-情侣牵手">765. 情侣牵手</h2><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。</p><p>人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。</p><p>这些情侣的初始座位 row[i] 是由最初始坐在第 i 个座位上的人决定的。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="n">row</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
<span class="nl">输出:</span> <span class="mi">1</span>
<span class="nl">解释:</span> <span class="n">我们只需要交换row</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="n">和row</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="n">的位置即可</span><span class="err">。</span>
</pre></table></code></div></div><p>说明:</p><ul><li>len(row) 是偶数且数值在 [4, 60]范围内。</li><li>可以保证row 是序列 0…len(row)-1 的一个全排列。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//并查集，每对情侣作为一个顶点</span>
    <span class="c1">//情侣2,3为同一个顶点，可以用整除2标识。2/2 = 1， 3/2 = 1</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minSwapsCouples</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//相邻的组进行合并</span>
        <span class="c1">//统计连通分量的个数</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="o">){</span>
            <span class="n">union</span><span class="o">(</span><span class="n">row</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">row</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//结果就是n - 连通分量个数</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">[</span><span class="n">py</span><span class="o">]){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
            <span class="n">px</span> <span class="o">=</span> <span class="n">py</span><span class="o">;</span>
            <span class="n">py</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">size</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">py</span><span class="o">];</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">py</span><span class="o">]</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">px</span><span class="o">];</span>
        <span class="n">count</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump766"></span></p><h2 id="766-托普利茨矩阵">766. 托普利茨矩阵</h2><p>给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。</p><p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/ex1-20210222090420340.jpg" alt="img" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">matrix</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">9</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">在上述矩阵中</span><span class="o">,</span> <span class="nl">其对角线为:</span> 
<span class="s">"[9]"</span><span class="o">,</span> <span class="s">"[5, 5]"</span><span class="o">,</span> <span class="s">"[1, 1, 1]"</span><span class="o">,</span> <span class="s">"[2, 2, 2]"</span><span class="o">,</span> <span class="s">"[3, 3]"</span><span class="o">,</span> <span class="s">"[4]"</span><span class="err">。</span> 
<span class="n">各条对角线上的所有元素均相同</span><span class="o">,</span> <span class="n">因此答案是</span> <span class="nc">True</span> <span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= m, n &lt;= 20</li><li>0 &lt;= <code class="language-plaintext highlighter-rouge">matrix[i][j]</code> &lt;= 99</li></ul><p>进阶：</p><ul><li>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</li><li>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</li></ul><p>依次比较各个对角线元素</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isToeplitzMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>对于进阶问题一，一次最多只能将矩阵的一行加载到内存中，我们将每一行复制到一个连续数组中，随后在读取下一行时，就与内存中此前保存的数组进行比较。</p><p>对于进阶问题二，一次只能将不完整的一行加载到内存中，我们将整个矩阵竖直切分成若干子矩阵，并保证两个相邻的矩阵至少有一列或一行是重合的，然后判断每个子矩阵是否符合要求。</p><p><span id="jump767"></span></p><h2 id="767重构字符串">767.重构字符串</h2><p>给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p><p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="no">S</span> <span class="o">=</span> <span class="s">"aab"</span>
<span class="nl">输出:</span> <span class="s">"aba"</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="no">S</span> <span class="o">=</span> <span class="s">"aaab"</span>
<span class="nl">输出:</span> <span class="s">""</span>
</pre></table></code></div></div><p>注意:</p><ul><li>S 只包含小写字母并且长度在[1, 500]区间内。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="c1">//贪心插空填字母</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reorganizeString</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="no">S</span><span class="o">;</span>

        <span class="kt">char</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="c1">//阈值，某个字母出现的次数大于这个值，说明无法重排</span>
        <span class="kt">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">//哈希表：Hash[i][0]代表字符编号，Hash[i][1]代表字符出现次数</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">hash</span><span class="o">[</span><span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)-</span><span class="sc">'a'</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="n">hash</span><span class="o">[</span><span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">][</span><span class="mi">1</span><span class="o">]++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hash</span><span class="o">[</span><span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>   <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//按字符出现次数升序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="c1">//插空填</span>
        <span class="c1">//先排偶数位</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">hash</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">hash</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">);</span>
                    <span class="n">cur</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
                    <span class="n">hash</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]--;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//再排奇数位</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">hash</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">hash</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">);</span>
                    <span class="n">cur</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
                    <span class="n">hash</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]--;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump771"></span></p><h2 id="771宝石与石头">771.宝石与石头</h2><p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="no">J</span> <span class="o">=</span> <span class="s">"aA"</span><span class="o">,</span> <span class="no">S</span> <span class="o">=</span> <span class="s">"aAAbbbb"</span>
<span class="nl">输出:</span> <span class="mi">3</span>
</pre></table></code></div></div><p>示例 2:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="no">J</span> <span class="o">=</span> <span class="s">"z"</span><span class="o">,</span> <span class="no">S</span> <span class="o">=</span> <span class="s">"ZZ"</span>
<span class="nl">输出:</span> <span class="mi">0</span>
</pre></table></code></div></div><p>注意:</p><ul><li>S 和 J 最多含有50个字母。</li><li>J 中的字符不重复。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="no">J</span><span class="o">,</span> <span class="nc">String</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">lenS</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lenS</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="no">J</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lenS</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">Character</span> <span class="n">c</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="no">J</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="n">cnt</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="802-找到最终的安全状态">802. 找到最终的安全状态</h2><p>在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。</p><p>对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。</p><p>返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。</p><p>该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">graph</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">5</span><span class="o">],[</span><span class="mi">0</span><span class="o">],[</span><span class="mi">5</span><span class="o">],[],[]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">eventualSafeNodes</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//无论每一步选择沿哪条有向边行走，最后`必然在有限步内到达终点，则将该起始节点称作是 安全 的。</span>
        <span class="c1">//graph[i]中的节点j，表示存在从i到j的一条有向边。</span>
        <span class="c1">//首先节点要有到达终点的路径，其次该节点的所有路径都能到达终点</span>
        <span class="c1">//终点就是出度为0的顶点</span>
        <span class="c1">//如果有环的话，那肯定不是安全的</span>
        <span class="c1">//只要一个顶点不处于环中，那就是安全的</span>
        <span class="c1">//从每个顶点出发，如果有环，那就把这条路径上的节点都着色为不安全。</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">color</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">color</span><span class="o">,</span> <span class="n">i</span><span class="o">)){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//状态0表示未访问，状态1表示正在标记，状态2表示安全</span>
    <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">g</span><span class="o">,</span><span class="kt">int</span><span class="o">[]</span> <span class="n">color</span><span class="o">,</span> <span class="kt">int</span> <span class="n">u</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">color</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">color</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">color</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="o">[</span><span class="n">u</span><span class="o">]){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">dfs</span><span class="o">(</span><span class="n">g</span><span class="o">,</span><span class="n">color</span><span class="o">,</span> <span class="n">v</span><span class="o">)){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">color</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump830"></span></p><h2 id="830-较大分组的位置">830. 较大分组的位置</h2><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p><p>分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</p><p>找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abbxxxxzzy"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span><span class="s">"xxxx"</span> <span class="n">是一个起始于</span> <span class="mi">3</span> <span class="n">且终止于</span> <span class="mi">6</span> <span class="n">的较大分组</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abc"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[]</span>
<span class="n">解释</span><span class="err">：</span><span class="s">"a"</span><span class="o">,</span><span class="s">"b"</span> <span class="n">和</span> <span class="s">"c"</span> <span class="n">均不是符合要求的较大分组</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abcdddeeeeaabbbcd"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">],[</span><span class="mi">12</span><span class="o">,</span><span class="mi">14</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">较大分组为</span> <span class="s">"ddd"</span><span class="o">,</span> <span class="s">"eeee"</span> <span class="n">和</span> <span class="s">"bbb"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 1000</li><li>s 仅含小写英文字母</li></ul><p>双指针</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">largeGroupPositions</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>

            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="c1">//固定左指针，移动右指针找相同字符的最大个数</span>
            <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">l</span><span class="o">]){</span>
                <span class="n">cnt</span><span class="o">++;</span>
                <span class="n">r</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">//如果最大个数大于等于3，说明属于一个分组</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">){</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump832"></span></p><h2 id="832-翻转图像">832. 翻转图像</h2><p>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。</p><p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。</p><p>反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span><span class="nl">首先翻转每一行:</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span><span class="err">；</span>
     <span class="nl">然后反转图片:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
</pre></table></code></div></div><p><strong>提示：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">1 &lt;= A.length = A[0].length &lt;= 20</code></li><li><code class="language-plaintext highlighter-rouge">0 &lt;= A[i][j] &lt;= 1</code></li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">flipAndInvertImage</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">^=</span> <span class="mi">1</span><span class="o">;</span><span class="c1">//异或1，取反</span>
            <span class="o">}</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">A</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump834"></span></p><h2 id="834树中距离之和tag">834.树中距离之和[tag]</h2><p>给定一个无向、连通的树。树中有 N 个标记为 0…N-1 的节点以及 N-1 条边 。</p><p>第 i 条边连接节点 <code class="language-plaintext highlighter-rouge">edges[i][0]</code> 和<code class="language-plaintext highlighter-rouge"> edges[i][1]</code> 。</p><p>返回一个表示节点 i 与其他所有节点距离之和的列表 ans。</p><p>示例 1:</p><p>输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] 输出: [8,12,6,10,10,10] 解释: 如下为给定的树的示意图：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  <span class="mi">0</span>
 <span class="o">/</span> <span class="err">\</span>
<span class="mi">1</span>   <span class="mi">2</span>
   <span class="o">/|</span><span class="err">\</span>
  <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span>
</pre></table></code></div></div><p>我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。</p><ul><li>说明: 1 &lt;= N &lt;= 10000</li></ul><p>树形DP，<a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/">参考</a></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//nodeSum[i]表示以i为根节点的子树的子节点个数</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nodeSum</span><span class="o">;</span>
    <span class="c1">//distSum[i]表示以i为根节点的子树的距离之和</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">distSum</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sumOfDistancesInTree</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//建立邻接表</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">src</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">src</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">dist</span><span class="o">);</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">dist</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">nodeSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="n">distSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="c1">//填充1</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">nodeSum</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
        <span class="c1">//后序遍历计算子树距离之和</span>
        <span class="n">postOrder</span><span class="o">(</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">);</span>
        <span class="c1">//先序遍历计算总距离之和</span>
        <span class="n">preOrder</span><span class="o">(</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">distSum</span><span class="o">;</span>
        
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">postOrder</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="o">){</span>
        <span class="c1">//获取root的所有子节点</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="c1">//遍历子节点，计算距离之和</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">child</span> <span class="o">:</span> <span class="n">children</span><span class="o">){</span>
            <span class="c1">//访问到邻接表中父节点，跳过</span>
            <span class="k">if</span><span class="o">(</span><span class="n">child</span> <span class="o">==</span> <span class="n">parent</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

            <span class="c1">//后序遍历</span>
            <span class="n">postOrder</span><span class="o">(</span><span class="n">child</span><span class="o">,</span><span class="n">root</span><span class="o">);</span>

            <span class="c1">//访问到有效的子节点</span>
            <span class="c1">//先计算nodeSum,统计子节点的个数</span>
            <span class="n">nodeSum</span><span class="o">[</span><span class="n">root</span><span class="o">]</span> <span class="o">+=</span> <span class="n">nodeSum</span><span class="o">[</span><span class="n">child</span><span class="o">];</span>
            <span class="c1">//根据nodeSum计算distSum</span>
            <span class="n">distSum</span><span class="o">[</span><span class="n">root</span><span class="o">]</span> <span class="o">+=</span> <span class="n">nodeSum</span><span class="o">[</span><span class="n">child</span><span class="o">]</span> <span class="o">+</span> <span class="n">distSum</span><span class="o">[</span><span class="n">child</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">preOrder</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="o">){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">child</span> <span class="o">:</span> <span class="n">children</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">child</span> <span class="o">==</span> <span class="n">parent</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

            <span class="n">distSum</span><span class="o">[</span><span class="n">child</span><span class="o">]</span> <span class="o">=</span> <span class="n">distSum</span><span class="o">[</span><span class="n">root</span><span class="o">]</span> <span class="o">-</span> <span class="n">nodeSum</span><span class="o">[</span><span class="n">child</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">graph</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">nodeSum</span><span class="o">[</span><span class="n">child</span><span class="o">]);</span>
            <span class="n">preOrder</span><span class="o">(</span><span class="n">child</span><span class="o">,</span><span class="n">root</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump839"></span></p><h2 id="839-相似字符串组">839. 相似字符串组</h2><p>如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p><p>例如，”tars” 和 “rats” 是相似的 (交换 0 与 2 的位置)； “rats” 和 “arts” 也是相似的，但是 “star” 不与 “tars”，”rats”，或 “arts” 相似。</p><p>总之，它们通过相似性形成了两个关联组：{“tars”, “rats”, “arts”} 和 {“star”}。注意，”tars” 和 “arts” 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p><p>给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">strs</span> <span class="o">=</span> <span class="o">[</span><span class="s">"tars"</span><span class="o">,</span><span class="s">"rats"</span><span class="o">,</span><span class="s">"arts"</span><span class="o">,</span><span class="s">"star"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">示例</span> <span class="mi">2</span><span class="err">：</span>

<span class="n">输入</span><span class="err">：</span><span class="n">strs</span> <span class="o">=</span> <span class="o">[</span><span class="s">"omv"</span><span class="o">,</span><span class="s">"ovm"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= strs.length &lt;= 100</li><li>1 &lt;= strs[i].length &lt;= 1000</li><li>sum(strs[i].length) &lt;= 2 * 104</li><li>strs[i] 只包含小写字母。</li><li>strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li></ul><p>备注：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。
</pre></table></code></div></div><p>并查集，统计连通分量数</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numSimilarGroups</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="c1">//为每个字符串编号</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isSimilar</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">])){</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//判断两个字符串是否相似，也就是只有两个字母的位置不一样，其他字母的位置都一样</span>
    <span class="kt">boolean</span> <span class="nf">isSimilar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">nums</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
                <span class="n">nums</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">[</span><span class="n">py</span><span class="o">]){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
            <span class="n">px</span> <span class="o">=</span> <span class="n">py</span><span class="o">;</span>
            <span class="n">py</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">size</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">py</span><span class="o">];</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">py</span><span class="o">]</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
        <span class="n">cnt</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump841"></span></p><h2 id="841钥匙和房间">841.钥匙和房间</h2><p>有<code class="language-plaintext highlighter-rouge"> N </code>个房间，开始时你位于 0 号房间。每个房间有不同的号码：<code class="language-plaintext highlighter-rouge">0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p><p>在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 <code class="language-plaintext highlighter-rouge">rooms[i][j] </code>由 <code class="language-plaintext highlighter-rouge">[0,1，...，N-1] </code>中的一个整数表示，其中<code class="language-plaintext highlighter-rouge"> N = rooms.length</code>。 钥匙<code class="language-plaintext highlighter-rouge"> rooms[i][j] = v </code>可以打开编号为<code class="language-plaintext highlighter-rouge"> v </code>的房间。</p><p>最初，除 0 号房间外的其余所有房间都被锁住。</p><p>你可以自由地在房间之间来回走动。</p><p>如果能进入每个房间返回 true，否则返回 false。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="o">[[</span><span class="mi">1</span><span class="o">],[</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">],[]]</span>
<span class="nl">输出:</span> <span class="kc">true</span>
<span class="nl">解释:</span>  
<span class="n">我们从</span> <span class="mi">0</span> <span class="n">号房间开始</span><span class="err">，</span><span class="n">拿到钥匙</span> <span class="mi">1</span><span class="err">。</span>
<span class="n">之后我们去</span> <span class="mi">1</span> <span class="n">号房间</span><span class="err">，</span><span class="n">拿到钥匙</span> <span class="mi">2</span><span class="err">。</span>
<span class="n">然后我们去</span> <span class="mi">2</span> <span class="n">号房间</span><span class="err">，</span><span class="n">拿到钥匙</span> <span class="mi">3</span><span class="err">。</span>
<span class="n">最后我们去了</span> <span class="mi">3</span> <span class="n">号房间</span><span class="err">。</span>
<span class="n">由于我们能够进入每个房间</span><span class="err">，</span><span class="n">我们返回</span> <span class="kc">true</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">2</span><span class="o">],[</span><span class="mi">0</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="n">我们不能进入</span> <span class="mi">2</span> <span class="n">号房间</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= rooms.length &lt;= 1000</li><li>0 &lt;= rooms[i].length &lt;= 1000</li><li>所有房间中的钥匙数量总计不超过 3000。</li></ul><p>很常规的深搜题，最近回溯做多了，导致每次递归回来都要把已访问的标记取消掉，然而这题仅仅只是一题遍历题而已，只要把所有点访问一遍就可以返回了。广搜也行。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>	<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canVisitAllRooms</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rooms</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">rooms</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">rooms</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">visited</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">rooms</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rooms</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">rooms</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
            <span class="k">return</span><span class="o">;</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nbrs</span> <span class="o">=</span> <span class="n">rooms</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbrs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nbr</span><span class="o">)){</span>
                <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nbr</span><span class="o">);</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">rooms</span><span class="o">,</span><span class="n">nbr</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="空间换时间">空间换时间</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canVisitAllRooms</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rooms</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">rooms</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">rooms</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">rooms</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">rooms</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rooms</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">cnt</span><span class="o">++;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nbrs</span> <span class="o">=</span> <span class="n">rooms</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbrs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">nbr</span><span class="o">]){</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">rooms</span><span class="o">,</span><span class="n">nbr</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>  
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>有时候不能理解leetcode的难度分类标准，有些简单题都需要费很多时间，像这种模版题却是中等题。</p><p><span id="jump842"></span></p><h2 id="842-将数组拆分成斐波那契序列">842. 将数组拆分成斐波那契序列</h2><p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p><p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p><p>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）； F.length &gt;= 3； 对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。 另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p><p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"123456579"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">123</span><span class="o">,</span><span class="mi">456</span><span class="o">,</span><span class="mi">579</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"11235813"</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">13</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"112358130"</span>
<span class="nl">输出:</span> <span class="o">[]</span>
<span class="nl">解释:</span> <span class="n">这项任务无法完成</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="s">"0123"</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">每个块的数字不能以零开头</span><span class="err">，</span><span class="n">因此</span> <span class="s">"01"</span><span class="err">，</span><span class="s">"2"</span><span class="err">，</span><span class="s">"3"</span> <span class="n">不是有效答案</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 5：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">输入:</span> <span class="s">"1101111"</span>
<span class="nl">输出:</span> <span class="o">[</span><span class="mi">110</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">111</span><span class="o">]</span>
<span class="nl">解释:</span> <span class="n">输出</span> <span class="o">[</span><span class="mi">11</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">]</span> <span class="n">也同样被接受</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= S.length &lt;= 200</li><li>字符串 S 中只含有数字。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//使用列表存储拆分出的数，回溯过程中维护该列表的元素，列表初始为空。</span>
    <span class="c1">//遍历字符串的所有可能的前缀，作为当前被拆分出的数，然后对剩余部分继续拆分，直到整个字符串拆分完毕。</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">splitIntoFibonacci</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="no">S</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">,</span> <span class="nc">String</span> <span class="no">S</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pre</span><span class="o">){</span>

        <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">long</span> <span class="n">curLong</span> <span class="o">=</span> <span class="mi">0L</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            
            <span class="c1">//除了数字0本身以外，其他情况不能以0开头</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">index</span> <span class="o">&amp;&amp;</span> <span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">curLong</span> <span class="o">=</span> <span class="n">curLong</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">(</span><span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">);</span>

            <span class="k">if</span><span class="o">(</span><span class="n">curLong</span> <span class="o">&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">curLong</span><span class="o">;</span>
            <span class="c1">//只有当列表长度大于等于2时才开始比较</span>
            <span class="k">if</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">sum</span><span class="o">){</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;</span> <span class="n">sum</span><span class="o">){</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="no">S</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">pre</span> <span class="o">+</span> <span class="n">cur</span><span class="o">,</span> <span class="n">cur</span><span class="o">)){</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//回溯</span>
                <span class="n">res</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>    
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><span id="844"></span></p><h2 id="844比较含退格的字符串">844.比较含退格的字符串</h2><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p><p>注意：如果对空文本输入退格字符，文本继续为空。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">S</span> <span class="o">=</span> <span class="s">"ab#c"</span><span class="o">,</span> <span class="no">T</span> <span class="o">=</span> <span class="s">"ad#c"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="no">S</span> <span class="n">和</span> <span class="no">T</span> <span class="n">都会变成</span> <span class="err">“</span><span class="n">ac</span><span class="err">”。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">S</span> <span class="o">=</span> <span class="s">"ab##"</span><span class="o">,</span> <span class="no">T</span> <span class="o">=</span> <span class="s">"c#d#"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="no">S</span> <span class="n">和</span> <span class="no">T</span> <span class="n">都会变成</span> <span class="err">“”。</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">S</span> <span class="o">=</span> <span class="s">"a##c"</span><span class="o">,</span> <span class="no">T</span> <span class="o">=</span> <span class="s">"#a#c"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="no">S</span> <span class="n">和</span> <span class="no">T</span> <span class="n">都会变成</span> <span class="err">“</span><span class="n">c</span><span class="err">”。</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">S</span> <span class="o">=</span> <span class="s">"a#c"</span><span class="o">,</span> <span class="no">T</span> <span class="o">=</span> <span class="s">"b"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="no">S</span> <span class="n">会变成</span> <span class="err">“</span><span class="n">c</span><span class="err">”，</span><span class="n">但</span> <span class="no">T</span> <span class="n">仍然是</span> <span class="err">“</span><span class="n">b</span><span class="err">”。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= S.length &lt;= 200</li><li>1 &lt;= T.length &lt;= 200</li><li>S 和 T 只含有小写字母以及字符 ‘#’。</li></ul><p>进阶：</p><ul><li>你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？</li></ul><p>从后往前移动，依次消除退格</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="cm">/*
执行用时：1 ms, 在所有 Java 提交中击败了96.52%的用户
内存消耗：36.3 MB, 在所有 Java 提交中击败了99.82%的用户
*/</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">backspaceCompare</span><span class="o">(</span><span class="nc">String</span> <span class="no">S</span><span class="o">,</span> <span class="nc">String</span> <span class="no">T</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">iS</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">iT</span> <span class="o">=</span> <span class="no">T</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cS</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cT</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//从后往前移动</span>
        <span class="k">while</span><span class="o">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">iT</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="c1">//如果当前字符为退格，就计数</span>
            <span class="k">if</span><span class="o">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">iS</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">){</span>
                <span class="n">cS</span><span class="o">++;</span>
                <span class="n">iS</span><span class="o">--;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">iT</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="no">T</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">iT</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">){</span>
                <span class="n">cT</span><span class="o">++;</span>
                <span class="n">iT</span><span class="o">--;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//把退格消耗掉，一个一个消耗，因为可能会继续有退格出现导致cS\cT变大</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">cS</span><span class="o">--;</span>
                <span class="n">iS</span><span class="o">--;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cT</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">cT</span><span class="o">--;</span>
                <span class="n">iT</span><span class="o">--;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//iS和iT都合法，就判断当前字符是否相等，不相等返回flase</span>
            <span class="k">if</span><span class="o">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">iS</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'#'</span> 
            <span class="o">&amp;&amp;</span> <span class="n">iT</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="no">T</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">iT</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">'#'</span> 
            <span class="o">&amp;&amp;</span> <span class="no">S</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">iS</span><span class="o">)</span> <span class="o">!=</span> <span class="no">T</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">iT</span><span class="o">)){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//iS和iT有一者非法，返回false</span>
            <span class="k">if</span><span class="o">((</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iT</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">iS</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iT</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//二者都合法，并且当前字符相等，就递减</span>
            <span class="o">--</span><span class="n">iS</span><span class="o">;</span>
            <span class="o">--</span><span class="n">iT</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//循环结束，没有出现不相等的情况，就返回true</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump845"></span></p><h2 id="845数组中的最长山脉">845.数组中的最长山脉</h2><p>我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：</p><p>B.length &gt;= 3 存在 0 &lt; i &lt; B.length - 1 使得 B[0] &lt; B[1] &lt; … B[i-1] &lt; B[i] &gt; B[i+1] &gt; … &gt; B[B.length - 1] （注意：B 可以是 A 的任意子数组，包括整个数组 A。）</p><p>给出一个整数数组 A，返回最长 “山脉” 的长度。</p><p>如果不含有 “山脉” 则返回 0。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：</span><span class="n">最长的</span> <span class="err">“</span><span class="n">山脉</span><span class="err">”</span> <span class="n">是</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span><span class="err">，</span><span class="n">长度为</span> <span class="mi">5</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">0</span>
<span class="n">解释</span><span class="err">：</span><span class="n">不含</span> <span class="err">“</span><span class="n">山脉</span><span class="err">”。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= A.length &lt;= 10000</li><li>0 &lt;= A[i] &lt;= 10000</li></ul><p>找到山顶，再中心扩展。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="cm">/*
执行用时：2 ms, 在所有 Java 提交中击败了99.84%的用户
内存消耗：39.5 MB, 在所有 Java 提交中击败了87.43%的用户
*/</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestMountain</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="c1">//找到一个符合要求的山顶</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="no">A</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]){</span>
                <span class="c1">//中心扩展</span>
                <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
              	<span class="c1">//向左扩展山脉</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="no">A</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="n">cnt</span><span class="o">++;</span>
                    <span class="n">cur</span><span class="o">--;</span>
                <span class="o">}</span>
              	<span class="c1">//向右扩展山脉</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="no">A</span><span class="o">[</span><span class="n">cur</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="n">cnt</span><span class="o">++;</span>
                    <span class="n">cur</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">cnt</span><span class="o">,</span><span class="n">max</span><span class="o">);</span>
            <span class="o">}</span>
          	<span class="c1">//更新index到这座山的右边山脚，减少迭代过程</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="852-山脉数组的峰顶索引">852. 山脉数组的峰顶索引</h2><p>符合下列属性的数组 arr 称为 山脉数组 ： arr.length &gt;= 3 存在 i（0 &lt; i &lt; arr.length - 1）使得： arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i] arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1] 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。</p><p>二分法找山顶：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peakIndexInMountainArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//二分法</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="o">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump860"></span></p><h2 id="860-柠檬水找零">860. 柠檬水找零</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">前</span> <span class="mi">3</span> <span class="n">位顾客那里</span><span class="err">，</span><span class="n">我们按顺序收取</span> <span class="mi">3</span> <span class="n">张</span> <span class="mi">5</span> <span class="n">美元的钞票</span><span class="err">。</span>
<span class="n">第</span> <span class="mi">4</span> <span class="n">位顾客那里</span><span class="err">，</span><span class="n">我们收取一张</span> <span class="mi">10</span> <span class="n">美元的钞票</span><span class="err">，</span><span class="n">并返还</span> <span class="mi">5</span> <span class="n">美元</span><span class="err">。</span>
<span class="n">第</span> <span class="mi">5</span> <span class="n">位顾客那里</span><span class="err">，</span><span class="n">我们找还一张</span> <span class="mi">10</span> <span class="n">美元的钞票和一张</span> <span class="mi">5</span> <span class="n">美元的钞票</span><span class="err">。</span>
<span class="n">由于所有客户都得到了正确的找零</span><span class="err">，</span><span class="n">所以我们输出</span> <span class="kc">true</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">前</span> <span class="mi">2</span> <span class="n">位顾客那里</span><span class="err">，</span><span class="n">我们按顺序收取</span> <span class="mi">2</span> <span class="n">张</span> <span class="mi">5</span> <span class="n">美元的钞票</span><span class="err">。</span>
<span class="n">对于接下来的</span> <span class="mi">2</span> <span class="n">位顾客</span><span class="err">，</span><span class="n">我们收取一张</span> <span class="mi">10</span> <span class="n">美元的钞票</span><span class="err">，</span><span class="n">然后返还</span> <span class="mi">5</span> <span class="n">美元</span><span class="err">。</span>
<span class="n">对于最后一位顾客</span><span class="err">，</span><span class="n">我们无法退回</span> <span class="mi">15</span> <span class="n">美元</span><span class="err">，</span><span class="n">因为我们现在只有两张</span> <span class="mi">10</span> <span class="n">美元的钞票</span><span class="err">。</span>
<span class="n">由于不是每位顾客都得到了正确的找零</span><span class="err">，</span><span class="n">所以答案是</span> <span class="kc">false</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= bills.length &lt;= 10000</li><li>bills[i] 不是 5 就是 10 或是 20</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">lemonadeChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">bills</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">bills</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">five</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ten</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bills</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>

            <span class="k">if</span><span class="o">(</span><span class="n">bills</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">5</span><span class="o">){</span>
                <span class="n">five</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">bills</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">10</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">five</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">five</span><span class="o">--;</span>
                    <span class="n">ten</span><span class="o">++;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span><span class="o">(</span><span class="n">bills</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">20</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">five</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ten</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">ten</span><span class="o">--;</span>
                    <span class="n">five</span><span class="o">--;</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">ten</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">five</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">){</span>
                    <span class="n">five</span> <span class="o">-=</span> <span class="mi">3</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump861"></span></p><h2 id="861翻转矩阵后的得分">861.翻转矩阵后的得分</h2><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p><p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p><p>返回尽可能高的分数。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">39</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">转换为</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="mb">0b1111</span> <span class="o">+</span> <span class="mb">0b1001</span> <span class="o">+</span> <span class="mb">0b1111</span> <span class="o">=</span> <span class="mi">15</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">=</span> <span class="mi">39</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 20</li><li>1 &lt;= A[0].length &lt;= 20</li><li><code class="language-plaintext highlighter-rouge">A[i][j]</code> 是 0 或 1</li></ul><p>贪心策略，最高位全部为1，剩余情况1越多越好</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">matrixScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//最高位为0的行都翻转一遍</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                    <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="c1">//从第二列开始，遍历每一列，0比1多的列都翻转一遍</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="o">)</span>    <span class="k">continue</span><span class="o">;</span>
            <span class="c1">//翻转此列</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//读取数字</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">num</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="863-二叉树中所有距离为-k-的结点">863. 二叉树中所有距离为 K 的结点</h2><p>给定一个二叉树（具有根结点 <code class="language-plaintext highlighter-rouge">root</code>）， 一个目标结点 <code class="language-plaintext highlighter-rouge">target</code> ，和一个整数值 <code class="language-plaintext highlighter-rouge">K</code> 。</p><p>返回到目标结点 <code class="language-plaintext highlighter-rouge">target</code> 距离为 <code class="language-plaintext highlighter-rouge">K</code> 的所有结点的值的列表。 答案可以以任何顺序返回。</p><p>建图，然后BFS即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">distanceK</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//用BFS做</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nbr</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">nbr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nbr_right</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
                <span class="n">nbr_right</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">nbr_right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">nbr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nbr_left</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
                <span class="n">nbr_left</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">nbr_left</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">nbr</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">target</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">bfs</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">k</span><span class="o">--;</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="nc">Integer</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">for</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">nbr</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">v</span><span class="o">)){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nbr</span><span class="o">))</span>   <span class="k">continue</span><span class="o">;</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nbr</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump867"></span></p><h2 id="867-转置矩阵">867. 转置矩阵</h2><p>给你一个二维整数数组 <code class="language-plaintext highlighter-rouge">matrix</code>， 返回 <code class="language-plaintext highlighter-rouge">matrix</code> 的 <strong>转置矩阵</strong> 。</p><p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">matrix</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">matrix</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= m, n &lt;= 1000</li><li>1 &lt;= m * n &lt;= 105</li><li>-109 &lt;= <code class="language-plaintext highlighter-rouge">matrix[i][j]</code> &lt;= 109</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">transpose</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump888"></span></p><h2 id="888-公平的糖果棒交换">888. 公平的糖果棒交换</h2><p>爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。</p><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</p><p>返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。</p><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">A</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="no">B</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>1 &lt;= B.length &lt;= 10000</li><li>1 &lt;= A[i] &lt;= 100000</li><li>1 &lt;= B[i] &lt;= 100000</li><li>保证爱丽丝与鲍勃的糖果总量不同。</li><li>答案肯定存在。</li></ul><p>哈希表</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">fairCandySwap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">B</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sumA</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sumB</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">setB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">:</span> <span class="no">A</span><span class="o">){</span>
            <span class="n">sumA</span> <span class="o">+=</span> <span class="n">a</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">:</span> <span class="no">B</span><span class="o">){</span>
            <span class="n">sumB</span> <span class="o">+=</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">setB</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">:</span> <span class="no">A</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">sumB</span> <span class="o">-</span> <span class="n">sumA</span><span class="o">)/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">setB</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">key</span><span class="o">)){</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">a</span><span class="o">,</span> <span class="n">key</span><span class="o">};</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump896"></span></p><h2 id="896-单调数列">896. 单调数列</h2><p>如果数组是单调递增或单调递减的，那么它是单调的。</p><p>如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。</p><p>当给定的数组 A 是单调数组时返回 true，否则返回 false。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 50000</li><li>-100000 &lt;= A[i] &lt;= 100000</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMonotonic</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">cur</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">!=</span> <span class="no">A</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span><span class="c1">//找到决定单调方向的数对</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">-</span> <span class="no">A</span><span class="o">[</span><span class="n">cur</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(;</span> <span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">cur</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">flag</span> <span class="o">*</span> <span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">-</span> <span class="no">A</span><span class="o">[</span><span class="n">cur</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump922"></span></p><h2 id="922按奇偶排序数组-ii">922.按奇偶排序数组 II</h2><p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p><p>你可以返回任何满足上述条件的数组作为答案。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span><span class="err">，</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span><span class="err">，</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="n">也会被接受</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>2 &lt;= A.length &lt;= 20000</li><li>A.length % 2 == 0</li><li>0 &lt;= A[i] &lt;= 1000</li></ul><p>双指针：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParityII</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//每找到一个偶数位上的奇数，就移动指针j，使其找到奇数位上的第一个偶数，交换</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="no">A</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">swap</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">A</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="no">A</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>   
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>辅助数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParityII</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cur_o</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cur_e</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur_o</span><span class="o">]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">cur_o</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur_e</span><span class="o">]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">cur_e</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Golang:</p><div class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">sortArrayByParityII</span><span class="p">(</span><span class="n">A</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="n">j</span> <span class="o">:=</span> <span class="m">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="m">2</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="m">2</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="m">2</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="m">2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">A</span>
<span class="p">}</span>
</pre></table></code></div></div><p><span id="jump925"></span></p><h2 id="925长按键入">925.长按键入</h2><p>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。</p><p>你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">name</span> <span class="o">=</span> <span class="s">"alex"</span><span class="o">,</span> <span class="n">typed</span> <span class="o">=</span> <span class="s">"aaleex"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：'</span><span class="n">alex</span><span class="err">'</span> <span class="n">中的</span> <span class="sc">'a'</span> <span class="n">和</span> <span class="sc">'e'</span> <span class="n">被长按</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">name</span> <span class="o">=</span> <span class="s">"saeed"</span><span class="o">,</span> <span class="n">typed</span> <span class="o">=</span> <span class="s">"ssaaedd"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
<span class="n">解释</span><span class="err">：</span><span class="sc">'e'</span> <span class="n">一定需要被键入两次</span><span class="err">，</span><span class="n">但在</span> <span class="n">typed</span> <span class="n">的输出中不是这样</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">name</span> <span class="o">=</span> <span class="s">"leelee"</span><span class="o">,</span> <span class="n">typed</span> <span class="o">=</span> <span class="s">"lleeelee"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">name</span> <span class="o">=</span> <span class="s">"laiden"</span><span class="o">,</span> <span class="n">typed</span> <span class="o">=</span> <span class="s">"laiden"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">长按名字中的字符并不是必要的</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>name.length &lt;= 1000</li><li>typed.length &lt;= 1000</li><li>name 和 typed 的字符都是小写字母。</li></ul><p>逆序遍历判断即可，出现不相等的字符，就判断是否是长按造成的，注意边界判断。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLongPressedName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">typed</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">typed</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ptr2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ptr2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//从后往前遍历</span>
        <span class="k">while</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ptr2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr1</span><span class="o">)</span> <span class="o">==</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr2</span><span class="o">)){</span>
                <span class="o">--</span><span class="n">ptr1</span><span class="o">;</span>
                <span class="o">--</span><span class="n">ptr2</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//最后一个字符就不相等了，肯定不可能是长按造成的</span>
                <span class="k">if</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">==</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="c1">//不相等的不是最后一个字符，那么需要判断这个字符是否被长按了</span>
                <span class="c1">//与后面那个字符相等，说明有可能是长按了</span>
                <span class="k">if</span><span class="o">(</span><span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr2</span><span class="o">)</span> <span class="o">==</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)){</span>
                    <span class="n">ptr2</span><span class="o">--;</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//如果不是长按多出的字符，那么就不匹配</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//匹配结束，如果ptr1&lt;0，则判断ptr2剩余字符是否都是与name.charAt(0)相同的字符，如果是，就返回true，否则就false</span>
        <span class="k">if</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">ptr2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">!=</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">ptr2</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">ptr2</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="930-和相同的二元子数组">930. 和相同的二元子数组</h2><p>给你一个二元数组 <code class="language-plaintext highlighter-rouge">nums</code> ，和一个整数 <code class="language-plaintext highlighter-rouge">goal</code> ，请你统计并返回有多少个和为 <code class="language-plaintext highlighter-rouge">goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="n">goal</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">如下面黑体所示</span><span class="err">，</span><span class="n">有</span> <span class="mi">4</span> <span class="n">个满足题目要求的子数组</span><span class="err">：</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numSubarraysWithSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">goal</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//和为xx的子数组有多少个</span>
        <span class="c1">//</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">cnt</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">goal</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">cnt</span><span class="o">[</span><span class="n">sum</span> <span class="o">-</span> <span class="n">goal</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">cnt</span><span class="o">[</span><span class="n">sum</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump941"></span></p><h2 id="941有效的山脉数组">941.有效的山脉数组</h2><p>给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。</p><p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><ul><li>A.length &gt;= 3</li><li>在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：<ul><li>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]</li><li>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</li></ul></li></ul><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p>提示：</p><ul><li>0 &lt;= A.length &lt;= 10000</li><li>0 &lt;= A[i] &lt;= 10000</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">validMountainArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">change</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      	<span class="c1">//上山</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span>  <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">++</span><span class="n">i</span><span class="o">;</span>
      	<span class="c1">//判断为何停止上山了</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
      	<span class="c1">//下山</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span>  <span class="o">++</span><span class="n">i</span><span class="o">;</span>
      	<span class="c1">//判断是否能够到山脚</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">validMountainArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">change</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">change</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span>
                <span class="n">change</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">change</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">change</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump947"></span></p><h2 id="947-移除最多的同行或同列石头">947. 移除最多的同行或同列石头</h2><p>n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p><p>如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。</p><p>给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">stones</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：</span><span class="n">一种移除</span> <span class="mi">5</span> <span class="n">块石头的方法如下所示</span><span class="err">：</span>

<span class="mi">1</span><span class="o">.</span> <span class="n">移除石头</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="err">，</span><span class="n">因为它和</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">同行</span><span class="err">。</span>
<span class="mi">2</span><span class="o">.</span> <span class="n">移除石头</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="err">，</span><span class="n">因为它和</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">同列</span><span class="err">。</span>
<span class="mi">3</span><span class="o">.</span> <span class="n">移除石头</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="err">，</span><span class="n">因为它和</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="n">同行</span><span class="err">。</span>
<span class="mi">4</span><span class="o">.</span> <span class="n">移除石头</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="err">，</span><span class="n">因为它和</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="n">同列</span><span class="err">。</span>
<span class="mi">5</span><span class="o">.</span> <span class="n">移除石头</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="err">，</span><span class="n">因为它和</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="n">同行</span><span class="err">。</span>
<span class="n">石头</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="n">不能移除</span><span class="err">，</span><span class="n">因为它没有与另一块石头同行</span><span class="o">/</span><span class="n">列</span><span class="err">。</span>
<span class="n">示例</span> <span class="mi">2</span><span class="err">：</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= stones.length &lt;= 1000</li><li>0 &lt;= xi, yi &lt;= 104</li><li>不会有两块石头放在同一个坐标点上</li></ul><p>连通在一起的石头可以被移除到只剩一个，因此这题是计算连通分量的个数。</p><p>将每个石头视作一个顶点，两个石头的坐标中x或y相等，则这两个顶点之间有边。因此可以根据此建立并查集计算连通分量。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//并查集</span>
    <span class="c1">//计算连通分量的个数</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeStones</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//n块石头视为图的n个顶点，顶点间的边关系由坐标得到，x相等或者y相等的视为两点之间有边</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">stones</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">stones</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">stones</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">stones</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">]){</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">){</span>
                <span class="n">res</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>

        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>

        <span class="n">parent</span><span class="o">[</span><span class="n">py</span><span class="o">]</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>优化：遍历每块石头与其他石头的关系时间消耗太大，我们可以将处于同一行或者同一列的石头视为连通的，因此我们可以将行数或者列数作为parent。</p><p>但是行数和列数可能会重叠，如坐标(2,2)行数和列数是相同的。观察到坐标范围在1到10000之间，所以我们可以将x或y的坐标映射到其他区间内，这样就能错开行列了。</p><p>同时行和列可能是稀疏分布的，因此要用Map替代数组实现并查集。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//并查集</span>
    <span class="c1">//计算连通分量的个数</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeStones</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">//n块石头视为图的n个顶点，顶点间的边关系由坐标得到，x相等或者y相等的视为两点之间有边</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">union</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">stones</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">stones</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">10001</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>

        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
        <span class="c1">//两个节点需要合并，那么count需要减1</span>
        <span class="n">parent</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">py</span><span class="o">,</span> <span class="n">px</span><span class="o">);</span>
        <span class="n">count</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">parent</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">idx</span><span class="o">)){</span><span class="c1">//并查集中没有这个节点，就计数并放入并查集</span>
            <span class="n">parent</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">idx</span><span class="o">);</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">parent</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">idx</span><span class="o">)));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump959"></span></p><h2 id="959-由斜杠划分区域">959. 由斜杠划分区域</h2><p>在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。</p><p>（请注意，反斜杠字符是转义的，因此 \ 用 “\” 表示。）。</p><p>返回区域的数目。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
<span class="o">[</span>
<span class="err"> </span> <span class="s">"/\\"</span><span class="o">,</span>
<span class="err"> </span> <span class="s">"\\/"</span>
<span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：（</span><span class="n">回想一下</span><span class="err">，</span><span class="n">因为</span> <span class="err">\</span> <span class="n">字符是转义的</span><span class="err">，</span><span class="n">所以</span> <span class="s">"/\\"</span> <span class="n">表示</span> <span class="o">/</span><span class="err">\，</span><span class="n">而</span> <span class="s">"\\/"</span> <span class="n">表示</span> <span class="err">\</span><span class="o">/</span><span class="err">。</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/4-20210125091530059.png" alt="img" /></p><p>并查集，将一个网格划分为4个区域</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210125091558094.png" alt="image-20210125091558094" /></p><p>然后遍历一次二维网格数组，在网格内以及网格之间进行合并。</p><p><strong>单元格内</strong>：</p><ul><li>如果是空格：合并 0、1、2、3；</li><li>如果是斜杠：合并 0、3，合并 1、2；</li><li>如果是反斜杠：合并 0、1，合并 2、3。</li></ul><p><strong>单元格间</strong>：</p><p>我们选择在遍历 <code class="language-plaintext highlighter-rouge">grid</code> 的每一个单元格的时候，分别向右、向下尝试合并。</p><ul><li>向右：合并 1 （当前单元格）和 3（当前单元格右边 1 列的单元格）</li><li>向下：合并 2 （当前单元格）和 0（当前单元格下边 1 列的单元格）</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">regionsBySlashes</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//并查集顶点个数</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="no">N</span> <span class="o">*</span> <span class="no">N</span><span class="o">;</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//网格内合并</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toCharArray</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="c1">//将在二维中的每个网格映射到一维</span>
                <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="no">N</span> <span class="o">+</span> <span class="n">j</span><span class="o">);</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span><span class="o">){</span>
                    <span class="c1">//合并0，3以及1，2</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">3</span><span class="o">);</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'\\'</span><span class="o">){</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">3</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">);</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">3</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">//网格间合并</span>
                <span class="c1">//向右合并</span>
                <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">){</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="no">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">){</span>
                    <span class="n">union</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="o">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="no">N</span> <span class="o">+</span> <span class="n">j</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">[</span><span class="n">py</span><span class="o">]){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
            <span class="n">px</span> <span class="o">=</span> <span class="n">py</span><span class="o">;</span>
            <span class="n">py</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">size</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">py</span><span class="o">];</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">py</span><span class="o">]</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
        <span class="n">cnt</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump968"></span></p><h2 id="968监控二叉树">968.监控二叉树</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例1：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
<span class="n">解释</span><span class="err">：</span><span class="n">如图所示</span><span class="err">，</span><span class="n">一台摄像头足以监控所有节点</span><span class="err">。</span>
</pre></table></code></div></div><p>示例2:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span><span class="n">需要至少两个摄像头来监视树的所有节点</span><span class="err">。</span> <span class="n">上图显示了摄像头放置的有效位置之一</span><span class="err">。</span>
</pre></table></code></div></div><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code class="language-plaintext highlighter-rouge">[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><p>思路：</p><p>假设节点有3种状态：1.节点已被覆盖，2.节点未被覆盖，3.节点上有相机。每个节点的状态由两个子节点的状态推出。</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">1.</span> 若两个节点至少有一个未被覆盖，当前节点必须装相机。
<span class="p">2.</span> 若两个节点都已经被覆盖，则当前节点就不一定需要装相机，就设置为为覆盖，交由父节点处理。
<span class="p">3.</span> 若其中一个子节点有相机，就设置当前节点为已覆盖
</pre></table></code></div></div><p>由于需要知道两个子节点的状态才能决定当前节点的状态，所以采用后序遍历。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minCameraCover</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">if</span><span class="o">(</span><span class="n">backOrder</span><span class="o">(</span><span class="n">root</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
            <span class="n">res</span><span class="o">++;</span>
         <span class="o">}</span>
         <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//节点有三种状态：1.节点已被覆盖，2.节点未被覆盖，3.节点上有相机</span>
    <span class="kt">int</span> <span class="nf">backOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">backOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">backOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="c1">//两个节点至少有一个没有被覆盖</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">right</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
            <span class="n">res</span><span class="o">++;</span>
            <span class="k">return</span> <span class="mi">3</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//两个节点已经被覆盖，那这个节点就不一定需要装相机了</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">right</span> <span class="o">==</span> <span class="mi">3</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump973"></span></p><h2 id="973最接近原点的-k-个点">973.最接近原点的 K 个点</h2><p>我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。</p><p>（这里，平面上两点之间的距离是欧几里德距离。）</p><p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]],</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span> 
<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">和原点之间的距离为</span> <span class="n">sqrt</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="err">，</span>
<span class="o">(-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="n">和原点之间的距离为</span> <span class="n">sqrt</span><span class="o">(</span><span class="mi">8</span><span class="o">)</span><span class="err">，</span>
<span class="n">由于</span> <span class="n">sqrt</span><span class="o">(</span><span class="mi">8</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">sqrt</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="err">，</span><span class="o">(-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="n">离原点更近</span><span class="err">。</span>
<span class="n">我们只需要距离原点最近的</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">个点</span><span class="err">，</span><span class="n">所以答案就是</span> <span class="o">[[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">5</span><span class="o">,-</span><span class="mi">1</span><span class="o">],[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]],</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">],[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]]</span>
<span class="err">（</span><span class="n">答案</span> <span class="o">[[-</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span> <span class="n">也会被接受</span><span class="err">。）</span>
</pre></table></code></div></div><p>提示：</p><ul><li><code class="language-plaintext highlighter-rouge">1 &lt;= K &lt;= points.length &lt;= 10000</code></li><li><code class="language-plaintext highlighter-rouge">-10000 &lt; points[i][0] &lt; 10000</code></li><li><code class="language-plaintext highlighter-rouge">-10000 &lt; points[i][1] &lt; 10000</code></li></ul><p>优先队列：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">kClosest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">K</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
                <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="na">getValue</span><span class="o">()){</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
        <span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="nc">Double</span> <span class="n">value</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]*</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]*</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="nc">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">K</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">key</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">key</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">Entry</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
        <span class="kt">double</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Entry</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">double</span> <span class="n">value</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="nf">getKey</span><span class="o">(){</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">double</span> <span class="nf">getValue</span><span class="o">(){</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>数组排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">kClosest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">K</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">double</span> <span class="n">value1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]*</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]*</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="kt">double</span> <span class="n">value2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]*</span><span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]*</span><span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">value1</span> <span class="o">&gt;</span> <span class="n">value2</span><span class="o">){</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">K</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>快速排序partition:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">kClosest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">random_select</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="no">K</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">K</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">random_select</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">pivotId</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">pivotId</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="n">points</span><span class="o">[</span><span class="n">pivotId</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">points</span><span class="o">[</span><span class="n">pivotId</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">points</span><span class="o">[</span><span class="n">pivotId</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">pivotId</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">i</span><span class="o">;</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="o">++</span><span class="n">i</span><span class="o">;</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="c1">// [left, i-1] 都小于等于 pivot, [i+1, right] 都大于 pivot</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">K</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">random_select</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="no">K</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="no">K</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">random_select</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="no">K</span> <span class="o">-</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">index1</span><span class="o">];</span>
        <span class="n">points</span><span class="o">[</span><span class="n">index1</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">index2</span><span class="o">];</span>
        <span class="n">points</span><span class="o">[</span><span class="n">index2</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump976"></span></p><h2 id="976三角形的最大周长">976.三角形的最大周长</h2><p>给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。</p><p>如果不能形成任何面积不为零的三角形，返回 0。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">0</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">10</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">8</span>
</pre></table></code></div></div><p>提示：</p><ul><li>3 &lt;= A.length &lt;= 10000</li><li>1 &lt;= A[i] &lt;= 10^6</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">largestPerimeter</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">A</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//两边之差A[p1] - A[p2]</span>
            <span class="kt">int</span> <span class="n">dec</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span> <span class="o">-</span> <span class="no">A</span><span class="o">[</span><span class="n">p2</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dec</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="k">return</span> <span class="no">A</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">p2</span><span class="o">]</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">p2</span><span class="o">;</span>
                <span class="n">p2</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump977"></span></p><h2 id="977有序数组的平方">977.有序数组的平方</h2><p>给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[-</span><span class="mi">4</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">100</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[-</span><span class="mi">7</span><span class="o">,-</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">11</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">49</span><span class="o">,</span><span class="mi">121</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>-10000 &lt;= A[i] &lt;= 10000</li><li>A 已按非递减顺序排序。</li></ul><p>双指针左右移动，比较绝对值的较小值，取平方依次填入新数组。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortedSquares</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//找到绝对值最小值的位置，双指针左右移</span>
        
        <span class="c1">//如果全部是非正数，那么绝对值最小值就是最后一个元素</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//当两个相邻元素的绝对值之差为负数时，说明找到了绝对值最小值</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&lt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">])){</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//双指针，初始时都在index处</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">index</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">l</span><span class="o">])</span> <span class="o">&lt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">r</span><span class="o">])){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
                <span class="n">l</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
                <span class="o">++</span><span class="n">r</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
            <span class="n">l</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
            <span class="o">++</span><span class="n">r</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump978"></span></p><h2 id="978-最长湍流子数组">978. 最长湍流子数组</h2><p>当 A 的子数组 A[i], A[i+1], …, A[j] 满足下列条件时，我们称其为湍流子数组：</p><p>若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]； 或 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。</p><p>返回 A 的最大湍流子数组的长度。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="mi">5</span><span class="o">])</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">16</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 40000</li><li>0 &lt;= A[i] &lt;= 10^9</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxTurbulenceSize</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">signal</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">*</span> <span class="n">signal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span><span class="c1">//异号，则增加湍流长度</span>
                <span class="n">cnt</span><span class="o">++;</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span><span class="c1">//同号或出现0，则截断</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">cnt</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="981-基于时间的键值存储">981. 基于时间的键值存储</h2><p>创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：</p><ol><li>set(string key, string value, int timestamp.</li></ol><ul><li>存储键 key、值 value，以及给定的时间戳 timestamp。</li></ul><ol><li>get(string key, int timestamp)</li></ol><ul><li>返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;= timestamp。</li><li>如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。</li><li>如果没有值，则返回空字符串（”“）。</li></ul><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">inputs</span> <span class="o">=</span> <span class="o">[</span><span class="s">"TimeMap"</span><span class="o">,</span><span class="s">"set"</span><span class="o">,</span><span class="s">"get"</span><span class="o">,</span><span class="s">"get"</span><span class="o">,</span><span class="s">"set"</span><span class="o">,</span><span class="s">"get"</span><span class="o">,</span><span class="s">"get"</span><span class="o">],</span> <span class="n">inputs</span> <span class="o">=</span> <span class="o">[[],[</span><span class="s">"foo"</span><span class="o">,</span><span class="s">"bar"</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="s">"foo"</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="s">"foo"</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="s">"foo"</span><span class="o">,</span><span class="s">"bar2"</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="s">"foo"</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="s">"foo"</span><span class="o">,</span><span class="mi">5</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="s">"bar"</span><span class="o">,</span><span class="s">"bar"</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="s">"bar2"</span><span class="o">,</span><span class="s">"bar2"</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span>  
<span class="nc">TimeMap</span> <span class="n">kv</span><span class="o">;</span>   
<span class="n">kv</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// 存储键 "foo" 和值 "bar" 以及时间戳 timestamp = 1   </span>
<span class="n">kv</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>  <span class="c1">// 输出 "bar"   </span>
<span class="n">kv</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// 输出 "bar" 因为在时间戳 3 和时间戳 2 处没有对应 "foo" 的值，所以唯一的值位于时间戳 1 处（即 "bar"）   </span>
<span class="n">kv</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar2"</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>   
<span class="n">kv</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span> <span class="c1">// 输出 "bar2"   </span>
<span class="n">kv</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> <span class="c1">// 输出 "bar2"   </span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">TimeMap</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">map</span><span class="o">;</span>
    <span class="cm">/** Initialize your data structure here. */</span>
    <span class="kd">public</span> <span class="nf">TimeMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    <span class="c1">//相同的key需要按照时间戳排序</span>
    <span class="c1">//&lt;key:&lt;timestamp:value&gt;&gt;</span>
    <span class="c1">//timestamps 都是严格递增的。所以不会出现timestamp重复的情况</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">String</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;());</span>
        <span class="n">tmp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">timestamp</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">tmp</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">get</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">Integer</span> <span class="n">floorKey</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">floorKey</span><span class="o">(</span><span class="n">timestamp</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">floorKey</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">floorKey</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>使用Map+List，哈希 +二分：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">TimeMap</span> <span class="o">{</span>
    <span class="kd">class</span> <span class="nc">Pair</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">timestamp</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">value</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="kt">int</span> <span class="n">timestamp</span><span class="o">,</span> <span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">timestamp</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Pair</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Pair</span> <span class="n">pair2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">timestamp</span> <span class="o">==</span> <span class="n">pair2</span><span class="o">.</span><span class="na">timestamp</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">pair2</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Pair</span> <span class="n">pair2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">timestamp</span> <span class="o">!=</span> <span class="n">pair2</span><span class="o">.</span><span class="na">timestamp</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">timestamp</span> <span class="o">-</span> <span class="n">pair2</span><span class="o">.</span><span class="na">timestamp</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">pair2</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="n">map</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">TimeMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">String</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="n">pairs</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;());</span>
        <span class="n">pairs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">timestamp</span><span class="o">,</span> <span class="n">value</span><span class="o">));</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">pairs</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">get</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="n">pairs</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;());</span>
        <span class="c1">// 使用一个大于所有 value 的字符串，以确保在 pairs 中含有 timestamp 的情况下也返回大于 timestamp 的位置</span>
        <span class="nc">Pair</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">timestamp</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="mi">127</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">pairs</span><span class="o">,</span> <span class="n">pair</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">pairs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="n">pairs</span><span class="o">,</span> <span class="nc">Pair</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">high</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pairs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">high</span><span class="o">).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">target</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">high</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">low</span><span class="o">;</span>
            <span class="nc">Pair</span> <span class="n">pair</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">target</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">low</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="987-二叉树的垂序遍历">987. 二叉树的垂序遍历</h2><p>给你二叉树的根结点 <code class="language-plaintext highlighter-rouge">root</code> ，请你设计算法计算二叉树的 <strong>垂序遍历</strong> 序列。</p><p>对位于 <code class="language-plaintext highlighter-rouge">(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code class="language-plaintext highlighter-rouge">(row + 1, col - 1)</code> 和 <code class="language-plaintext highlighter-rouge">(row + 1, col + 1)</code> 。树的根结点位于 <code class="language-plaintext highlighter-rouge">(0, 0)</code> 。</p><p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p><p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">9</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">15</span><span class="o">],[</span><span class="mi">20</span><span class="o">],[</span><span class="mi">7</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">列</span> <span class="o">-</span><span class="mi">1</span> <span class="err">：</span><span class="n">只有结点</span> <span class="mi">9</span> <span class="n">在此列中</span><span class="err">。</span>
<span class="n">列</span>  <span class="mi">0</span> <span class="err">：</span><span class="n">只有结点</span> <span class="mi">3</span> <span class="n">和</span> <span class="mi">15</span> <span class="n">在此列中</span><span class="err">，</span><span class="n">按从上到下顺序</span><span class="err">。</span>
<span class="n">列</span>  <span class="mi">1</span> <span class="err">：</span><span class="n">只有结点</span> <span class="mi">20</span> <span class="n">在此列中</span><span class="err">。</span>
<span class="n">列</span>  <span class="mi">2</span> <span class="err">：</span><span class="n">只有结点</span> <span class="mi">7</span> <span class="n">在此列中</span><span class="err">。</span>
</pre></table></code></div></div><p>将节点放入数组中，按col升序排序，col相同的按row升序，col、row相同的按value升序.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">verticalTraversal</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//将节点放入数组中，按col升序排序，col相同的按row升序，col、row相同的按value升序</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">nodes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>

        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nodes</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">!=</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">//遍历nodes，相同col的放入同一个list中</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1001</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">node</span> <span class="o">:</span> <span class="n">nodes</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">node</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="n">col</span><span class="o">){</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>


    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">nodes</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>

        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">col</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">});</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">nodes</span><span class="o">,</span> <span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">nodes</span><span class="o">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump989"></span></p><h2 id="989-数组形式的整数加法">989. 数组形式的整数加法</h2><p>对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。</p><p>给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。 示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">A</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">806</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span><span class="mi">215</span> <span class="o">+</span> <span class="mi">806</span> <span class="o">=</span> <span class="mi">1021</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">A</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">9</span><span class="o">],</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span><span class="mi">9999999999</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">10000000000</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>0 &lt;= A[i] &lt;= 9</li><li>0 &lt;= K &lt;= 10000</li><li>如果 A.length &gt; 1，那么 A[0] != 0</li></ul><p>逐位相加</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">addToArrayForm</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">while</span><span class="o">(</span><span class="no">K</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ptr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="no">K</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="o">(</span><span class="no">K</span> <span class="o">%</span> <span class="mi">10</span><span class="o">)</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">ptr</span><span class="o">--];</span>
                <span class="no">K</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="no">K</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="o">(</span><span class="no">K</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
                <span class="no">K</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">ptr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">ptr</span><span class="o">--];</span>
            <span class="o">}</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">carry</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>


        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>对于ArrayList慎用add(index, target)方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">addToArrayForm</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="no">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">,</span> <span class="no">K</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">K</span> <span class="o">+=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="no">K</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1002"></span></p><h2 id="1002查找常用字符">1002.查找常用字符</h2><p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="s">"bella"</span><span class="o">,</span><span class="s">"label"</span><span class="o">,</span><span class="s">"roller"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"e"</span><span class="o">,</span><span class="s">"l"</span><span class="o">,</span><span class="s">"l"</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="s">"cool"</span><span class="o">,</span><span class="s">"lock"</span><span class="o">,</span><span class="s">"cook"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="s">"c"</span><span class="o">,</span><span class="s">"o"</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 100</li><li>1 &lt;= A[i].length &lt;= 100</li><li><code class="language-plaintext highlighter-rouge">A[i][j] </code>是小写字母</li></ul><p>哈希表，建立数组<code class="language-plaintext highlighter-rouge">counts[26]</code>，先预存第一个字符串每个字母的哈希，统计出现次数。</p><p>再遍历剩余字符串，统计每个字符串中每个字符出现的次数，放入哈希数组<code class="language-plaintext highlighter-rouge">tmp[26]</code>中，再按如下规则更新<code class="language-plaintext highlighter-rouge">counts</code>:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">tmp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</pre></table></code></div></div><p>即统计各字符出现的最小次数。</p><p>最后将<code class="language-plaintext highlighter-rouge">counts[i]</code>映射到字符串即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">commonChars</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="c1">//预存第一个字符串每个字母的哈希，统计出现次数。</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="n">counts</span><span class="o">[</span><span class="n">index</span><span class="o">]++;</span>
        <span class="o">}</span>
        <span class="c1">//遍历剩余字符串，统计每个字符串中每个字符出现的次数，放入哈希数组tmp[26]中</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
                <span class="n">tmp</span><span class="o">[</span><span class="n">index</span><span class="o">]++;</span>
            <span class="o">}</span>
          	<span class="c1">//取最小次数</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">counts</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="n">j</span><span class="o">],</span><span class="n">tmp</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">continue</span><span class="o">;</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">i</span><span class="o">+</span><span class="mi">97</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1004"></span></p><h2 id="1004-最大连续1的个数-iii">1004. 最大连续1的个数 III</h2><p>给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。</p><p>返回仅包含 1 的最长（连续）子数组的长度。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">A</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span> 
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">粗体数字从</span> <span class="mi">0</span> <span class="n">翻转到</span> <span class="mi">1</span><span class="err">，</span><span class="n">最长的子数组长度为</span> <span class="mi">6</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">A</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">10</span>
<span class="n">解释</span><span class="err">：</span>
<span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">粗体数字从</span> <span class="mi">0</span> <span class="n">翻转到</span> <span class="mi">1</span><span class="err">，</span><span class="n">最长的子数组长度为</span> <span class="mi">10</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 20000</li><li>0 &lt;= K &lt;= A.length</li><li>A[i] 为 0 或 1</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestOnes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//滑动窗口</span>
        <span class="c1">//窗口内0的个数需要小于等于k，如果大于k，就窗口整体右移，直到数量小于等于k</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//初始化窗口</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="n">cnt</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="no">K</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">r</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
            <span class="c1">//窗口整体右移</span>
            <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="no">K</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="n">cnt</span><span class="o">--;</span>
                <span class="n">l</span><span class="o">++;</span>
                <span class="n">r</span><span class="o">++;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="no">A</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="n">cnt</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">//窗口增长</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>    <span class="n">r</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="no">A</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>   <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="no">K</span><span class="o">)</span> <span class="k">return</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1006"></span></p><h2 id="1006-笨阶乘">1006. 笨阶乘</h2><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。</p><p>相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p><p>例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p><p>另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。</p><p>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：4
输出：7
解释：7 = 4 * 3 / 2 + 1
</pre></table></code></div></div><p><strong>提示：</strong></p><ol><li><code class="language-plaintext highlighter-rouge">1 &lt;= N &lt;= 10000</code></li><li><code class="language-plaintext highlighter-rouge">-2^31 &lt;= answer &lt;= 2^31 - 1</code> （答案保证符合 32 位整数。）</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">clumsy</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
        <span class="no">N</span><span class="o">--;</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">*</span> <span class="no">N</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">/</span> <span class="no">N</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(-</span><span class="no">N</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">idx</span><span class="o">++;</span>
            <span class="no">N</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1018"></span></p><h2 id="1018-可被-5-整除的二进制前缀">1018. 可被 5 整除的二进制前缀</h2><p>给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p><p>返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="kc">true</span><span class="o">,</span><span class="kc">false</span><span class="o">,</span><span class="kc">false</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">输入数字为</span> <span class="mi">0</span><span class="o">,</span> <span class="mo">01</span><span class="o">,</span> <span class="mo">011</span><span class="err">；</span><span class="n">也就是十进制中的</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="err">。</span><span class="n">只有第一个数可以被</span> <span class="mi">5</span> <span class="n">整除</span><span class="err">，</span><span class="n">因此</span> <span class="n">answer</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">为真</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="kc">false</span><span class="o">,</span><span class="kc">false</span><span class="o">,</span><span class="kc">false</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 30000</li><li>A[i] 为 0 或 1</li></ul><p>循环左移，低位补A[i]，再循环取模。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="nf">prefixesDivBy5</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">((</span><span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">%</span> <span class="mi">5</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Boolean</span><span class="o">.</span><span class="na">TRUE</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Boolean</span><span class="o">.</span><span class="na">FALSE</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1024"></span></p><h2 id="1024视频拼接">1024.视频拼接</h2><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p><p>视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。</p><p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">clips</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">9</span><span class="o">]],</span> <span class="no">T</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">我们选中</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span> <span class="n">这三个片段</span><span class="err">。</span>
<span class="n">然后</span><span class="err">，</span><span class="n">按下面的方案重制比赛片段</span><span class="err">：</span>
<span class="n">将</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span> <span class="n">再剪辑为</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span> <span class="o">+</span> <span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span> <span class="err">。</span>
<span class="n">现在我们手上有</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span> <span class="o">+</span> <span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span><span class="err">，</span><span class="n">而这些涵盖了整场比赛</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">]</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">clips</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]],</span> <span class="no">T</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">输出</span><span class="err">：</span><span class="o">-</span><span class="mi">1</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">我们无法只用</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="n">和</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="n">覆盖</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="n">的整个过程</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">clips</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">8</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]],</span> <span class="no">T</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span> 
<span class="n">我们选取片段</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span> <span class="n">和</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span> <span class="err">。</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">clips</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">8</span><span class="o">]],</span> <span class="no">T</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">注意</span><span class="err">，</span><span class="n">你可能录制超过比赛结束时间的视频</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= clips.length &lt;= 100</li><li>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100</li><li>0 &lt;= T &lt;= 100</li></ul><p>先将片段按结束时间降序排序，再贪心选择有效持续时间最长的片段。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">videoStitching</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">clips</span><span class="o">,</span> <span class="kt">int</span> <span class="no">T</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//对数组按结束时间降序排序</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">clips</span><span class="o">,(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">//指向当前视频片段覆盖的区域开头，为T表示未被覆盖</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="no">T</span><span class="o">;</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">clips</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="c1">//按结束时间先选择片段，贪心地选择持续时间最长的</span>
        <span class="c1">//但是结束时间可能超过T</span>
        <span class="c1">//所以选择有效持续时间最长的，先判断当前片段的结束时间是否大于cur，如果成立再计算有效持续时间才有意义</span>
        <span class="c1">//有效持续时间为：cur - 开始时间</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">clips</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clips</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">clips</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="o">)</span>   <span class="k">break</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span>  <span class="k">continue</span><span class="o">;</span>
                <span class="c1">//当前片段的结束时间大于cur，且开始时间小于cur</span>
                <span class="k">if</span><span class="o">(</span><span class="n">clips</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">clips</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">-</span> <span class="n">clips</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">){</span>
                        <span class="n">max</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">-</span> <span class="n">clips</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">//没有片段符合此次覆盖要求</span>
            <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">clips</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">clips</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1030"></span></p><h2 id="1030距离顺序排列矩阵单元格">1030.距离顺序排列矩阵单元格</h2><p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。</p><p>另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。</p><div class="table-wrapper"><table><tbody><tr><td>返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，<td>r1 - r2<td>+<td>c1 - c2<td>。（你可以按任何满足此条件的顺序返回答案。）</table></div><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">R</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="no">C</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">c0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">从</span> <span class="o">(</span><span class="n">r0</span><span class="o">,</span> <span class="n">c0</span><span class="o">)</span> <span class="n">到其他单元格的距离为</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">R</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="no">C</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">c0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">从</span> <span class="o">(</span><span class="n">r0</span><span class="o">,</span> <span class="n">c0</span><span class="o">)</span> <span class="n">到其他单元格的距离为</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span> <span class="n">也会被视作正确答案</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="no">R</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="no">C</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">c0</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">从</span> <span class="o">(</span><span class="n">r0</span><span class="o">,</span> <span class="n">c0</span><span class="o">)</span> <span class="n">到其他单元格的距离为</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">其他满足题目要求的答案也会被视为正确</span><span class="err">，</span><span class="n">例如</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= R &lt;= 100</li><li>1 &lt;= C &lt;= 100</li><li>0 &lt;= r0 &lt; R</li><li>0 &lt;= c0 &lt; C</li></ul><p>直接排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">allCellsDistOrder</span><span class="o">(</span><span class="kt">int</span> <span class="no">R</span><span class="o">,</span> <span class="kt">int</span> <span class="no">C</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r0</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">R</span><span class="o">*</span><span class="no">C</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">R</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">C</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">r0</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">c0</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">r0</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">c0</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>桶排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//桶排序，由于各个节点到(r0,c0)的曼哈顿距离都是整数</span>
    <span class="c1">//所以分桶，枚举每个节点，将其填入各个桶中，最后按序读取桶即可</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">allCellsDistOrder</span><span class="o">(</span><span class="kt">int</span> <span class="no">R</span><span class="o">,</span> <span class="kt">int</span> <span class="no">C</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r0</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxDis</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">r0</span><span class="o">,</span> <span class="no">R</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">r0</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">c0</span><span class="o">,</span> <span class="no">C</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">c0</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;&gt;</span> <span class="n">buckets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxDis</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">buckets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;());</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">R</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">C</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">r0</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">c0</span><span class="o">);</span>
                <span class="n">buckets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">dist</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">R</span><span class="o">*</span><span class="no">C</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxDis</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1049-最后一块石头的重量-ii">1049. 最后一块石头的重量 II</h2><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lastStoneWeightII</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//将本问题抽象为背包问题</span>
        <span class="cm">/*
        要使得剩下的石头重量最小，那么只需要将石头分为左右两堆
        让左边的堆重量大于等于右边堆的重量，左堆减右堆
        二堆的重量越接近，那么剩下的石头越小
        记石头总重为sum，右堆重量为neg，左堆重量为sum - neg
        那么剩余的石头重量为 sum - neg - neg = sum - 2*neg
        只要sum - 2*neg最小，即可
        sum固定，neg只要尽可能大，迫近 sum/2，最优可达sum/2
        所以，我们把sum/2认为是一个背包容量，stones[i]是石头的重量
         */</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">stone</span> <span class="o">:</span> <span class="n">stones</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">stone</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">//dp[i][j]表示前i个石头能否凑出neg重量j</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">stones</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">stones</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">j</span><span class="o">]){</span>
                <span class="k">return</span> <span class="n">sum</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1052"></span></p><h2 id="1052-爱生气的书店老板">1052. 爱生气的书店老板</h2><p>今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">customers</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">grumpy</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="no">X</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">16</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">书店老板在最后</span> <span class="mi">3</span> <span class="n">分钟保持冷静</span><span class="err">。</span>
<span class="n">感到满意的最大客户数量</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">=</span> <span class="mi">16</span><span class="o">.</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</li><li>0 &lt;= customers[i] &lt;= 1000</li><li>0 &lt;= grumpy[i] &lt;= 1</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSatisfied</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">customers</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">grumpy</span><span class="o">,</span> <span class="kt">int</span> <span class="no">X</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">customers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">wSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">grumpy</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">customers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//窗口大小为X，找和最大的子窗口。窗口内只有当grumy[i]==1时，才记入总和</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">X</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">wSum</span> <span class="o">+=</span> <span class="n">grumpy</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">customers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">wSum</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">X</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">wSum</span> <span class="o">=</span><span class="n">wSum</span> <span class="o">+</span> <span class="n">grumpy</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">customers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">grumpy</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="no">X</span><span class="o">]</span> <span class="o">*</span> <span class="n">customers</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="no">X</span><span class="o">];</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">wSum</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1104-二叉树寻路">1104. 二叉树寻路</h2><p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。</p><p>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p><p>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p><p>给你树上某一个节点的标号 <code class="language-plaintext highlighter-rouge">label</code>，请你返回从根节点到该标号为 <code class="language-plaintext highlighter-rouge">label</code> 节点的路径，该路径是由途经的节点标号所组成的。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入：label = 14
输出：[1,3,4,14]
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">pathInZigZagTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">label</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//首先能定位label在第几层</span>
        <span class="c1">//知道是第几层的第几个数字，可以反推回去</span>
        <span class="c1">//比如是第4层的第2个数字，那么父节点是第3层的第1个数字</span>
        <span class="c1">//第3层的第1个数字，父节点是第2层的第1个数字</span>
        <span class="c1">//第2层的第一个数字，父节点是第1层的第1个数字</span>
        
        <span class="c1">// 第k层的数字处于2 ^ (k-1)次方到2^k次方</span>
        <span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">label</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">i</span><span class="o">)){</span>
                <span class="n">layer</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//第几层找到了，那么是第几个数字？</span>
        <span class="c1">//奇数层从左往右</span>
        <span class="c1">//偶数层从右往左</span>
        <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">layer</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="n">number</span> <span class="o">=</span> <span class="n">label</span> <span class="o">-</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">layer</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">number</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">layer</span><span class="o">)</span> <span class="o">-</span> <span class="n">label</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
        <span class="c1">//label是第layer层的第number个数字</span>
        <span class="c1">//反推回去，那么它的父节点是第layer-1层的第(number+1)/2个数字</span>
        <span class="c1">//直到layer = 1</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">layer</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">number</span><span class="o">+</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">);</span>
            <span class="n">number</span> <span class="o">=</span> <span class="o">(</span><span class="n">number</span><span class="o">+</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//此时list中保存了从根节点到label的路径</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="c1">//第i层的第list.get(i)个数是多少？</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="n">n</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1128"></span></p><h2 id="1128-等价多米诺骨牌对的数量">1128. 等价多米诺骨牌对的数量</h2><p>给你一个由一些多米诺骨牌组成的列表 dominoes。</p><p>如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p><p>形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 <code class="language-plaintext highlighter-rouge">a==c 且 b==d</code>，或是 <code class="language-plaintext highlighter-rouge">a==d 且 b==c</code>。</p><p>在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">dominoes</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= dominoes.length &lt;= 40000</li><li>1 &lt;= <code class="language-plaintext highlighter-rouge">dominoes[i][j]</code> &lt;= 9</li></ul><p>可以选择暴力比较每一对牌，但是时间复杂度太高。可以对每个牌排序，使每个牌都呈升序排列，然后使用桶计数统计相同的牌个数，再使用等差数列求和。</p><p>由于每个牌的数都小于10，因此我们只要将较小的数乘10，就能将等价的牌映射到同一个桶中。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numEquivDominoPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">dominoes</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//桶计数</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dominoes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">dominoes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">dominoes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">?</span> <span class="n">dominoes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">dominoes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">dominoes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">dominoes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
          	<span class="c1">//在计数过程中就累加，也可以在计数完成后直接使用等差数列求和公式求和</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">val</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">val</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1178"></span></p><h2 id="1178-猜字谜">1178. 猜字谜</h2><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p>字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p><p>单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。 例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span>
<span class="n">words</span> <span class="o">=</span> <span class="o">[</span><span class="s">"aaaa"</span><span class="o">,</span><span class="s">"asas"</span><span class="o">,</span><span class="s">"able"</span><span class="o">,</span><span class="s">"ability"</span><span class="o">,</span><span class="s">"actt"</span><span class="o">,</span><span class="s">"actor"</span><span class="o">,</span><span class="s">"access"</span><span class="o">],</span> 
<span class="n">puzzles</span> <span class="o">=</span> <span class="o">[</span><span class="s">"aboveyz"</span><span class="o">,</span><span class="s">"abrodyz"</span><span class="o">,</span><span class="s">"abslute"</span><span class="o">,</span><span class="s">"absoryz"</span><span class="o">,</span><span class="s">"actresz"</span><span class="o">,</span><span class="s">"gaswxyz"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span>
<span class="mi">1</span> <span class="n">个单词可以作为</span> <span class="s">"aboveyz"</span> <span class="n">的谜底</span> <span class="o">:</span> <span class="s">"aaaa"</span> 
<span class="mi">1</span> <span class="n">个单词可以作为</span> <span class="s">"abrodyz"</span> <span class="n">的谜底</span> <span class="o">:</span> <span class="s">"aaaa"</span>
<span class="mi">3</span> <span class="n">个单词可以作为</span> <span class="s">"abslute"</span> <span class="n">的谜底</span> <span class="o">:</span> <span class="s">"aaaa"</span><span class="o">,</span> <span class="s">"asas"</span><span class="o">,</span> <span class="s">"able"</span>
<span class="mi">2</span> <span class="n">个单词可以作为</span> <span class="s">"absoryz"</span> <span class="n">的谜底</span> <span class="o">:</span> <span class="s">"aaaa"</span><span class="o">,</span> <span class="s">"asas"</span>
<span class="mi">4</span> <span class="n">个单词可以作为</span> <span class="s">"actresz"</span> <span class="n">的谜底</span> <span class="o">:</span> <span class="s">"aaaa"</span><span class="o">,</span> <span class="s">"asas"</span><span class="o">,</span> <span class="s">"actt"</span><span class="o">,</span> <span class="s">"access"</span>
<span class="n">没有单词可以作为</span> <span class="s">"gaswxyz"</span> <span class="n">的谜底</span><span class="err">，</span><span class="n">因为列表中的单词都不含字母</span> <span class="sc">'g'</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= words.length &lt;= 10^5</li><li>4 &lt;= words[i].length &lt;= 50</li><li>1 &lt;= puzzles.length &lt;= 10^4</li><li>puzzles[i].length == 7</li><li><code class="language-plaintext highlighter-rouge">words[i][j]</code>,<code class="language-plaintext highlighter-rouge"> puzzles[i][j]</code> 都是小写英文字母。 每个 puzzles[i] 所包含的字符都不重复。</li></ul><p>一开始我的想法是把word[i]的每个字符统计，然后组合成字符串放入哈希表中。再遍历每个谜面，判断条件是否成立，但是超时了。</p><p>于是可以考虑用一个26长度的二进制数来替换字符串。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">wordsMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="c1">//先统计words[i]的所有字符，然后放入哈希表中</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
    <span class="n">table</span><span class="o">[</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
  <span class="o">}</span>
  <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">table</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'#'</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
  <span class="c1">//将形如1#0#2#0#0...的字符串作为key放入哈希表，统计这样的字符串的个数</span>
  <span class="n">wordsMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">wordsMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>替换为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">wordsMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="c1">//先统计words[i]的所有字符，然后放入哈希表中</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
    <span class="c1">//把左移1位，表示这个字符是‘b’</span>
    <span class="c1">//再用掩码去或，得到最终的掩码</span>
    <span class="n">mask</span> <span class="o">|=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="c1">//由于puzzle的长度固定为7，那么当mask的比特位数大于7时，肯定存在不属于puzzle的字符</span>
  <span class="k">if</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">bitCount</span><span class="o">(</span><span class="n">mask</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="o">){</span>
    <span class="c1">//将形如10010101的二进制数放入哈希表</span>
    <span class="n">wordsMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">mask</span><span class="o">,</span> <span class="n">wordsMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">mask</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>对于每个puzzle，仍旧先统计其mask：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span><span class="c1">//第0位放到后面统计，因为在遍历mask的子集时，第0位必须出现</span>
  <span class="n">mask</span> <span class="o">|=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">puzzle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">));</span>
<span class="o">}</span>
<span class="kt">int</span> <span class="n">subset</span> <span class="o">=</span> <span class="n">mask</span><span class="o">;</span>
</pre></table></code></div></div><p>用通用的枚举二进制子集的方法来判断哈希表中是否存在符合条件的子集。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">function</span> <span class="nf">get_subset</span><span class="o">(</span><span class="n">bitmask</span><span class="o">)</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="n">bitmask</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="o">[</span><span class="n">bitmask</span><span class="o">]</span><span class="c1">//bitmask本身也是其子集</span>
    <span class="k">while</span> <span class="n">subset</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="o">(</span><span class="n">subset</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">mask</span>
        <span class="n">put</span> <span class="n">subset</span> <span class="n">into</span> <span class="n">the</span> <span class="n">answer</span> <span class="n">list</span>
    <span class="n">end</span> <span class="k">while</span>
    <span class="k">return</span> <span class="n">answer</span>
<span class="n">end</span> <span class="n">function</span>
</pre></table></code></div></div><p>具体实现：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findNumOfValidWords</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">puzzles</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">wordsMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//先统计words[i]的所有字符，然后放入哈希表中</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">mask</span> <span class="o">|=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">bitCount</span><span class="o">(</span><span class="n">mask</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="o">){</span>
                <span class="n">wordsMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">mask</span><span class="o">,</span> <span class="n">wordsMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">mask</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">puzzle</span> <span class="o">:</span> <span class="n">puzzles</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="n">mask</span> <span class="o">|=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">puzzle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">subset</span> <span class="o">=</span> <span class="n">mask</span><span class="o">;</span>

            <span class="k">do</span><span class="o">{</span>
                <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">subset</span> <span class="o">|</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">puzzle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">));</span>
                <span class="k">if</span><span class="o">(</span><span class="n">wordsMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">)){</span>
                    <span class="n">times</span> <span class="o">+=</span> <span class="n">wordsMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="o">(</span><span class="n">subset</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">;</span>
            <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">subset</span> <span class="o">!=</span> <span class="n">mask</span><span class="o">);</span>


            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">times</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1202"></span></p><h2 id="1202-交换字符串中的元素">1202. 交换字符串中的元素</h2><p>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。</p><p>示例 1:</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"dcab"</span><span class="o">,</span> <span class="n">pairs</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"bacd"</span>
<span class="n">解释</span><span class="err">：</span> 
<span class="n">交换</span> <span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">和</span> <span class="n">s</span><span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"bcad"</span>
<span class="n">交换</span> <span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="n">和</span> <span class="n">s</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"bacd"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"dcab"</span><span class="o">,</span> <span class="n">pairs</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"abcd"</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">交换</span> <span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">和</span> <span class="n">s</span><span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"bcad"</span>
<span class="n">交换</span> <span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">和</span> <span class="n">s</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"acbd"</span>
<span class="n">交换</span> <span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="n">和</span> <span class="n">s</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"abcd"</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"cba"</span><span class="o">,</span> <span class="n">pairs</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"abc"</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">交换</span> <span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">和</span> <span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"bca"</span>
<span class="n">交换</span> <span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="n">和</span> <span class="n">s</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"bac"</span>
<span class="n">交换</span> <span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">和</span> <span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"abc"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 10^5</li><li>0 &lt;= pairs.length &lt;= 10^5</li><li>0 &lt;= <code class="language-plaintext highlighter-rouge">pairs[i][0]</code>,<code class="language-plaintext highlighter-rouge"> pairs[i][1]</code> &lt; s.length</li><li>s 中只含有小写英文字母</li></ul><p>并查集：一开始想的是将每个连通分量的字符序列进行排序，再依次填回去，发现超时了。</p><p>可以将排序用优先队列替换，将每个连通分量的代表元放入哈希表，将优先队列与其对应，直接查询能够大大减少时间复杂度。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">smallestStringWithSwaps</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">pairs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//对每个连通分量内的索引代表的字符进行排序，并且填入arr中</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">pairs</span><span class="o">){</span>
            <span class="n">union</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">pair</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">//遍历每个连通分量的代表元，将子元素都放入代表元下的优先队列中，用哈希表优化映射，直接搜索代表元的子元素会超时</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;&gt;</span> <span class="n">hashMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hashMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">root</span><span class="o">)){</span>
                <span class="n">hashMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">offer</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">hashMap</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;()).</span><span class="na">offer</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//重组字符串</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">hashMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">poll</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>

    <span class="o">}</span>


    <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">=</span> <span class="n">py</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1203"></span></p><h2 id="1203-项目管理">1203. 项目管理</h2><p>公司共有 n 个项目和 m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责。</p><p>group[i] 表示第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。</p><p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p><p>同一小组的项目，排序后在列表中彼此相邻。 项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。 如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。</p><p><strong>示例 1：</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/1359_ex1-20210112100308782.png" alt="img" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">group</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">],</span> <span class="n">beforeItems</span> <span class="o">=</span> <span class="o">[[],[</span><span class="mi">6</span><span class="o">],[</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">],[],[],[]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">group</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">],</span> <span class="n">beforeItems</span> <span class="o">=</span> <span class="o">[[],[</span><span class="mi">6</span><span class="o">],[</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">],[</span><span class="mi">3</span><span class="o">],[],[</span><span class="mi">4</span><span class="o">],[]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">与示例</span> <span class="mi">1</span> <span class="n">大致相同</span><span class="err">，</span><span class="n">但是在排序后的列表中</span><span class="err">，</span><span class="mi">4</span> <span class="n">必须放在</span> <span class="mi">6</span> <span class="n">的前面</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= m &lt;= n &lt;= 3 * 104</li><li>group.length == beforeItems.length == n</li><li>-1 &lt;= group[i] &lt;= m - 1</li><li>0 &lt;= beforeItems[i].length &lt;= n - 1</li><li>0 &lt;= <code class="language-plaintext highlighter-rouge">beforeItems[i][j]</code> &lt;= n - 1</li><li>i != <code class="language-plaintext highlighter-rouge">beforeItems[i][j]</code></li><li>beforeItems[i] 不含重复元素</li></ul><p>拓扑排序，根据组内依赖关系建立组内拓扑图、根据组间依赖关系建立组间拓扑图。在建图时将group[i]==-1的项目从m开始编号。</p><p>分别对组间、组内拓扑图执行拓扑排序。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//有几个关键点：</span>
    <span class="c1">//（1）相同小组的项目要相邻</span>
    <span class="c1">//（2）进行第i个项目前，需要beforeItem[i]中的项目都以完成</span>
    <span class="c1">//（3）beforeItem[i]为空的项目可以较为自由地安排，但需受限于关键点（1）</span>
    <span class="c1">//利用拓扑排序，首先解决组间依赖，再解决组内依赖</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortItems</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">group</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">beforeItems</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">groupItem</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">groupItem</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>
        <span class="c1">//建图</span>
        <span class="c1">//组间依赖图</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">groupGraph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">groupGraph</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>
        <span class="c1">//组内依赖图</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">itemGraph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">itemGraph</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>
        <span class="c1">//组间和组内入度数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">groupDeg</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">itemDeg</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="o">];</span>
        <span class="c1">//对group[i]=-1的项目进行编号</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">id</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">leftId</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="c1">//将项目分组</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">group</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="n">group</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftId</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">groupItem</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">group</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//遍历所有项目，</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">curGroupId</span> <span class="o">=</span> <span class="n">group</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">//遍历第i个项目的条件</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">item</span> <span class="o">:</span> <span class="n">beforeItems</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
                <span class="kt">int</span> <span class="n">beforeGroupId</span> <span class="o">=</span> <span class="n">group</span><span class="o">[</span><span class="n">item</span><span class="o">];</span>
                <span class="c1">//如果第i个项目的条件与第i个项目属于同一个小组，就建立组内依赖关系</span>
                <span class="k">if</span><span class="o">(</span><span class="n">beforeGroupId</span> <span class="o">==</span> <span class="n">curGroupId</span><span class="o">){</span>
                    <span class="n">itemDeg</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
                    <span class="n">itemGraph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">item</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//否则就建立组间依赖关系</span>
                    <span class="n">groupDeg</span><span class="o">[</span><span class="n">curGroupId</span><span class="o">]++;</span>
                    <span class="n">groupGraph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beforeGroupId</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">curGroupId</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//组间拓扑排序</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">groupTopSort</span> <span class="o">=</span> <span class="n">topSort</span><span class="o">(</span><span class="n">groupDeg</span><span class="o">,</span> <span class="n">groupGraph</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">groupTopSort</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span><span class="c1">//组间不存在拓扑排序，就返回空数组</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//组内拓扑排序</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">curGroupId</span> <span class="o">:</span> <span class="n">groupTopSort</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">groupItem</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curGroupId</span><span class="o">).</span><span class="na">size</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">topSort</span><span class="o">(</span><span class="n">itemDeg</span><span class="o">,</span> <span class="n">itemGraph</span><span class="o">,</span> <span class="n">groupItem</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curGroupId</span><span class="o">));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//拓扑排序</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">topSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">deg</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">){</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//将入度为0的项目入队</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">item</span> <span class="o">:</span> <span class="n">items</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">deg</span><span class="o">[</span><span class="n">item</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
            <span class="c1">//遍历顶点u的所有邻接点</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">u</span><span class="o">)){</span>
                <span class="c1">//入度-1</span>
                <span class="k">if</span><span class="o">(--</span><span class="n">deg</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1207"></span></p><h2 id="1207独一无二的出现次数">1207.独一无二的出现次数</h2><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">在该数组中</span><span class="err">，</span><span class="mi">1</span> <span class="n">出现了</span> <span class="mi">3</span> <span class="n">次</span><span class="err">，</span><span class="mi">2</span> <span class="n">出现了</span> <span class="mi">2</span> <span class="n">次</span><span class="err">，</span><span class="mi">3</span> <span class="n">只出现了</span> <span class="mi">1</span> <span class="n">次</span><span class="err">。</span><span class="n">没有两个数的出现次数相同</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">false</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,-</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,-</span><span class="mi">3</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= arr.length &lt;= 1000</li><li>-1000 &lt;= arr[i] &lt;= 1000</li></ul><p>先排序，再统计出现个数放入set，出现重复即返回false.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">uniqueOccurrences</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">cnt</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">cnt</span><span class="o">))</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cnt</span><span class="o">);</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">[</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1208"></span></p><h2 id="1208-尽可能使字符串相等">1208. 尽可能使字符串相等</h2><p>给你两个长度相同的字符串，s 和 t。</p><div class="table-wrapper"><table><tbody><tr><td>将 s 中的第 i 个字符变到 t 中的第 i 个字符需要<td>s[i] - t[i]<td>的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</table></div><p>用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"bcdf"</span><span class="o">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">s</span> <span class="n">中的</span> <span class="s">"abc"</span> <span class="n">可以变为</span> <span class="s">"bcd"</span><span class="err">。</span><span class="n">开销为</span> <span class="mi">3</span><span class="err">，</span><span class="n">所以最大长度为</span> <span class="mi">3</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length, t.length &lt;= 10^5</li><li>0 &lt;= maxCost &lt;= 10^6</li><li>s 和 t 都只含小写英文字母。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//实际上就是求和为maxCost的最长子数组，数组代表每个字符的转化开销</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">equalSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxCost</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">cost</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">cost</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">((</span><span class="kt">int</span><span class="o">)(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
        <span class="o">}</span>
        <span class="c1">//双指针，找和为maxCount的最长子数组</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
            <span class="o">++</span><span class="n">right</span><span class="o">;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">cost</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">maxCost</span><span class="o">)</span>    <span class="k">continue</span><span class="o">;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">);</span>
            <span class="k">while</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">maxCost</span><span class="o">){</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">cost</span><span class="o">[</span><span class="n">left</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//到了末尾，判断是超出了还是没超出maxCount</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">maxCost</span> <span class="o">?</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1239-串联字符串的最大长度">1239. 串联字符串的最大长度</h2><p>给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。</p><p>请返回所有可行解 s 中最长长度。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="s">"un"</span><span class="o">,</span><span class="s">"iq"</span><span class="o">,</span><span class="s">"ue"</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">所有可能的串联组合是</span> <span class="s">""</span><span class="o">,</span><span class="s">"un"</span><span class="o">,</span><span class="s">"iq"</span><span class="o">,</span><span class="s">"ue"</span><span class="o">,</span><span class="s">"uniq"</span> <span class="n">和</span> <span class="s">"ique"</span><span class="err">，</span><span class="n">最大长度为</span> <span class="mi">4</span><span class="err">。</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxLength</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">bitmap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span> <span class="o">:</span> <span class="n">arr</span><span class="o">){</span>
            <span class="c1">//首先过滤哪些有重复字母的字符串</span>
            <span class="c1">//然后将字符串用位图表示</span>
            <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
                <span class="k">if</span><span class="o">((</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">bit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">bit</span> <span class="o">|=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">bit</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="n">bitmap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">bit</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//深搜</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">bitmap</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">bitmap</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">bitmap</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">bitCount</span><span class="o">(</span><span class="n">mask</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//对于当前的bit，可选可不选，如果与mask没冲突，那么可选</span>
        <span class="k">if</span><span class="o">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">bitmap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cur</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">bitmap</span><span class="o">,</span> <span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mask</span> <span class="o">|</span> <span class="n">bitmap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cur</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">bitmap</span><span class="o">,</span> <span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mask</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1319"></span></p><h2 id="1319-连通网络的操作次数">1319. 连通网络的操作次数</h2><p>用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。</p><p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p><p>给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span> <span class="n">connections</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
<span class="n">解释</span><span class="err">：</span><span class="n">拔下计算机</span> <span class="mi">1</span> <span class="n">和</span> <span class="mi">2</span> <span class="n">之间的线缆</span><span class="err">，</span><span class="n">并将它插到计算机</span> <span class="mi">1</span> <span class="n">和</span> <span class="mi">3</span> <span class="n">上</span><span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= n &lt;= 10^5</li><li>1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</li><li>connections[i].length == 2</li><li>0 &lt;= <code class="language-plaintext highlighter-rouge">connections[i][0]</code>, <code class="language-plaintext highlighter-rouge">connections[i][1]</code> &lt; n</li><li><code class="language-plaintext highlighter-rouge">connections[i][0]</code> != <code class="language-plaintext highlighter-rouge">connections[i][1]</code></li><li>没有重复的连接。</li><li>两台计算机不会通过多条线缆连接。</li></ul><p>并查集，统计连通分量中多余边的个数，再统计连通分量的个数，若多余的边能够将这些连通分量连起来，那么连通分量的个数-1就是结果，否则返回-1</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">makeConnected</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">connections</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">lines</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">connections</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">connections</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">connections</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">union</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)){</span>
                <span class="n">lines</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//统计连通分量的个数</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">){</span>
                <span class="n">cnt</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">lines</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">?</span> <span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">y</span><span class="o">]);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">[</span><span class="n">py</span><span class="o">]){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
            <span class="n">px</span> <span class="o">=</span> <span class="n">py</span><span class="o">;</span>
            <span class="n">py</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">size</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">py</span><span class="o">];</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">py</span><span class="o">]</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1356"></span></p><h2 id="1356根据数字二进制下-1-的数目排序">1356.根据数字二进制下 1 的数目排序</h2><p>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。</p><p>如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">是唯一一个有</span> <span class="mi">0</span> <span class="n">个</span> <span class="mi">1</span> <span class="n">的数</span><span class="err">。</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span> <span class="n">都有</span> <span class="mi">1</span> <span class="n">个</span> <span class="mi">1</span> <span class="err">。</span>
<span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span> <span class="n">有</span> <span class="mi">2</span> <span class="n">个</span> <span class="mi">1</span> <span class="err">。</span>
<span class="o">[</span><span class="mi">7</span><span class="o">]</span> <span class="n">有</span> <span class="mi">3</span> <span class="n">个</span> <span class="mi">1</span> <span class="err">。</span>
<span class="n">按照</span> <span class="mi">1</span> <span class="n">的个数排序得到的结果数组为</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1024</span><span class="o">,</span><span class="mi">512</span><span class="o">,</span><span class="mi">256</span><span class="o">,</span><span class="mi">128</span><span class="o">,</span><span class="mi">64</span><span class="o">,</span><span class="mi">32</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">32</span><span class="o">,</span><span class="mi">64</span><span class="o">,</span><span class="mi">128</span><span class="o">,</span><span class="mi">256</span><span class="o">,</span><span class="mi">512</span><span class="o">,</span><span class="mi">1024</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">数组中所有整数二进制下都只有</span> <span class="mi">1</span> <span class="n">个</span> <span class="mi">1</span> <span class="err">，</span><span class="n">所以你需要按照数值大小将它们排序</span><span class="err">。</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="mi">10000</span><span class="o">,</span><span class="mi">10000</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">10000</span><span class="o">,</span><span class="mi">10000</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">19</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 5：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="mi">10</span><span class="o">,</span><span class="mi">100</span><span class="o">,</span><span class="mi">1000</span><span class="o">,</span><span class="mi">10000</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">10</span><span class="o">,</span><span class="mi">100</span><span class="o">,</span><span class="mi">10000</span><span class="o">,</span><span class="mi">1000</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= arr.length &lt;= 500</li><li>0 &lt;= arr[i] &lt;= 10^4</li></ul><p>快速排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortByBits</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
            <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span> <span class="o">,</span><span class="kt">int</span> <span class="n">high</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">pivotCount</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">low</span><span class="o">]);</span>
        <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
          	<span class="c1">//当二进制计数大于pivotCount时，--high</span>
          	<span class="c1">//当二进制计数等于pivotCount，且 arr[high] &gt;= pivot，--high</span>
            <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span>
                <span class="o">(</span><span class="n">count</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">])</span> <span class="o">&gt;</span> <span class="n">pivotCount</span> <span class="o">||</span>
                <span class="o">(</span><span class="n">count</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">])</span> <span class="o">==</span> <span class="n">pivotCount</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="o">)))</span>  <span class="o">--</span><span class="n">high</span><span class="o">;</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
          	<span class="c1">//同理</span>
            <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span>
                <span class="o">(</span><span class="n">count</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">low</span><span class="o">])</span> <span class="o">&lt;</span> <span class="n">pivotCount</span> <span class="o">||</span>
                <span class="o">(</span><span class="n">count</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">low</span><span class="o">])</span> <span class="o">==</span> <span class="n">pivotCount</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="o">)))</span> <span class="o">++</span><span class="n">low</span><span class="o">;</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">low</span><span class="o">;</span>
    <span class="o">}</span>
		<span class="c1">//统计二进制个数</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">a</span> <span class="o">&gt;&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>改写库函数：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortByBits</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Integer</span><span class="o">[]</span> <span class="n">arrI</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
      	<span class="c1">//因为Arrays.sort()只支持T类型对象自定义比较器，不支持诸如int[]的对象。</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">arrI</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arrI</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">count</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">a</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">count</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">b</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ca</span> <span class="o">&gt;</span> <span class="n">cb</span><span class="o">)</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">ca</span> <span class="o">==</span> <span class="n">cb</span><span class="o">){</span>
                <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">a</span> <span class="o">-</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">b</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arrI</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">a</span> <span class="o">&gt;&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1365"></span></p><h2 id="1365有多少小于当前数字的数字">1365.有多少小于当前数字的数字</h2><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。</p><p>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。</p><p>以数组形式返回答案。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="n">解释</span><span class="err">：</span> 
<span class="n">对于</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">8</span> <span class="n">存在四个比它小的数字</span><span class="err">：（</span><span class="mi">1</span><span class="err">，</span><span class="mi">2</span><span class="err">，</span><span class="mi">2</span> <span class="n">和</span> <span class="mi">3</span><span class="err">）。</span> 
<span class="n">对于</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="mi">1</span> <span class="n">不存在比它小的数字</span><span class="err">。</span>
<span class="n">对于</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]=</span><span class="mi">2</span> <span class="n">存在一个比它小的数字</span><span class="err">：（</span><span class="mi">1</span><span class="err">）。</span> 
<span class="n">对于</span> <span class="n">nums</span><span class="o">[</span><span class="mi">3</span><span class="o">]=</span><span class="mi">2</span> <span class="n">存在一个比它小的数字</span><span class="err">：（</span><span class="mi">1</span><span class="err">）。</span> 
<span class="n">对于</span> <span class="n">nums</span><span class="o">[</span><span class="mi">4</span><span class="o">]=</span><span class="mi">3</span> <span class="n">存在三个比它小的数字</span><span class="err">：（</span><span class="mi">1</span><span class="err">，</span><span class="mi">2</span> <span class="n">和</span> <span class="mi">2</span><span class="err">）。</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
</pre></table></code></div></div><p>提示：</p><ul><li>2 &lt;= nums.length &lt;= 500</li><li>0 &lt;= nums[i] &lt;= 100</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">smallerNumbersThanCurrent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="c1">//将计算过的数放入哈希表中</span>
        <span class="c1">//拷贝一份数组，排序，动态规划，放入哈希表，直接读取</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                <span class="n">x</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">x</span><span class="o">++);</span>    
            <span class="o">}</span>
            
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1370"></span></p><h2 id="1370上升下降字符串">1370.上升下降字符串</h2><p>给你一个字符串 s ，请你根据下面的算法重新构造字符串：</p><p>从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。 重复步骤 2 ，直到你没法从 s 中选择字符。 从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。 重复步骤 5 ，直到你没法从 s 中选择字符。 重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。 在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p><p>请你返回将 s 中字符重新排序后的 结果字符串 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"aaaabbbbcccc"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"abccbaabccba"</span>
<span class="n">解释</span><span class="err">：</span><span class="n">第一轮的步骤</span> <span class="mi">1</span><span class="err">，</span><span class="mi">2</span><span class="err">，</span><span class="mi">3</span> <span class="n">后</span><span class="err">，</span><span class="n">结果字符串为</span> <span class="n">result</span> <span class="o">=</span> <span class="s">"abc"</span>
<span class="n">第一轮的步骤</span> <span class="mi">4</span><span class="err">，</span><span class="mi">5</span><span class="err">，</span><span class="mi">6</span> <span class="n">后</span><span class="err">，</span><span class="n">结果字符串为</span> <span class="n">result</span> <span class="o">=</span> <span class="s">"abccba"</span>
<span class="n">第一轮结束</span><span class="err">，</span><span class="n">现在</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"aabbcc"</span> <span class="err">，</span><span class="n">我们再次回到步骤</span> <span class="mi">1</span>
<span class="n">第二轮的步骤</span> <span class="mi">1</span><span class="err">，</span><span class="mi">2</span><span class="err">，</span><span class="mi">3</span> <span class="n">后</span><span class="err">，</span><span class="n">结果字符串为</span> <span class="n">result</span> <span class="o">=</span> <span class="s">"abccbaabc"</span>
<span class="n">第二轮的步骤</span> <span class="mi">4</span><span class="err">，</span><span class="mi">5</span><span class="err">，</span><span class="mi">6</span> <span class="n">后</span><span class="err">，</span><span class="n">结果字符串为</span> <span class="n">result</span> <span class="o">=</span> <span class="s">"abccbaabccba"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"rat"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"art"</span>
<span class="n">解释</span><span class="err">：</span><span class="n">单词</span> <span class="s">"rat"</span> <span class="n">在上述算法重排序以后变成</span> <span class="s">"art"</span>
</pre></table></code></div></div><p>示例 3：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"leetcode"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"cdelotee"</span>
</pre></table></code></div></div><p>示例 4：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"ggggggg"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"ggggggg"</span>
</pre></table></code></div></div><p>示例 5：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s">"spo"</span>
<span class="n">输出</span><span class="err">：</span><span class="s">"ops"</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 500</li><li>s 只包含小写英文字母。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">sortString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span>  <span class="k">return</span> <span class="n">s</span><span class="o">;</span>

        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        
        <span class="c1">//桶计数，很有用的思路，以后排序字符就可以用这个</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">counts</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]++;</span>
        <span class="o">}</span>

        <span class="k">while</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">((</span><span class="kt">char</span><span class="o">)(</span><span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">));</span>
                    <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">]--;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">((</span><span class="kt">char</span><span class="o">)(</span><span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">));</span>
                    <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">]--;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1418-点菜展示表">1418. 点菜展示表</h2><p>给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。</p><p>请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p><p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">orders</span> <span class="o">=</span> <span class="o">[[</span><span class="s">"David"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"Ceviche"</span><span class="o">],[</span><span class="s">"Corina"</span><span class="o">,</span><span class="s">"10"</span><span class="o">,</span><span class="s">"Beef Burrito"</span><span class="o">],[</span><span class="s">"David"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"Fried Chicken"</span><span class="o">],[</span><span class="s">"Carla"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"Water"</span><span class="o">],[</span><span class="s">"Carla"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"Ceviche"</span><span class="o">],[</span><span class="s">"Rous"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"Ceviche"</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="o">[[</span><span class="s">"Table"</span><span class="o">,</span><span class="s">"Beef Burrito"</span><span class="o">,</span><span class="s">"Ceviche"</span><span class="o">,</span><span class="s">"Fried Chicken"</span><span class="o">,</span><span class="s">"Water"</span><span class="o">],[</span><span class="s">"3"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">],[</span><span class="s">"5"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">],[</span><span class="s">"10"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">,</span><span class="s">"0"</span><span class="o">]]</span> 
<span class="n">解释</span><span class="err">：</span>
<span class="n">点菜展示表如下所示</span><span class="err">：</span>
<span class="nc">Table</span><span class="o">,</span><span class="nc">Beef</span> <span class="nc">Burrito</span><span class="o">,</span><span class="nc">Ceviche</span><span class="o">,</span><span class="nc">Fried</span> <span class="nc">Chicken</span><span class="o">,</span><span class="nc">Water</span>
<span class="mi">3</span>    <span class="o">,</span><span class="mi">0</span>           <span class="o">,</span><span class="mi">2</span>      <span class="o">,</span><span class="mi">1</span>            <span class="o">,</span><span class="mi">0</span>
<span class="mi">5</span>    <span class="o">,</span><span class="mi">0</span>           <span class="o">,</span><span class="mi">1</span>      <span class="o">,</span><span class="mi">0</span>            <span class="o">,</span><span class="mi">1</span>
<span class="mi">10</span>   <span class="o">,</span><span class="mi">1</span>           <span class="o">,</span><span class="mi">0</span>      <span class="o">,</span><span class="mi">0</span>            <span class="o">,</span><span class="mi">0</span>
<span class="n">对于餐桌</span> <span class="mi">3</span><span class="err">：</span><span class="nc">David</span> <span class="n">点了</span> <span class="s">"Ceviche"</span> <span class="n">和</span> <span class="s">"Fried Chicken"</span><span class="err">，</span><span class="n">而</span> <span class="nc">Rous</span> <span class="n">点了</span> <span class="s">"Ceviche"</span>
<span class="n">而餐桌</span> <span class="mi">5</span><span class="err">：</span><span class="nc">Carla</span> <span class="n">点了</span> <span class="s">"Water"</span> <span class="n">和</span> <span class="s">"Ceviche"</span>
<span class="n">餐桌</span> <span class="mi">10</span><span class="err">：</span><span class="nc">Corina</span> <span class="n">点了</span> <span class="s">"Beef Burrito"</span> 
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">displayTable</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">orders</span><span class="o">)</span> <span class="o">{</span>
        

        <span class="c1">//有几桌，就有几行，先按桌号排序，然后再按菜名排序</span>
        <span class="c1">//&lt;桌号:&lt;菜名:数量&gt;&gt;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">order</span> <span class="o">:</span> <span class="n">orders</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">table</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">order</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">table</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="o">}</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">tmp</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">table</span><span class="o">,</span> <span class="n">tmp</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//菜名按字典序排列</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">set</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tables</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">tables</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="c1">//标题</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Table"</span><span class="o">);</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                    <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//桌号</span>
                <span class="kt">int</span> <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">table</span><span class="o">);</span>
                <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">table</span><span class="o">+</span><span class="s">""</span><span class="o">);</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                    <span class="nc">Integer</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                    <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="n">cnt</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">+</span> <span class="s">""</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1423"></span></p><h2 id="1423-可获得的最大点数">1423. 可获得的最大点数</h2><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">cardPoints</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">1</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">12</span>
<span class="n">解释</span><span class="err">：</span><span class="n">第一次行动</span><span class="err">，</span><span class="n">不管拿哪张牌</span><span class="err">，</span><span class="n">你的点数总是</span> <span class="mi">1</span> <span class="err">。</span><span class="n">但是</span><span class="err">，</span><span class="n">先拿最右边的卡牌将会最大化你的可获得点数</span><span class="err">。</span><span class="n">最优策略是拿右边的三张牌</span><span class="err">，</span><span class="n">最终点数为</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">=</span> <span class="mi">12</span> <span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><ul><li>1 &lt;= cardPoints.length &lt;= 10^5</li><li>1 &lt;= cardPoints[i] &lt;= 10^4</li><li>1 &lt;= k &lt;= cardPoints.length</li></ul><p>取边缘最大的k个牌等价于保留一段和最小的连续子数组。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">cardPoints</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cardPoints</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//实际上就是求长度为n - k的和最小的子数组</span>
        <span class="c1">//滑动窗口，大小固定为n-k</span>

        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//初始化窗口</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="c1">//求sum的最小值</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">)];</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">cardPoints</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">total</span> <span class="o">-</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1438"></span></p><h2 id="1438-绝对差不超过限制的最长连续子数组">1438. 绝对差不超过限制的最长连续子数组</h2><p>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。</p><p>如果不存在满足条件的子数组，则返回 0 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">],</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span> 
<span class="n">解释</span><span class="err">：</span><span class="n">所有子数组如下</span><span class="err">：</span>
<span class="o">[</span><span class="mi">8</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">8</span><span class="o">-</span><span class="mi">8</span><span class="o">|</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">8</span><span class="o">-</span><span class="mi">2</span><span class="o">|</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">.</span> 
<span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">8</span><span class="o">-</span><span class="mi">2</span><span class="o">|</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">[</span><span class="mi">8</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">8</span><span class="o">-</span><span class="mi">2</span><span class="o">|</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">|</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">2</span><span class="o">-</span><span class="mi">4</span><span class="o">|</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="o">|</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">4</span><span class="o">-</span><span class="mi">4</span><span class="o">|</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">4</span><span class="o">-</span><span class="mi">7</span><span class="o">|</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">[</span><span class="mi">7</span><span class="o">]</span> <span class="n">最大绝对差</span> <span class="o">|</span><span class="mi">7</span><span class="o">-</span><span class="mi">7</span><span class="o">|</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="o">.</span> 
<span class="n">因此</span><span class="err">，</span><span class="n">满足题意的最长子数组的长度为</span> <span class="mi">2</span> <span class="err">。</span>
</pre></table></code></div></div><p>提示：</p><p>1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^9 0 &lt;= limit &lt;= 10^9</p><p>我们使用一个单调递增的队列 维护最小值，一个单调递减的队列 维护最大值。这样我们只需要计算两个队列的队首的差值，即可知道当前窗口是否满足条件。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">minq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">maxq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="c1">//单调栈</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">minq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">minq</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                <span class="n">minq</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">maxq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">maxq</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]){</span>
                <span class="n">maxq</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="n">minq</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]);</span>
            <span class="n">maxq</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]);</span>
            <span class="c1">//如果最大栈的最大元素 - 最小栈的最小元素 &gt; limit</span>
            <span class="c1">//说明需要缩小窗口，直到将最大值或最小值移出窗口</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">minq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">maxq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">maxq</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">-</span> <span class="n">minq</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">maxq</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]){</span>
                    <span class="n">maxq</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="n">minq</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]){</span>
                    <span class="n">minq</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">l</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">r</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1448-统计二叉树中好节点的数目">1448. 统计二叉树中好节点的数目</h2><p>给你一棵根为 <code class="language-plaintext highlighter-rouge">root</code> 的二叉树，请你返回二叉树中好节点的数目。</p><p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">goodNodes</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//从根节点到该节点的路径上，没有任何节点的值大于该节点</span>
        <span class="c1">//那么就要记录当前路径的最大值</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxVal</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">maxVal</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
            <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">maxVal</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxVal</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">maxVal</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">maxVal</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1489"></span></p><h2 id="1489-找到最小生成树里的关键边和伪关键边">1489. 找到最小生成树里的关键边和伪关键边</h2><p>给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [fromi, toi, weighti] 表示在 fromi 和 toi 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p><p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p><p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p><p>先用Kruskal算法找出最小生成树，然后再遍历每条边</p><ul><li>关键边：如果最小生成树中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。也就是说，如果设原图最小生成树的权值为value，那么去掉这条边后：<ul><li>要么整个图不连通，不存在最小生成树；</li><li>要么整个图联通，对应的最小生成树的权值为 v，其严格大于value。</li></ul></li><li>伪关键边：可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。也就是说，我们可以在计算最小生成树的过程中，最先考虑这条边，即<strong>最先将这条边的两个端点在并查集中合并</strong>。设最终得到的最小生成树权值为 v，如果 v=value，那么这条边就是伪关键边。</li></ul><p>需要注意的是，关键边也满足伪关键边对应的性质。因此，我们首先对原图执行Kruskal 算法，得到最小生成树的权值value，随后我们枚举每一条边，首先根据上面的方法判断其是否是关键边，如果不是关键边，再判断其是否是伪关键边。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">findCriticalAndPseudoCriticalEdges</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">newEdges</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="mi">4</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">newEdges</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">u</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">u</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">-</span> <span class="n">v</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">// 计算 value</span>
        <span class="nc">UnionFind</span> <span class="n">ufStd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UnionFind</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ufStd</span><span class="o">.</span><span class="na">unite</span><span class="o">(</span><span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
        <span class="o">}</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 判断是否是关键边</span>
            <span class="nc">UnionFind</span> <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UnionFind</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
              	<span class="c1">//删去第i条边后</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">uf</span><span class="o">.</span><span class="na">unite</span><span class="o">(</span><span class="n">newEdges</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">newEdges</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">newEdges</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
          	<span class="c1">//图不连通或者权值变大</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">setCount</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">setCount</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">value</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">3</span><span class="o">]);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">//如果不是关键边，就判断是否是伪关键边</span>
            <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UnionFind</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
            <span class="n">uf</span><span class="o">.</span><span class="na">unite</span><span class="o">(</span><span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">uf</span><span class="o">.</span><span class="na">unite</span><span class="o">(</span><span class="n">newEdges</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">newEdges</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">newEdges</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
          <span class="c1">//权值为最小，就是一条伪关键边，因为收入这条边不会导致最小生成树权值变大。</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">newEdges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">3</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
      
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 并查集模板</span>
<span class="kd">class</span> <span class="nc">UnionFind</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="c1">// 当前连通分量数目</span>
    <span class="kt">int</span> <span class="n">setCount</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">UnionFind</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">setCount</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findset</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">findset</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]));</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">unite</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">findset</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">findset</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">[</span><span class="n">y</span><span class="o">])</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">size</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">y</span><span class="o">];</span>
        <span class="o">--</span><span class="n">setCount</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">findset</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">findset</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jump1584"></span></p><h2 id="1584-连接所有点的最小费用">1584. 连接所有点的最小费用</h2><p>给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。</p><div class="table-wrapper"><table><tbody><tr><td>连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：<td>xi - xj<td>+<td>yi - yj<td>，其中<td>val<td>表示 val 的绝对值。</table></div><p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/c-20210119091347577.png" alt="img" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">points</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">],[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">10</span><span class="o">],[</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">20</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">我们可以按照上图所示连接所有点得到最小总费用</span><span class="err">，</span><span class="n">总费用为</span> <span class="mi">20</span> <span class="err">。</span>
<span class="n">注意到任意两个点之间只有唯一一条路径互相到达</span><span class="err">。</span>
</pre></table></code></div></div><p>最小生成树的问题，使用Kruskal算法解决：</p><ol><li>把图中的所有边按代价从小到大排序；</li><li>把图中的n个顶点看成独立的n棵树组成的森林；</li><li>按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol><p>使用并查集维护树的连通性，只要边的两个顶点不相通，就可以被选择作为最小生成树的边。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//最小生成树：Kruskal算法</span>

    <span class="c1">//用并查集维护连通性</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">rank</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minCostConnectPoints</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//求出所有边的代价，顺便对顶点进行编号从0～n-1</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">edges</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">mDist</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//对所有边排序</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">edges</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">len</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">len</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">nodeNum</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="na">len</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
            <span class="c1">//只要该边的两端顶点不连通，那就可以选择这条边</span>
            <span class="k">if</span><span class="o">(</span><span class="n">union</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)){</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">len</span><span class="o">;</span>
                <span class="n">nodeNum</span><span class="o">++;</span>
                <span class="c1">//当节点数量到达n个时，算法结束</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nodeNum</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">mDist</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">])</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//按秩合并，将秩高的作为父节点，降低树深度，加快查询速度</span>
        <span class="k">if</span><span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">py</span><span class="o">]){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
            <span class="n">px</span> <span class="o">=</span> <span class="n">py</span><span class="o">;</span>
            <span class="n">py</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">rank</span><span class="o">[</span><span class="n">px</span><span class="o">]</span> <span class="o">+=</span> <span class="n">rank</span><span class="o">[</span><span class="n">py</span><span class="o">];</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">py</span><span class="o">]</span> <span class="o">=</span> <span class="n">px</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="c1">//边</span>
<span class="kd">class</span> <span class="nc">Edge</span><span class="o">{</span>
    <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">len</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">len</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1711-大餐计数">1711. 大餐计数</h2><p>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。</p><p>你可以搭配 任意 两道餐品做一顿大餐。</p><p>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countPairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">deliciousness</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mi">1000000007</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">:</span> <span class="n">deliciousness</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxVal</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxVal</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//二者之和不可能超过这个数</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">maxVal</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span><span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//实时记录餐品的数量</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">deliciousness</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">deliciousness</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">//遍历和的情况</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">maxSum</span><span class="o">;</span> <span class="n">sum</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">){</span>
                <span class="c1">//从哈希表中取符合条件的餐品</span>
                <span class="kt">int</span> <span class="n">count</span>  <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
                <span class="n">res</span> <span class="o">=</span> <span class="o">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">count</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1736-替换隐藏数字得到的最晚时间">1736. 替换隐藏数字得到的最晚时间</h2><p>给你一个字符串 <code class="language-plaintext highlighter-rouge">time</code> ，格式为 <code class="language-plaintext highlighter-rouge">hh:mm</code>（小时：分钟），其中某几位数字被隐藏（用 <code class="language-plaintext highlighter-rouge">?</code> 表示）。</p><p>有效的时间为 <code class="language-plaintext highlighter-rouge">00:00</code> 到 <code class="language-plaintext highlighter-rouge">23:59</code> 之间的所有时间，包括 <code class="language-plaintext highlighter-rouge">00:00</code> 和 <code class="language-plaintext highlighter-rouge">23:59</code> 。</p><p>替换 <code class="language-plaintext highlighter-rouge">time</code> 中隐藏的数字，返回你可以得到的最晚有效时间。</p><p><strong>示例 2：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入：time = "0?:3?"
输出："09:39"
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">maximumTime</span><span class="o">(</span><span class="nc">String</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//先把它分为两个部分吧</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">":"</span><span class="o">);</span>
        <span class="c1">//前面部分是小时，后面部分是分钟</span>
        <span class="c1">//分别对两个部分求最大值</span>
        <span class="c1">//分钟部分也分为两部分，第一部分最大值为5，第二部分最大值为9</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="kt">char</span> <span class="n">m_high</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">m_low</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">m_low</span> <span class="o">==</span> <span class="sc">'?'</span> <span class="o">?</span> <span class="sc">'9'</span> <span class="o">:</span> <span class="n">m_low</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">m_high</span> <span class="o">==</span> <span class="sc">'?'</span> <span class="o">?</span> <span class="sc">'5'</span> <span class="o">:</span> <span class="n">m_high</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">":"</span><span class="o">);</span>
        <span class="c1">//小时部分互相牵制，如果：</span>
        <span class="c1">//  是两个问号的话，那么无脑填充23</span>
        <span class="c1">//  高位是问号，那么如果低位大于等于4，那么高位最多只能填1</span>
        <span class="c1">//                  否则能填2</span>
        <span class="c1">//  低位是问号，那么如果高位是2，只能填到3，否则能填到9</span>
        <span class="kt">char</span> <span class="n">h_high</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">h_low</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">h_high</span> <span class="o">==</span> <span class="sc">'?'</span> <span class="o">&amp;&amp;</span> <span class="n">h_low</span> <span class="o">==</span> <span class="sc">'?'</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"32"</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">h_high</span> <span class="o">==</span> <span class="sc">'?'</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">h_low</span><span class="o">);</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">h_low</span> <span class="o">&gt;=</span> <span class="sc">'4'</span> <span class="o">?</span> <span class="sc">'1'</span> <span class="o">:</span> <span class="sc">'2'</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">h_low</span> <span class="o">==</span> <span class="sc">'?'</span><span class="o">){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">h_high</span> <span class="o">==</span> <span class="sc">'2'</span> <span class="o">?</span> <span class="sc">'3'</span> <span class="o">:</span> <span class="sc">'9'</span><span class="o">);</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">h_high</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">h_low</span><span class="o">);</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">h_high</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1800-最大升序子数组和">1800. 最大升序子数组和</h2><p>给你一个正整数组成的数组 <code class="language-plaintext highlighter-rouge">nums</code> ，返回 <code class="language-plaintext highlighter-rouge">nums</code> 中一个 <strong>升序</strong> 子数组的最大可能元素和。</p><p>子数组是数组中的一个连续数字序列。</p><p>已知子数组 <code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> ，若对所有 <code class="language-plaintext highlighter-rouge">i</code>（<code class="language-plaintext highlighter-rouge">l &lt;= i &lt; r</code>），<code class="language-plaintext highlighter-rouge">numsi &lt; numsi+1</code> 都成立，则称这一子数组为 <strong>升序</strong> 子数组。注意，大小为 <code class="language-plaintext highlighter-rouge">1</code> 的子数组也视作 <strong>升序</strong> 子数组。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>输入：nums = [10,20,30,5,10,50]
输出：65
解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxAscendingSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1818-绝对差值和">1818. 绝对差值和</h2><p>给你两个正整数数组 <code class="language-plaintext highlighter-rouge">nums1</code> 和 <code class="language-plaintext highlighter-rouge">nums2</code> ，数组的长度都是 <code class="language-plaintext highlighter-rouge">n</code> 。</p><p>数组 <code class="language-plaintext highlighter-rouge">nums1</code> 和 <code class="language-plaintext highlighter-rouge">nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code class="language-plaintext highlighter-rouge">|nums1[i] - nums2[i]|</code>（<code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p><p>你可以选用 <code class="language-plaintext highlighter-rouge">nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code class="language-plaintext highlighter-rouge">nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p><p>在替换数组 <code class="language-plaintext highlighter-rouge">nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code class="language-plaintext highlighter-rouge">109 + 7</code> <strong>取余</strong> 后返回。</p><p><code class="language-plaintext highlighter-rouge">|x|</code> 定义为：</p><ul><li>如果 <code class="language-plaintext highlighter-rouge">x &gt;= 0</code> ，值为 <code class="language-plaintext highlighter-rouge">x</code> ，或者</li><li>如果 <code class="language-plaintext highlighter-rouge">x &lt;= 0</code> ，值为 <code class="language-plaintext highlighter-rouge">-x</code></li></ul><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">5</span><span class="o">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">有两种可能的最优方案</span><span class="err">：</span>

<span class="o">-</span> <span class="n">将第二个元素替换为第一个元素</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="err">，</span><span class="n">或者</span>
<span class="o">-</span> <span class="n">将第二个元素替换为第三个元素</span><span class="err">：</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
  <span class="n">两种方案的绝对差值和都是</span> <span class="o">|</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">|</span> <span class="o">+</span> <span class="o">(|</span><span class="mi">1</span><span class="o">-</span><span class="mi">3</span><span class="o">|</span> <span class="n">或者</span> <span class="o">|</span><span class="mi">5</span><span class="o">-</span><span class="mi">3</span><span class="o">|)</span> <span class="o">+</span> <span class="o">|</span><span class="mi">5</span><span class="o">-</span><span class="mi">5</span><span class="o">|</span> <span class="o">=</span> <span class="mi">3</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minAbsoluteSumDiff</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//求最小绝对差值和，那么需要让||nums1[i] - nums2[i]| - |nums1[j] - nums2[i]||值最大</span>
        <span class="c1">//此时意味着替换一个数字后能够让差值和最大程度的减小</span>
        <span class="c1">//于是遍历数字nums[i]，尝试寻找出nums1中与nums2[i]最接近的数字</span>
        <span class="c1">//那么可以将nums1放到辅助数组中，排序后进行二分查找，总体的时间复杂度控制在O(nlogn)</span>
        <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mi">1000000007</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="o">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">diff</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">//下面的判断是精髓，两个if，把各种情况囊括了</span>
            <span class="c1">//当j &lt; n时，可以肯定的是arr中有大于等于target的数字，那么我们会找到第一个大于等于target的数字</span>
            <span class="c1">//当j &gt; 0时，可以肯定的是arr中有小于等于target的数字，那么可以囊括以下情况</span>
            <span class="c1">// 1. arr中所有数字都小于target，那最接近的是j-1</span>
            <span class="c1">// 2. 在j &lt; n的情况中，我们考虑了target小于等于arr[j]的差值，但是有可能arr[j-1]离target更近</span>
            <span class="c1">//                                  j-1, target, j，这两个区间取最小的间距</span>
            <span class="c1">//这边是arr[j] &gt;= target的情况</span>
            <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">diff</span> <span class="o">-</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
            <span class="o">}</span>
            <span class="c1">//这边是arr[j-1] &lt; target的情况 </span>
            <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">diff</span> <span class="o">-</span> <span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">max</span> <span class="o">+</span> <span class="n">mod</span><span class="o">)</span> <span class="o">%</span> <span class="n">mod</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//目的是找出最接近target的数字</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">l</span><span class="o">;</span>   
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1833-雪糕的最大数量">1833. 雪糕的最大数量</h2><p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p><p>商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。</p><p>注意：Tony 可以按任意顺序购买雪糕。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxIceCream</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">costs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//贪心为什么成立。</span>
        <span class="c1">//假设购买到最后时，钱不够了，买不了更大的了，</span>
        <span class="c1">//如果说想尝试一下退掉一个，买一个更大的，那么也不会增加雪糕数量</span>
        <span class="c1">//例如买到最后剩x元，最近购买的雪糕价值y元，下一个更贵的雪糕价值z元</span>
        <span class="c1">//那么肯定有 z &gt; y, z &gt; x,那么即使退掉一个雪糕，让钱包变为x+y，那么也只可能买一只价格z的。</span>
        <span class="c1">//不会增加雪糕数量。</span>

        <span class="c1">//所以思路是排个序，然后贪心就行了。重点是写个排序算法，那就写个快速排序吧</span>
        <span class="n">heapSort</span><span class="o">(</span><span class="n">costs</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">coins</span> <span class="o">&gt;=</span> <span class="n">costs</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">++;</span>
                <span class="n">coins</span> <span class="o">-=</span> <span class="n">costs</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">heapSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">adjust</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="n">adjust</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">adjust</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="o">)</span>    <span class="k">break</span><span class="o">;</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1838-最高频元素的频数">1838. 最高频元素的频数</h2><p>元素的 频数 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。</p><p>执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">对第一个元素执行</span> <span class="mi">3</span> <span class="n">次递增操作</span><span class="err">，</span><span class="n">对第二个元素执</span> <span class="mi">2</span> <span class="n">次递增操作</span><span class="err">，</span><span class="n">此时</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="err">。</span>
<span class="mi">4</span> <span class="n">是数组中最高频元素</span><span class="err">，</span><span class="n">频数是</span> <span class="mi">3</span> <span class="err">。</span>
</pre></table></code></div></div><p><strong>提示：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">1 &lt;= nums.length &lt;= 105</code></li><li><code class="language-plaintext highlighter-rouge">1 &lt;= nums[i] &lt;= 105</code></li><li><code class="language-plaintext highlighter-rouge">1 &lt;= k &lt;= 105</code></li></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxFrequency</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//滑动窗口</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//这也太妙了~</span>
        <span class="c1">//假设数组为1，4，8</span>
        <span class="c1">//第一次是1和4，把1往4凑，那么total是3，比k小，继续移动r</span>
        <span class="c1">//第二次是4和8，但是是乘(2-0)，也就是(8-4)*2，为什么呢？</span>
        <span class="c1">//因为第一次total=3还保留着，</span>
        <span class="c1">//这意味着从1到8的步数，在第一次已经走了3步了，这次只需要补4步就行了~</span>
        <span class="c1">//当total &gt; k时，从左边缩减窗口，只需要减去nums[r] - nums[l]即可。</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">r</span><span class="o">){</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">*</span> <span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="o">);</span>
            <span class="k">while</span><span class="o">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">){</span><span class="c1">//从左边缩减窗口</span>
                <span class="n">total</span> <span class="o">-=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]);</span>
                <span class="n">l</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1846-减小和重新排列数组后的最大元素">1846. 减小和重新排列数组后的最大元素</h2><p>给你一个正整数数组 <code class="language-plaintext highlighter-rouge">arr</code> 。请你对 <code class="language-plaintext highlighter-rouge">arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p><ul><li><code class="language-plaintext highlighter-rouge">arr</code> 中 <strong>第一个</strong> 元素必须为 <code class="language-plaintext highlighter-rouge">1</code> 。</li><li>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code class="language-plaintext highlighter-rouge">1</code> ，也就是说，对于任意的 <code class="language-plaintext highlighter-rouge">1 &lt;= i &lt; arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code class="language-plaintext highlighter-rouge">abs(arr[i] - arr[i - 1]) &lt;= 1</code> 。<code class="language-plaintext highlighter-rouge">abs(x)</code> 为 <code class="language-plaintext highlighter-rouge">x</code> 的绝对值。</li></ul><p>你可以执行以下 2 种操作任意次：</p><ul><li><strong>减小</strong> <code class="language-plaintext highlighter-rouge">arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li><li><strong>重新排列</strong> <code class="language-plaintext highlighter-rouge">arr</code> 中的元素，你可以以任意顺序重新排列。</li></ul><p>请你返回执行以上操作后，在满足前文所述的条件下，<code class="language-plaintext highlighter-rouge">arr</code> 中可能的 <strong>最大值</strong> 。</p><p><strong>示例 1：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>输入：arr = [2,2,1,2,1]
输出：2
解释：
我们可以重新排列 arr 得到 [1,2,2,2,1] ，该数组满足所有条件。
arr 中最大元素为 2 。
</pre></table></code></div></div><p>参透了”我们希望数字能一直往上升的，如果实在做不到，那只能逐个减小“这个道理后，题目就很简单了。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximumElementAfterDecrementingAndRearranging</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//两个条件：1. 第一个元素必须为1，任意两个元素相差不超过1</span>
        <span class="c1">//可以减小数字，但是不能增大数字</span>
        <span class="c1">//可以随便排列</span>
        <span class="c1">//我们希望数字能一直往上升的，如果实在做不到，那只能逐个减小</span>
        <span class="c1">//排序可行</span>
        <span class="k">if</span><span class="o">(</span><span class="n">arr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">||</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="mi">1</span><span class="o">)</span>  <span class="k">continue</span><span class="o">;</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1877-数组中最大数对和的最小值">1877. 数组中最大数对和的最小值</h2><p>一个数对 <code class="language-plaintext highlighter-rouge">(a,b)</code> 的 <strong>数对和</strong> 等于 <code class="language-plaintext highlighter-rouge">a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p><p>比方说，如果我们有数对 <code class="language-plaintext highlighter-rouge">(1,5)</code> ，<code class="language-plaintext highlighter-rouge">(2,3)</code> 和 <code class="language-plaintext highlighter-rouge">(4,4)</code>，<strong>最大数对和</strong> 为<code class="language-plaintext highlighter-rouge">max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</p><p>给你一个长度为 <strong>偶数</strong> <code class="language-plaintext highlighter-rouge">n</code> 的数组 <code class="language-plaintext highlighter-rouge">nums</code> ，请你将 <code class="language-plaintext highlighter-rouge">nums</code> 中的元素分成 <code class="language-plaintext highlighter-rouge">n / 2</code> 个数对，使得：</p><ul><li><code class="language-plaintext highlighter-rouge">nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li><li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li></ul><p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">8</span>
<span class="n">解释</span><span class="err">：</span><span class="n">数组中的元素可以分为数对</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span><span class="err">，</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">)</span> <span class="n">和</span> <span class="o">(</span><span class="mi">6</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span> <span class="err">。</span>
<span class="n">最大数对和为</span> <span class="n">max</span><span class="o">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span> <span class="o">=</span> <span class="mi">8</span> <span class="err">。</span>
</pre></table></code></div></div><p>意思就是把元素两两分组，分组后求和，找到 最大和 最小的分组方案，如果要让值尽量小，那么要让最大的值去匹配最小的值，这样才会让值更小。</p><p>证明一下：假设数值为[a,b,c,d]， d &gt; c &gt; b &gt; a，我要让a和d配对。</p><p>1号：(a,d),(b,c) 2号：(b,d)、(a,c)。会不会2号方案划分会比1号更优？有更小的最大和？</p><p>明显 b+d &gt; a+d，并且b+c&lt;b+d，那么1号方案的最大和必然小于2号方案</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minPairSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//数对和 a + b，最大数对和</span>
        <span class="c1">//数组长度为偶数，把数组分为n/2个数对</span>
        <span class="c1">//使得每个元素恰好在一个数对中，且最大数对和的值最小</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]);</span>
            <span class="n">l</span><span class="o">++;</span>
            <span class="n">r</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1893-检查是否区域内所有整数都被覆盖">1893. 检查是否区域内所有整数都被覆盖</h2><p>给你一个二维整数数组 <code class="language-plaintext highlighter-rouge">ranges</code> 和两个整数 <code class="language-plaintext highlighter-rouge">left</code> 和 <code class="language-plaintext highlighter-rouge">right</code> 。每个 <code class="language-plaintext highlighter-rouge">ranges[i] = [starti, endi]</code> 表示一个从 <code class="language-plaintext highlighter-rouge">starti</code> 到 <code class="language-plaintext highlighter-rouge">endi</code> 的 <strong>闭区间</strong> 。</p><p>如果闭区间 <code class="language-plaintext highlighter-rouge">[left, right]</code> 内每个整数都被 <code class="language-plaintext highlighter-rouge">ranges</code> 中 <strong>至少一个</strong> 区间覆盖，那么请你返回 <code class="language-plaintext highlighter-rouge">true</code> ，否则返回 <code class="language-plaintext highlighter-rouge">false</code> 。</p><p>已知区间 <code class="language-plaintext highlighter-rouge">ranges[i] = [starti, endi]</code> ，如果整数 <code class="language-plaintext highlighter-rouge">x</code> 满足 <code class="language-plaintext highlighter-rouge">starti &lt;= x &lt;= endi</code> ，那么我们称整数<code class="language-plaintext highlighter-rouge">x</code> 被覆盖了。</p><p>差分数组：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210723080904398.png" alt="image-20210723080904398" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210723080919909.png" alt="image-20210723080919909" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isCovered</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">ranges</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//差分数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">52</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">range</span> <span class="o">:</span> <span class="n">ranges</span><span class="o">){</span>
            <span class="n">diff</span><span class="o">[</span><span class="n">range</span><span class="o">[</span><span class="mi">0</span><span class="o">]]++;</span>
            <span class="n">diff</span><span class="o">[</span><span class="n">range</span><span class="o">[</span><span class="mi">1</span><span class="o">]+</span><span class="mi">1</span><span class="o">]--;</span>
        <span class="o">}</span>

        <span class="c1">//求前缀和</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">52</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="lcp-07-传递信息">LCP 07. 传递信息</h2><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><p>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p><p>示例 1：</p><p>输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3</p><p>输出：3</p><p>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numWays</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">relation</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/**
        有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
        每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
        经过k轮，从0传递到n-1的不同路径
         */</span>

        <span class="c1">//建立邻接关系</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relation</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">g</span><span class="o">[</span><span class="n">relation</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]][</span><span class="n">relation</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//节点个数很少啊，可以用dfs去做，先试试吧</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">g</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">times</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">times</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>    <span class="n">res</span><span class="o">++;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//遍历当前节点的所有邻居</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//可访问</span>
            <span class="k">if</span><span class="o">(</span><span class="n">g</span><span class="o">[</span><span class="n">v</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numWays</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">relation</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/**
        有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
        每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
        经过k轮，从0传递到n-1的不同路径
         */</span>

        <span class="c1">//建立邻接关系</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relation</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">g</span><span class="o">[</span><span class="n">relation</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]][</span><span class="n">relation</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//节点个数很少啊，可以用dfs去做，先试试吧</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">g</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">){</span>
            <span class="o">++</span><span class="n">step</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">g</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">g</span><span class="o">[</span><span class="n">v</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">()</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">res</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jumplcp19"></span></p><h2 id="lcp-19-秋叶收藏集">LCP 19. 秋叶收藏集</h2><p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。 出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p><p>示例 1：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">leaves</span> <span class="o">=</span> <span class="s">"rrryyyrryyyrr"</span>

<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>

<span class="n">解释</span><span class="err">：</span><span class="n">调整两次</span><span class="err">，</span><span class="n">将中间的两片红叶替换成黄叶</span><span class="err">，</span><span class="n">得到</span> <span class="s">"rrryyyyyyyyrr"</span>
</pre></table></code></div></div><p>示例 2：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">leaves</span> <span class="o">=</span> <span class="s">"ryr"</span>

<span class="n">输出</span><span class="err">：</span><span class="mi">0</span>

<span class="n">解释</span><span class="err">：</span><span class="n">已符合要求</span><span class="err">，</span><span class="n">不需要额外操作</span>
</pre></table></code></div></div><p>提示：</p><ul><li>3 &lt;= leaves.length &lt;= 10^5</li><li>leaves 中只包含字符 ‘r’ 和字符 ‘y’</li></ul><p>动态规划：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minimumOperations</span><span class="o">(</span><span class="nc">String</span> <span class="n">leaves</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">leaves</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">//dp[i][j]表示对0~i的叶子进行调整操作，并且第i片叶子的颜色为j的最小调整操作</span>
        <span class="c1">//j有三个状态，0:前面的红色，1：中间的黄色，2:后面的红色</span>
        <span class="c1">//叶子一共有n片</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>

        <span class="c1">//初始条件</span>
        <span class="c1">//对第0片叶子进行调整，第0片叶子为1的最小调整次数</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">leaves</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'y'</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
     <span class="c1">//由于i必须大于等于2，所以dp[0][2],dp[1][2]是不可能的值，为了不影响后面的结果，就将其初始化为极大值</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

      <span class="c1">//状态转移：</span>
      <span class="c1">//  状态dp[i][0]必须从dp[i-1][0]转化而来，所以第i片叶子为红色就无需调整，若为黄色就需要调整为红色</span>
      <span class="c1">//</span>
      <span class="c1">//  状态dp[i][1]可能由dp[i-1][0]转化而来，所以第i片叶子为黄色就无需调整，若为红色就需要调整为黄色</span>
      <span class="c1">//            也可能由dp[i-1][1]转化而来，所以第i片叶子为黄色就无需调整，若为红色就需要调整为黄色</span>
      <span class="c1">//            不可能从dp[i-1][2]转化而来</span>
      <span class="c1">//  状态dp[i][2]可能由dp[i-1][1]转化而来，所以第i片叶子为红色就无需调整，若为黄色就需要调整为红色</span>
      <span class="c1">//            也可能从dp[i-1][2]转化而来，所以第i片叶子为红色就无需调整，若为黄色就需要调整为红色</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">leaves</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'r'</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="o">(</span><span class="n">leaves</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'y'</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">//i必须大于等于2,dp[i][2]才有意义</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">])</span> <span class="o">+</span> <span class="o">(</span><span class="n">leaves</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'r'</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span> 
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jumpNC30"></span></p><h2 id="nc-30-数组中未出现的最小正整数">NC 30 数组中未出现的最小正整数</h2><p>给定一个无序数组arr，找到数组中未出现的最小正整数</p><p>例如arr = [-1, 2, 3, 4]。返回1</p><p>arr = [1, 2, 3, 4]。返回5</p><p>要求:时间复杂度为O(n)，空间复杂度为O(1)</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * return the min number
     * @param arr int整型一维数组 the array
     * @return int整型
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minNumberdisappered</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write code here</span>
        <span class="c1">//最小正整数，只能线性复杂度和常数空间复杂度</span>
        <span class="c1">//哈希</span>
        <span class="c1">//将范围在[1,n]之间的元素放到[0,n-1]中，最后遍历的时候，如果arr[i] != i+1说明这个就是最小正整数</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jumpNC36"></span></p><h2 id="nc-36-在两个长度相等的排序数组中找到上中位数">NC 36. 在两个长度相等的排序数组中找到上中位数</h2><p>给定两个有序数组arr1和arr2，已知两个数组的长度都为N，求两个数组中所有数的上中位数。</p><p>上中位数：假设递增序列长度为n，若n为奇数，则上中位数为第n/2+1个数；否则为第n/2个数</p><p>[要求]</p><p>时间复杂度为O(logN)，额外空间复杂度为O(1)</p><ol><li>如果每个数组中只有一个元素，较小的那个元素就是整体的上中位数，如果两个元素相等，随便返回哪个都可以。</li><li>如果数组中不止一个元素，找到两个数组的中间位置mid1和mid2。</li><li>如果arr1[mid1] == arr2[mid2]，不管每个数组中元素的个数是奇数还是偶数，这两个数都可以是整体的上中位数，返回其中一个就可以。</li><li>如果arr1[mid1] &gt; arr2[mid2]，每个数组的个数是奇数的情况下：数组arr1中mid1位置以后的数都不可能是整体的上中位数，数组arr2中mid2位置以前的数都不可能是整体的上中位数。所以现在只需要考虑arr1[left1…mid1]、arr2[mid2…right]，这两部分的元素个数相同，它们的上中位数就是整体的上中位数。</li><li>如果arr1[mid1] &gt; arr2[mid2]，每个数组的个数是偶数的情况下：数组arr1中mid1位置以后的数都不可能是整体的上中位数，数组arr2中mid2位置以后包括mid2位置，都不可能是整体的上中位数。所以现在只需要考虑arr1[left1…mid1]、arr2[mid2+1…right]，这两部分的元素个数相同，它们的上中位数就是整体的上中位数。</li><li>arr1[mid1] &lt; arr2[mid2]的情况，分析同上。</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * find median in two sorted array
     * @param arr1 int整型一维数组 the array1
     * @param arr2 int整型一维数组 the array2
     * @return int整型
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMedianinTwoSortedAray</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write code here</span>
        <span class="c1">//就是从这两个数组中找到第N小的数</span>
        <span class="c1">//时间复杂度要求logn，不能使用额外空间</span>
        <span class="c1">//logn能想到的就是二分查找</span>
        <span class="c1">//如何在两个排序的数组上进行二分查找呢？</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l1</span> <span class="o">&lt;</span> <span class="n">r1</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">mid1</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">+</span> <span class="o">((</span><span class="n">r1</span> <span class="o">-</span> <span class="n">l1</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">mid2</span> <span class="o">=</span> <span class="n">l2</span> <span class="o">+</span> <span class="o">((</span><span class="n">r2</span> <span class="o">-</span> <span class="n">l2</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">//数组长度是会变化的</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="n">l1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr1</span><span class="o">[</span><span class="n">mid1</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr2</span><span class="o">[</span><span class="n">mid2</span><span class="o">])</span>    <span class="k">return</span> <span class="n">arr1</span><span class="o">[</span><span class="n">mid1</span><span class="o">];</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">arr1</span><span class="o">[</span><span class="n">mid1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr2</span><span class="o">[</span><span class="n">mid2</span><span class="o">]){</span>
                <span class="c1">//如果n是奇数，那么中位数是第n/2+1个数</span>
                <span class="c1">//如果n是偶数，那么中位数是第n/2个数</span>
                <span class="c1">//所以当n是奇数的时候，包括mid，如果是偶数的时候，排除mid</span>
                <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">r1</span> <span class="o">=</span> <span class="n">mid1</span><span class="o">;</span>
                    <span class="n">l2</span> <span class="o">=</span> <span class="n">mid2</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">r1</span> <span class="o">=</span> <span class="n">mid1</span><span class="o">;</span>
                    <span class="n">l2</span> <span class="o">=</span> <span class="n">mid2</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">2</span><span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">l1</span> <span class="o">=</span> <span class="n">mid1</span><span class="o">;</span>
                    <span class="n">r2</span> <span class="o">=</span> <span class="n">mid2</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">l1</span> <span class="o">=</span> <span class="n">mid1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">r2</span> <span class="o">=</span> <span class="n">mid2</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">arr1</span><span class="o">[</span><span class="n">l1</span><span class="o">],</span> <span class="n">arr2</span><span class="o">[</span><span class="n">l2</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jumpNC100"></span></p><h2 id="nc100-将字符串转化为整数">NC100 将字符串转化为整数</h2><p>实现函数 atoi 。函数的功能为将字符串转化为整数</p><p>提示：仔细思考所有可能的输入情况。这个问题没有给出输入的限制，你需要自己考虑所有可能的情况。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * 
     * @param str string字符串 
     * @return int整型
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">atoi</span> <span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write code here</span>
        <span class="c1">//1. 会不会溢出？</span>
        <span class="c1">//2. 删除前导0</span>
        <span class="c1">//3. 正负数处理</span>
        <span class="c1">//4. 空串如何处理呢？</span>
        <span class="c1">//6. 会有小数吗？</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//处理空格</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="o">)</span>
                <span class="n">cur</span><span class="o">++;</span>
            <span class="k">else</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//处理正负号</span>
        <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">//处理前导0和符号</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">||</span> <span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">||</span> <span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span>
                <span class="n">cur</span><span class="o">++;</span>
            <span class="k">else</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//开始读取数字</span>
        <span class="c1">//遇到特殊字符就截断</span>
        <span class="c1">//遇到正溢出就输出MAX_VALUE，遇到负溢出就输出MIN_VALUE</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">&lt;</span> <span class="sc">'0'</span> <span class="o">||</span> <span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="o">)</span>    <span class="k">break</span><span class="o">;</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">cur</span><span class="o">]);</span>
            <span class="n">cur</span><span class="o">++;</span>
        <span class="o">}</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">isOverflow</span><span class="o">(</span><span class="n">sb</span><span class="o">,</span> <span class="n">sign</span><span class="o">)){</span>
            <span class="k">return</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Integer</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">res</span> <span class="o">*</span> <span class="n">sign</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//判断溢出</span>
    <span class="kt">boolean</span> <span class="nf">isOverflow</span><span class="o">(</span><span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sign</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="sc">'2'</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="nc">String</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">"2147483647"</span> <span class="o">:</span> <span class="s">"2147483648"</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">thres</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">))</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">thres</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">cur</span><span class="o">))</span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">else</span>    <span class="n">cur</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><span id="jumpNC129"></span></p><h2 id="nc129-阶乘末尾的0的数量">NC129 阶乘末尾的0的数量</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210419164407765.png" alt="image-20210419164407765" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * the number of 0
     * @param n long长整型 the number
     * @return long长整型
     */</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">thenumberof0</span> <span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write code here</span>
        <span class="c1">//要相乘产生0，那肯定是与5相乘的结果。对n!如果分解质因数的话，</span>
        <span class="c1">//结果为0的个数只与2与5的个数有关，每一次2*5就能产生一个0。</span>
        <span class="c1">//因为2的个数肯定要大于5的个数，所以只要关注5的个数就可以了.</span>
        <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">5</span><span class="o">;</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="nc138-矩阵最长递增路径">NC138 矩阵最长递增路径</h2><p>给定一个矩阵，矩阵内所有数均为非负整数。</p><p>求一条路径，该路径上所有数是递增的。</p><p>这个路径必须满足以下条件：</p><p>1、对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。</p><p>2、你不能走重复的单元格。即每个格子最多只能走一次。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 递增路径的最大长度
     * @param matrix int整型二维数组 描述矩阵的每个数
     * @return int整型
     */</span>
    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solve</span> <span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write code here</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">direction</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">};</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">){</span>
        
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">new_x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">new_x</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">new_y</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span>    <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">new_x</span><span class="o">][</span><span class="n">new_y</span><span class="o">])</span>    <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">new_x</span><span class="o">][</span><span class="n">new_y</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]){</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">new_x</span><span class="o">,</span> <span class="n">new_y</span><span class="o">,</span> <span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="hj-6-质数因子">HJ 6 质数因子</h2><p>功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ）</p><p>最后一个数后面也要有空格</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="nc">Long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLong</span><span class="o">();</span>
        <span class="c1">//打印所有质数因子</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                <span class="n">n</span> <span class="o">/=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span><span class="o">+</span><span class="s">" "</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="nc-159-最小生成树">NC 159 最小生成树</h2><p>一个有n户人家的村庄，有m条路连接着。村里现在要修路，每条路都有一个代价，现在请你帮忙计算下，最少需要花费多少的代价，就能让这n户人家连接起来。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost int二维数组 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">miniSpanningTree</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">cost</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write code here</span>
        <span class="c1">//n户人家编号为1，2，3，。。。，n</span>
        <span class="c1">//初始选择顶点1作为起始，那么u = {1}, v = {2,3,4,...,n}</span>
        <span class="c1">//找到集合v中到顶点u的代价最小的边，然后把点从v移动到u中</span>
        <span class="c1">//</span>
        <span class="kt">int</span> <span class="no">INF</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="c1">//首先建立邻接矩阵</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="no">INF</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">src</span> <span class="o">=</span> <span class="n">cost</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">cost</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">cost</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
            <span class="c1">//两个顶点间可能存在多条边，取权值最小的边</span>
            <span class="k">if</span><span class="o">(</span><span class="n">graph</span><span class="o">[</span><span class="n">src</span><span class="o">][</span><span class="n">dst</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="o">){</span>
                <span class="n">graph</span><span class="o">[</span><span class="n">src</span><span class="o">][</span><span class="n">dst</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
                <span class="n">graph</span><span class="o">[</span><span class="n">dst</span><span class="o">][</span><span class="n">src</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//记录哪些顶点已经被假如集合u了</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span><span class="c1">//从1开始</span>
        <span class="c1">//记录集合u到集合v中每条边的最小权值</span>
        <span class="c1">//比如集合u{1,2,3}到集合v中点x的最小边为dist[x]</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">visited</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//初始化，一开始集合中只有点1，那么从集合u到集合v所有点的边权为graph[1][i]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">//遍历剩余所有边</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//找一条最小的边对应的点加入集合u</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">){</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="n">visited</span><span class="o">[</span><span class="n">next</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">min</span><span class="o">;</span>
            <span class="c1">//更新集合v中每个点到集合u的最小距离</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="c1">//未访问的点肯定在集合v中</span>
                <span class="c1">//我们把next加入到u中，导致集合v中有些点到集合u的最小距离缩短了，那就更新dist</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">graph</span><span class="o">[</span><span class="n">next</span><span class="o">][</span><span class="n">j</span><span class="o">]){</span>
                    <span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">[</span><span class="n">next</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="nc-23-划分链表">NC 23 划分链表</h2><p>给出一个链表和一个值 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.nowcoder.com/equation?tex=x%5C" alt="img" />，以 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.nowcoder.com/equation?tex=x%5C" alt="img" />为参照将链表划分成两部分，使所有小于 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.nowcoder.com/equation?tex=x%5C" alt="img" />的节点都位于大于或等于 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.nowcoder.com/equation?tex=x%5C" alt="img" />的节点之前。 两个部分之内的节点之间要保持的原始相对顺序。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">partition</span> <span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write code here</span>
        <span class="c1">//双指针</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
<span class="c1">//         if(left.next == null)    return dummy.next;</span>
        <span class="c1">//此时left已经定位到第一个大于等于x节点的前驱</span>
        <span class="nc">ListNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">){</span>
                <span class="c1">//插入到left的后面</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">right</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">left</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="jz-31整数中1出现的次数">JZ 31整数中1出现的次数</h2><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数 例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次</p><p>像类似这样的问题，我们可以通过归纳总结来获取相关的东西。</p><p>首先可以先分类：</p><p><strong>个位</strong></p><p>我们知道在个位数上，1会每隔10出现一次，例如1、11、21等等，我们发现以10为一个阶梯的话，每一个完整的阶梯里面都有一个1，例如数字22，按照10为间隔来分三个阶梯，在完整阶梯0-9，10-19之中都有一个1，但是19之后有一个不完整的阶梯，我们需要去判断这个阶梯中会不会出现1，易推断知，如果最后这个露出来的部分小于1，则不可能出现1（这个归纳换做其它数字也成立）。</p><p>我们可以归纳个位上1出现的个数为：</p><blockquote><p><strong>n/10 * 1+(n%10!=0 ? 1 : 0)</strong></p></blockquote><p><strong>十位</strong></p><p>现在说十位数，十位数上出现1的情况应该是10-19，依然沿用分析个位数时候的阶梯理论，我们知道10-19这组数，每隔100出现一次，这次我们的阶梯是100，例如数字317，分析有阶梯0-99，100-199，200-299三段完整阶梯，每一段阶梯里面都会出现10次1（从10-19），最后分析露出来的那段不完整的阶梯。我们考虑如果露出来的数大于19，那么直接算10个1就行了，因为10-19肯定会出现；如果小于10，那么肯定不会出现十位数的1；如果在10-19之间的，我们计算结果应该是k - 10 + 1。例如我们分析300-317，17个数字，1出现的个数应该是17-10+1=8个。</p><p>那么现在可以归纳：十位上1出现的个数为：</p><blockquote><ul><li>设k = n % 100，即为不完整阶梯段的数字</li><li>归纳式为：<strong>(n / 100) * 10 + (if(k &gt; 19) 10 else if(k &lt; 10) 0 else k - 10 + 1)</strong></li></ul></blockquote><p><strong>百位</strong></p><p>现在说百位1，我们知道在百位，100-199都会出现百位1，一共出现100次，阶梯间隔为1000，100-199这组数，每隔1000就会出现一次。这次假设我们的数为2139。跟上述思想一致，先算阶梯数 * 完整阶梯中1在百位出现的个数，即n/1000 * 100得到前两个阶梯中1的个数，那么再算漏出来的部分139，沿用上述思想，不完整阶梯数k199，得到100个百位1，100&lt;=k&lt;=199则得到k - 100 + 1个百位1。</p><p>那么继续归纳百位上出现1的个数：</p><blockquote><ul><li>设k = n % 1000</li><li>归纳式为：<strong>(n / 1000) * 100 + (if(k &gt;199) 100 else if(k &lt; 100) 0 else k - 100 + 1)</strong></li></ul></blockquote><p>后面的依次类推….</p><p><strong>再次回顾个位</strong></p><p>我们把个位数上算1的个数的式子也纳入归纳式中</p><blockquote><ul><li>k = n % 10</li><li>个位数上1的个数为：<strong>n / 10 * 1 + (if(k &gt; 1) 1 else if(k &lt; 1) 0 else k - 1 + 1)</strong></li></ul></blockquote><p>完美！归纳式看起来已经很规整了。 来一个更抽象的归纳，设i为计算1所在的位数，i=1表示计算个位数的1的个数，10表示计算十位数的1的个数等等。</p><blockquote><ul><li>k = n % (i * 10)</li><li><strong>count(i) = (n / (i * 10)) * i + (if(k &gt; i * 2 - 1) i else if(k &lt; i) 0 else k - i + 1)</strong></li></ul></blockquote><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">NumberOf1Between1AndN_Solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">){</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">10</span><span class="o">))</span> <span class="o">*</span> <span class="n">i</span><span class="o">;</span>
            <span class="kt">long</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">10</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">){</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/leetcode/'>leetcode</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" class="post-tag no-text-decoration" >算法题解</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Leetcode题解 - 黄玉才的博客&url=www.yucaihuang.com/posts/leetcode-solutions/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Leetcode题解 - 黄玉才的博客&u=www.yucaihuang.com/posts/leetcode-solutions/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Leetcode题解 - 黄玉才的博客&url=www.yucaihuang.com/posts/leetcode-solutions/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/web-url-with-chinese-string/">URL包含中文，请求资源404</a></li><li><a href="/posts/web-docker_2/">Docker：入门</a></li><li><a href="/posts/web-docker_1/">Docker：概述</a></li><li><a href="/posts/web-delete-system-python-in-centos/">centOS误删系统自带python</a></li><li><a href="/posts/springboot-starter-id/">创建自定义Springboot starter</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/leetcode-package-problems/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Jun 17 <i class="unloaded">2021-06-17T15:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode：背包问题专题整理</h3><div class="text-muted small"><p> 本文用于记录各类背包问题及其解题思路。 01背包问题 这是最为基础的背包问题，每种物品只有一件，可以选择取或者不取。 问题描述可以归结为：将N种物品有选择地放入容量为V的背包中，要求背包中的物品价值最大。 尝试提炼其子问题：将i种物品有选择地放入容量为V的背包中，要求背包中的物品价值最大。 那么由子问题转移到父问题的方程为： 1 f(i,V) = max{f(i-1,...</p></div></div></a></div><div class="card"> <a href="/posts/leetcode-competition247/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Jun 28 <i class="unloaded">2021-06-28T08:59:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode：第247场周赛记录</h3><div class="text-muted small"><p> 5797. 两个数对之间的最大乘积差 两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a * b) - (c * d) 。 例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 * 6) - (2 * 7) = 16 。 给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对 (nums[w], nums[x]) 和 (nums[y]...</p></div></div></a></div><div class="card"> <a href="/posts/leetcode-competition248/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Jul 4 <i class="unloaded">2021-07-04T12:04:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode：第248场周赛记录</h3><div class="text-muted small"><p> 总体来说，发挥还是可以的，前三题做的很顺利。最后一题还剩大概1个小时，但是还是没AC，最好做到69/71，时间复杂度没法解决。 5800. 基于排列构建数组 给你一个 从 0 开始的排列 nums（下标也从 0 开始）。请你构建一个 同样长度 的数组 ans ，其中，对于每个 i（0 &lt;= i &lt; nums.length），都满足 ans[i] = nums[nums...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/algorithm-union-find/" class="btn btn-outline-primary"><p>并查集</p></a> <a href="/posts/java-meta-annotation/" class="btn btn-outline-primary"><p>Java的四个元注解</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-2</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
