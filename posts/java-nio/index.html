<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>浅析Java NIO | 黄玉才的博客</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="浅析Java NIO" /><meta name="author" content="Kol Huang" /><meta property="og:locale" content="en_US" /><meta name="description" content="本文用于记录对Java NIO的一些理解和思考" /><meta property="og:description" content="本文用于记录对Java NIO的一些理解和思考" /><link rel="canonical" href="www.yucaihuang.com/posts/java-nio/" /><meta property="og:url" content="www.yucaihuang.com/posts/java-nio/" /><meta property="og:site_name" content="黄玉才的博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-13T15:40:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="浅析Java NIO" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kol Huang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"www.yucaihuang.com/posts/java-nio/"},"url":"www.yucaihuang.com/posts/java-nio/","author":{"@type":"Person","name":"Kol Huang"},"description":"本文用于记录对Java NIO的一些理解和思考","dateModified":"2021-05-13T15:40:00+08:00","datePublished":"2021-05-13T15:40:00+08:00","headline":"浅析Java NIO","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176388509-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-176388509-1'); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="http://www.yucaihuang.com" alt="avatar"> <img src="/assets/img/daliy/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">黄玉才的博客</a></div><div class="site-subtitle font-italic">把开源的变成自己的，把自己的变成祖传的!</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/KolinHuang" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['yc_huang97','163.com'].join('@'))" > <i class="fas fa-envelope"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>浅析Java NIO</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>浅析Java NIO</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, May 13, 2021, 3:40 PM +0800" > May 13 <i class="unloaded">2021-05-13T15:40:00+08:00</i> </span> by <span class="author"> Kol Huang</div></div><div class="post-content"><blockquote><p>本文用于记录对Java NIO的一些理解和思考</p></blockquote><h2 id="核心类">核心类</h2><p>Java NIO主要有<strong>三个核心部分组成</strong>：</p><ul><li><strong>buffer缓冲区</strong></li><li><strong>Channel管道</strong></li><li><strong>Selector选择器</strong></li></ul><p>Buffer类维护了4个核心变量属性来提供<strong>关于其所包含的数组的信息</strong>。它们是：</p><ul><li><p>容量Capacity</p></li><li><ul><li><strong>缓冲区能够容纳的数据元素的最大数量</strong>。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)</li></ul></li><li><p>上界Limit</p></li><li><ul><li><strong>缓冲区里的数据的总数</strong>，代表了当前缓冲区中一共有多少数据。</li></ul></li><li><p>位置Position</p></li><li><ul><li><strong>下一个要被读或写的元素的位置</strong>。Position会自动由相应的 <code class="language-plaintext highlighter-rouge">get( )</code>和 <code class="language-plaintext highlighter-rouge">put( )</code>函数更新。</li></ul></li><li><p>标记Mark</p></li><li><ul><li>一个备忘位置。<strong>用于记录上一次读写的位置</strong>。</li></ul></li></ul><p>ByteBuffer是最常用的实现类。</p><p>Channel可以分为两大类：用于网络读写的SelectableChannel和用于文件操作的FileChannel。像ServerSocketChannel和SocketChannel都是SelectableChannel的子类。</p><p>Selector提供了选择已经就绪的任务的能力。简单来说，Selector会不断地轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪的Channel集合，进行后续的IO操作。一个多路复用器Selector可以同时轮询多个Channel。</p><p>在我的理解中，Channel只是一个抽象的概念，并不像PIPE或者FIFO那样是真实存在的管道文件。Channel是抽象出来，让Java程序能够去直接操作文件描述符的一个工具。</p><p>Buffer缓冲区则是一个真实存在的内存区域，总得来说这个Buffer缓冲区有三种，第一种是文件NIO里的MapedByteBuffer，这是直接通过系统调用mmap创建的一个内存到磁盘文件的直接映射，也就是有一块内存的虚拟地址被映射到了一块真实存在的磁盘文件，这种Buffer应该没有在内存中开辟缓冲区，只是把一块虚拟地址和磁盘文件进行绑定；第二种是网络NIO里的经常用的，byteBuffer，这种byteBuffer是在内存中真实划分了一块区域作为缓冲区的，我们可以调用allocate把缓冲区划分在JVM堆内，也可以调用allocateDirect把缓冲区划分在JVM堆外，Java程序堆内。后面这两种缓冲区在大多数情况下，性能都是差不多的，分配在JVM堆外的缓冲区少了1次系统调用，但是分配系统级内存更加耗时。有人测试过，在处理大文件的时候，分配在JVM堆外速度会快一些，还有就是生命周期长一些的缓冲区，可以直接分配在JVM堆外。</p><p>Selector则是对内核中的多路复用器的封装，比如select、poll、epoll、kqueue。</p><h2 id="bytebuffer">ByteBuffer</h2><ul><li>put往数组里放字节，移动pos指针，一开始pos指针指向0；</li><li>flip翻转，在读的时候将limit指向pos，让pos指向0，这样能读取已写入的字节；（读写行为交替）</li><li>get让pos向后移动。</li><li>compact：把已读取的位置删除，再把剩余未读的往前移动填充，最后更新pos到未读数据的末尾，更新limit到数组末尾。</li></ul><p>想读的时候flip一下，想写的时候compact一下。</p><p>byteBuffer的allocate是将字节数组分配到堆上，allocateDirect是在Java进程的堆空间（JVM堆空间的外部）分配的数组。</p><h2 id="文件的nio">文件的NIO</h2><p>首先介绍一个接口 RandomAccessFile：</p><ol><li>直接调用write写</li><li>可以用seek方法来移动光标。</li><li>getChannel获得FileChannel对象，文件通道。</li></ol><p>FileChannel是能直接连接输入流和输出流的文件通道，将数据直接写入到目标文件中。</p><p>传统上，我们使用输入输出流来读写文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">inputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">fromFile</span><span class="o">));</span>
<span class="n">outputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">toFile</span><span class="o">));</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
<span class="c1">//读取到输入流数据，然后写入到输出流中去，实现复制</span>
<span class="k">while</span> <span class="o">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">outputStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>利用FileChannel进行文件复制操作如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">fileInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">fromFile</span><span class="o">);</span>
<span class="n">fileOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">toFile</span><span class="o">);</span>
<span class="c1">//得到fileInputStream的文件通道</span>
<span class="n">fileChannelInput</span> <span class="o">=</span> <span class="n">fileInputStream</span><span class="o">.</span><span class="na">getChannel</span><span class="o">();</span>
<span class="c1">//得到fileOutputStream的文件通道</span>
<span class="n">fileChannelOutput</span> <span class="o">=</span> <span class="n">fileOutputStream</span><span class="o">.</span><span class="na">getChannel</span><span class="o">();</span>
<span class="c1">//将fileChannelInput通道的数据，写入到fileChannelOutput通道</span>
<span class="n">fileChannelInput</span><span class="o">.</span><span class="na">transferTo</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">fileChannelInput</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="n">fileChannelOutput</span><span class="o">);</span>
</pre></table></code></div></div><p>和SelectableChannel相比，FileChannel的特别之处：</p><p>只有FileChannel才有map方法，map的返回值是一个MappedByteBuffer对象。map方法实际上是调用了mmap系统调用，得到了一个堆外的、和文件映射的ByteBuffer，我们可以直接通过ByteBuffer的put方法往这个文件里写数据，这不涉及系统调用，但是数据会到达内核的Page Cache。曾经我们是需要用out.write()这样的系统调用才能让程序的data进入内核的PageBuffer，也就是必须有内核用户态切换。</p><p>更加具体地说，调用这个Map方法之后，生成了一个内存映射，将一个缓冲区（字节数组）和一个文件直接映射。我们在使用输入输出流来读写文件的时候，实际上是创建了一个读写的文件描述符，将这个文件描述符作为参数通过系统调用去读写文件。区别就在这里，一个是直接读写文件，一个是通过系统调用去读写文件，中间少了一层用户态和核心态的切换。</p><p>目前的JDK API都无法跨越内核的PageCache往磁盘中写数据的，但是我们可以使用一些JNI扩展库，用C语言使用Linux内核的Direct IO去忽略PageCache，Direct IO是自己开辟一个字节数组当做PageCache，也就是说PageCache交给程序自己管理了，所以要程序自己维护一致性和脏回写等一系列问题。实际上在性能上，跟内核的PageCache没啥区别，但是这意味着可以每个程序自己去管理和维护PageCache的一系列状态和操作，每个程序的PageCache配置参数互相独立，以更细粒度的方式来优化我们的程序。因为内核的PageCache配置是全局的，对所有程序生效。数据库可能会使用这种Direct IO。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210423231103665.png" alt="image-20210423231103665" /></p><p>如果通过ByteBuffer的allocate方法在程序堆空间内创建的字节数组要写入到内核的PageCache（目的是写到文件，但是必然是要经过内核的），是需要调用<code class="language-plaintext highlighter-rouge">channel.write</code>和 <code class="language-plaintext highlighter-rouge">channel.read</code>方法写入的，因此必然是要经过系统调用。而FileChannel对象的map方法返回的MappedByteBuffer对象可以直接写入文件，因为map方法是通过调用mmap系统调用来创建一块进程和内核的共享内存区，且这个区域是PageCache到文件的映射。还有一点是，<code class="language-plaintext highlighter-rouge">allocateDirect</code>方法分配的数组使用JVM堆外空间，因此少了一次JVM堆空间向程序堆空间的映射，所以性能稍微高一些。</p><p>Netty用的是(On heap，Off Heap)，Off Heap更多一些，Kafka log是用的mmap实现的。</p><ul><li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210423233250235.png" alt="image-20210423233250235" /></li></ul><p>回到NIO，这是属于文件的NIO，非阻塞体现在没经过系统调用，对于SocketNIO呢，非阻塞体现在多路复用上。</p><h2 id="io视角下的tcpip">I/O视角下的TCP/IP</h2><p>假设有一个服务器和一个客户端。我们在服务器上创建了一个Server Socket，监听一个端口；然后我们在客户端上创建一个Socket，尝试给服务端发数据。目前我们只创建一个一个Server Socket，<strong>没有调用accept方法</strong>，这时候服务端会创建一个unix类型的文件描述符处于监听状态，客户端主动向服务端握手，服务端会响应，并且二者可以成功地完成三次握手并进入ESTABLISHED状态。关键点来了，客户端在成功建立连接后，向服务端发送了数据，但是服务端并没有调用accept方法，可是这时候内核中已经创建了一个Socket，但是还未分配给一个具体的进程，并且这个Socket的接收队列是可以有客户端发来的数据的。以上更加说明TCP是面向连接的，只要三次握手成功，连接建立，那么客户端和服务端就会在内核中开辟一块资源用于双方交互（客户端给服务端发数据，服务端会返回ACK，即使Socket还没分配给一个具体的进程）。</p><p>这时候我们查看服务端进程的文件描述符列表，会发现还是只有一个处于监听状态的文件描述符，因为我们还没调用accept，也就是还没通过系统调用accept响应Socket，通过内核获得这个Socket对应的文件描述符。</p><p>随后我们调用accept，就会发现网络连接中的Socket已经被分配给了服务端进程，服务端进程的文件描述符列表中也出现了类型为IPv4的文件描述符。</p><p>在Java中，我们调用accept方法获得的Socket其实是系统调用返回的文件描述符的抽象和封装。</p><p>再说说一个参数，叫back_log，这个参数就跟上面说的情况有关，如果我们的服务端进程都不去调用accept，内核最多允许有back_log+1个没有被分配给具体进程的Socket连接，举个例子，假如back_log为2，那么当有4个客户端进程来尝试连接服务端，只会有3个连接成功，有一个会连接失败（SYN_REVD）。</p><p>最后，我们可以给accept配置一个TIMEOUT，因为在调用accept的时候，如果没有Socket过来，那么会进程阻塞，我们给他设置一个TIMEOUT，就是为了防止过度阻塞。</p><p>Socket的接收队列容量是有限制的，如果服务端进程迟迟不取走数据，而客户端一直在发数据，那么当接收队列满了以后，新的数据都会直接被丢弃。</p><p><strong>还有一个参数叫NoDelay</strong>，默认是关闭NoDelay的，也就是默认会开启一个发送优化。假设我们通过文件描述符往Socket里写数据的时候，是通过write系统调用一个字节一个字节的写进去的，那么如果开启了这个发送优化，那么Socket会尽量先把你要发送的数据在发送队列里攒一攒，然后再发送出去，这是为了减少网络中数据包的数量，同时提高数据传输率，因为我们在发送一个TCP包的时候，TCP报文段头部20字节、IP数据报头部20字节，如果发送的数据只有1字节，那发送效率就太低了，开启发送优化就可以提高这个发送效率。如果我们把NoDelay打开，在网络状况良好的情况下，数据包就会更快地发送到另一端，所以要根据具体的场景来决定是否打开这个优化。</p><p>小结：当Java代码new了一个ServerSocket，然后绑定了端口P，并调用accept方法接收客户端连接，以上步骤实际上对应着系统调用<code class="language-plaintext highlighter-rouge">socket+bind+listen+accept</code>，socket系统调用返回一个文件描述符，bind将这个文件描述符绑定到P端口，listen监听80端口，accept阻塞在等待客户端连接的过程，有客户端连接后，accept会返回一个文件描述符用于表示当前这个Socket连接。</p><h2 id="网络io模型变化">网络IO模型变化</h2><h3 id="bio">BIO</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210425225216717.png" alt="image-20210425225216717" /></p><p>进程创建监听Socket，并绑定端口开启监听，调用accept阻塞等待客户端连接，当接收到客户端连接后accept返回一个连接Socket和相应的文件描述符，然后调用clone创建一个线程（子进程）调用recv阻塞等待接收数据。这就是BIO模型。</p><p>BIO的弊端就是：accept阻塞、来一个连接创建线程耗时，罪魁祸首就是内核的阻塞系统调用API。</p><h3 id="网络nio">网络NIO</h3><p><strong>NIO登场</strong>。NIO在JDK里的意思是new IO，在操作系统IO模型中的意思是NONBLOCKING。</p><p>首先介绍SelectableChannel的子类实现：</p><p><code class="language-plaintext highlighter-rouge">ServerSocketChannel</code>：</p><ol><li><code class="language-plaintext highlighter-rouge">open</code></li><li><code class="language-plaintext highlighter-rouge">bind</code></li><li><code class="language-plaintext highlighter-rouge">configureBlocking(false)</code>：给listen状态的Socket设置非阻塞</li></ol><p><code class="language-plaintext highlighter-rouge">SocketChannel</code>：</p><ol><li><code class="language-plaintext highlighter-rouge">configureBlocking(false)</code>：给客户端连接设置非阻塞</li></ol><p>让我们联系一段代码例子来解释网络NIO：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="cm">/**
 * @author kol Huang
 * @date 2021/4/26
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SocketNIO</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">SocketChannel</span><span class="o">&gt;</span> <span class="n">clients</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="nc">ServerSocketChannel</span> <span class="n">ss</span> <span class="o">=</span> <span class="nc">ServerSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
    <span class="n">ss</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="mi">9090</span><span class="o">));</span><span class="c1">//bind(9090, 0)</span>
    <span class="n">ss</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span><span class="c1">//设置监听非阻塞</span>

    <span class="n">ss</span><span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">StandardSocketOptions</span><span class="o">.</span><span class="na">TCP_NODELAY</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

    <span class="k">for</span><span class="o">(;;){</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
      <span class="nc">SocketChannel</span> <span class="n">client</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span><span class="c1">//不会阻塞</span>

      <span class="k">if</span><span class="o">(</span><span class="n">client</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"null addition client..."</span><span class="o">);</span>
      <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="n">client</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span><span class="c1">//设置客户端连接非阻塞</span>
        <span class="n">clients</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">client</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="nc">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="mi">4096</span><span class="o">);</span><span class="c1">//分配一个缓冲区在JVM堆外，在进程堆内</span>

      <span class="k">for</span> <span class="o">(</span><span class="nc">SocketChannel</span> <span class="n">c</span> <span class="o">:</span> <span class="n">clients</span><span class="o">)</span> <span class="o">{</span><span class="c1">//轮询所有客户端连接Socket，有数据我就读</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
          <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span><span class="c1">//开始读，在读的时候将limit指向pos，让pos指向0，这样能读取已写入的字节；（读写行为交替）</span>
          <span class="kt">byte</span><span class="o">[]</span> <span class="n">aaa</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">buffer</span><span class="o">.</span><span class="na">limit</span><span class="o">()];</span>
          <span class="n">buffer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">aaa</span><span class="o">);</span><span class="c1">//把bytebuffer里的字节读到字符数组中</span>
          <span class="c1">//进一步对读到的字节数据进行处理</span>
          <span class="c1">//...</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>


</pre></table></code></div></div><p>以上代码就在一个主线程里接收所有的客户端连接，都放入一个列表<code class="language-plaintext highlighter-rouge">clients</code>中，并且服务端监听和客户端<code class="language-plaintext highlighter-rouge">read</code>都是非阻塞的，所以一个线程就能搞定所有的连接，问题就是所有数据都由一个线程处理，性能还是有瓶颈。连接是连接，我们一个主线程在不考虑内存等其他制约因素的情况下，可以接受几百万的客户端连接，但是由于服务器其他资源的限制，我们在处理这些连接的时候，肯定会遇到瓶颈。比如我们Linux服务器默认单个进程打开的文件描述符限制是1024。此外，内核会根据内存大小估算最大的文件描述符，基本上1G内存对应10万文件描述符。</p><p>NIO的弊端：前面说，在一个线程里通过非阻塞的系统调用能够实现几十万的连接建立，但是我们在处理连接的时候，都是将所有的连接遍历一遍，调用其recv方法。我们以经典的C10K问题来举例，假设当前服务端有10000个客户端连接，那么我们在每个循环中都要调用1万次recv方法，这1万次recv方法很可能有很大一部分的返回值会是-1，也就是啥也没读到，但是我们还是需要去遍历它们。对于那些空闲的连接，我们还是要一次一次地去遍历它，遍历一个连接就意味着进行一次系统调用，就会进行一次用户态和内核态的切换（80中断，保护现场，操作PSW等寄存器等等等等耗时的操作，如果有读到数据，那么这些耗时是可以接受的，但是关键是很可能读不到数据），性能瓶颈就出现在这里。</p><p>以上代码执行时，Java代码和系统调用的对应关系：</p><ol><li><p><code class="language-plaintext highlighter-rouge">ServerSocketChannel.open();</code> ————&gt; <code class="language-plaintext highlighter-rouge">socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 6</code>，打开一个Socket，分配一个文件描述符<code class="language-plaintext highlighter-rouge">6</code>。这个Socket用于监听客户端连接。如下图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210513105635222.png" alt="image-20210513105635222" /></p></li><li><p><code class="language-plaintext highlighter-rouge">ss.bind(new InetSocketAddress(9090));</code> —————&gt; <code class="language-plaintext highlighter-rouge">bind(6, {sa_family=AF_INET, sin_port=htons(9090), sin_addr=inet_addr("0.0.0.0")}, 16) = 0</code>，将端口绑定到上面那个Socket上，并开启监听<code class="language-plaintext highlighter-rouge">listen(6, 50)</code>。</p></li><li><p><code class="language-plaintext highlighter-rouge">SocketChannel client = ss.accept();</code> —————-&gt; <code class="language-plaintext highlighter-rouge">accept(6, 0x7f217c0f6960, 0x7f2184239754) = -1 EAGAIN (Resource temporarily unavailable)</code>，由于是非阻塞的，此次accept没有接收到客户端连接，所以返回-1 。</p></li><li><p><code class="language-plaintext highlighter-rouge">accept(6, {sa_family=AF_INET, sin_port=htons(54280), sin_addr=inet_addr("127.0.0.1")}, [16]) = 7</code>，当接收到客户端请求后，内核会创建一个与客户端的连接Socket，accept会返回一个文件描述符表示这个Socket。</p></li><li><p><code class="language-plaintext highlighter-rouge">ByteBuffer.allocateDirect(4096);</code> ————–&gt; <code class="language-plaintext highlighter-rouge">mprotect(0x7f217c100000, 4096, PROT_READ|PROT_WRITE) = 0</code>，修改这块<code class="language-plaintext highlighter-rouge">0x7f217c100000</code>起始的4096字节内存的访问权限，把这块拿来作为堆外缓冲区。</p></li><li><p><code class="language-plaintext highlighter-rouge">channel.read(buffer)</code> ———-&gt; <code class="language-plaintext highlighter-rouge">read(7, "sdadsadsad\n", 4096) = 11</code>，从管道中读数据到缓冲区，也就是调用System Call read 到文件描述符为7的Socket的接收队列里把数据读到Java程序的堆区内，JVM堆外的buffer里。</p></li></ol><p><strong>多路复用器登场！</strong></p><p>多路复用通俗的理解就是多个IO连接（路）的<strong>状态</strong>通过一次系统调用就能传递给进程。于是我们需要一个多路复用器去完成这些事情，然后进程根据IO连接的状态去具体的连接上recv。</p><p>常见的Linux内核多路复用器有三种：select, poll以及epoll</p><p><strong>select</strong></p><p>select的使用方式：在用户程序（JVM）里创建一个文件描述符数组，里面存我们关心的文件描述符，每次循环都将这个FD数组传递到内核中，内核会将这个FD数组作为参数（readfds, writefds, errorfds）通过系统调用select去查看这些fd集合有哪些已经是准备好了（可读、或可写），具体select会返回一个数字代表准备好的描述符数目，-1代表发生了错误，0有可能代表超时。内核会对进程传递进来的文件描述符集合进行轮询，将没有发生事件的文件描述符删除，最后拷贝到用户区和数组中的文件描述符进行比对，然后进程再调用recv等系统调用去操作那些有事件发生的文件描述符。</p><p>select的缺点：</p><ul><li>select最大的缺陷就是<strong>单个进程打开的文件描述符是有一定限制</strong>的，默认值是1024。当然通过修改ulimit或者修改内核的一个参数（proc/sys/fs/file-max）来增加这个限制，但是由于select采用轮询方式扫描文件描述符。文件描述符数量越多，性能越差。</li><li><strong>内核/用户数据拷贝频繁，操作复杂</strong>。select在调用之前，需要手动在应用程序里将要监控的文件描述符添加到fed_set集合中。然后加载到内核进行监控。用户为了检测事件是否发生，还需要在用户程序手动维护一个数组，存储监控文件描述符。当内核事件发生，在将fed_set集合中没有发生事件的文件描述符清空，然后拷贝到用户区，和数组中的文件描述符进行比对。再调用select也是如此。每次调用，都需要来回拷贝。</li><li><strong>需要轮询，所以效率低</strong>。select返回的是整个数组的句柄。应用程序需要遍历整个数组才知道谁发生了变化。轮询代价大。</li><li><strong>select是水平触发</strong>。应用程序如果<strong>没有完成</strong>对一个已经就绪的文件描述符进行的IO操作。那么之后select调用还是会将这些文件描述符返回，通知进程。</li></ul><p><strong>poll</strong></p><p>poll的机制和select类似，本质上没有多大的区别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p>select将要监控的文件描述符按状态分为三个fd_set，分别是write, read和error；poll则是通过两个short变量，通过一个位图的数据结构来表示进程对这个FD要关心的事件。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210426210735631.png" alt="image-20210426210735631" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210426210752599.png" alt="image-20210426210752599" /></p><p>使用poll()和select()不一样，不需要显式地请求异常情况报告。 POLLIN | POLLPRI等价于select()的读事件，POLLOUT |POLLWRBAND等价于select()的写事件。POLLIN等价于POLLRDNORM |POLLRDBAND，而POLLOUT则等价于POLLWRNORM。例如，要同时监视一个文件描述符是否可读和可写，我们可以设置 events为POLLIN |POLLOUT。在poll返回时，我们可以检查revents中的标志，对应于文件描述符请求的events结构体。如果POLLIN事件被设置，则文件描述符可以被读取而不阻塞。如果POLLOUT被设置，则文件描述符可以写入而不导致阻塞。这些标志并不是互斥的：它们可能被同时设置，表示这个文件描述符的读取和写入操作都会正常返回而不阻塞。</p><p>多路复用器<code class="language-plaintext highlighter-rouge">select/poll</code>的弊端：</p><ol><li>每次都要重新重复传递fds（内核开辟空间）</li><li>每次内核被调用了之后，针对这次调用，触发了一个遍历fds全量的操作</li></ol><p>所以在2.6内核中提出了epoll。</p><p><strong>epoll</strong></p><p>epoll是上面两种多路复用器的升级版，通过三个系统调用来创建和管理epoll实例，值得一提的是epoll不是一个系统调用，是一个协议、惯例或者标准。三个系统调用如下：</p><ol><li><code class="language-plaintext highlighter-rouge">epoll_create</code>：创建一个epoll实例并返回引用该实例的文件描述符。</li><li><code class="language-plaintext highlighter-rouge">epoll_ctl</code>：通过epoll_ctl<strong>注册</strong>指定文件描述符集合。</li><li><code class="language-plaintext highlighter-rouge">epoll_wait</code> ：等待I / O事件，如果当前没有可用的事件，则阻塞调用线程。</li></ol><p>具体过程如下：首先调用epoll_create创建红黑树空间，然后执行epoll_ctl将这个红黑树空间的文件描述符和监听Socket的文件描述符关联，当有IO发生时，记录IO的编号，并存在一个链表中，当发生epoll_wait系统调用的时候，会将这个记录 有事件IO的链表返回，用户程序只需要根据这个链表上记录的信息读写产生事件的IO描述符即可。画张图加深理解：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://hyc-pic.oss-cn-hangzhou.aliyuncs.com/image-20210426214637595.png" alt="image-20210426214637595" /></p><p>工作模式：</p><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p><ul><li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li><li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li><li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li></ul><p>多路复用器的部分内容参考自：https://www.cnblogs.com/Courage129/p/14295476.html</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=浅析Java NIO - 黄玉才的博客&url=www.yucaihuang.com/posts/java-nio/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=浅析Java NIO - 黄玉才的博客&u=www.yucaihuang.com/posts/java-nio/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=浅析Java NIO - 黄玉才的博客&url=www.yucaihuang.com/posts/java-nio/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/web-url-with-chinese-string/">URL包含中文，请求资源404</a></li><li><a href="/posts/web-docker_2/">Docker：入门</a></li><li><a href="/posts/web-docker_1/">Docker：概述</a></li><li><a href="/posts/web-delete-system-python-in-centos/">centOS误删系统自带python</a></li><li><a href="/posts/springboot-starter-id/">创建自定义Springboot starter</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a> <a class="post-tag" href="/tags/jvm/">Jvm</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/java-access-control/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 12, 2020 <i class="unloaded">2020-09-12T18:39:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java访问控制</h3><div class="text-muted small"><p> 父类引用只能调用父类中定义的方法和变量。 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。 还有一种特殊情形，当子类重写了父类的某个方法时，子类的父类引用调用了一个父类的其他方法，这个方法中调用了被重写的父类方法，那么执行的结果会是被重写过后的父类方法，并不会执行原来的父类方法。具体示例如下： class F...</p></div></div></a></div><div class="card"> <a href="/posts/java-meta-annotation/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 25, 2020 <i class="unloaded">2020-09-25T10:17:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java的四个元注解</h3><div class="text-muted small"><p> @Target 描述注解的使用范围，即被修饰的注解可以用在什么地方。 注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数） publi...</p></div></div></a></div><div class="card"> <a href="/posts/design-pattern/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > May 6 <i class="unloaded">2021-05-06T18:49:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式的六大原则 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象放在程序设计的高层，并保持稳定，程序的细节变化由底层...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/design-pattern/" class="btn btn-outline-primary"><p>设计模式</p></a> <a href="/posts/jvm-classfile-resolve/" class="btn btn-outline-primary"><p>JVM：记一次完整的类文件分析过程</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><p class="footer-center"> © 2021 <a href="">Yucai Huang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span> <br> <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2020032055号-1</a></p></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Java源码学习</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/jvm/">jvm</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/redis/">redis</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a> <a class="post-tag" href="/tags/jvm/">Jvm</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-176388509-1', 'auto'); ga('send', 'pageview'); </script> <script> (function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)} ;a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s ;c.parentNode.insertBefore(a,c) })(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js"); galite('create', '{"id"=>"UA-176388509-1", "pv"=>{"enabled"=>false, "proxy_url"=>"", "proxy_endpoint"=>"", "cache"=>true}}', 'auto'); galite('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="www.yucaihuang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
